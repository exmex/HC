; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	H:\Source\HG\Client\Code_Core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT

PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?minInt@Value@Json@@2HB				; Json::Value::minInt
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?maxInt@Value@Json@@2HB				; Json::Value::maxInt
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?maxUInt@Value@Json@@2IB			; Json::Value::maxUInt
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
CONST	SEGMENT
?minInt@Value@Json@@2HB DD 080000000H			; Json::Value::minInt
?maxInt@Value@Json@@2HB DD 07fffffffH			; Json::Value::maxInt
?maxUInt@Value@Json@@2IB DD 0ffffffffH			; Json::Value::maxUInt
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
PUBLIC	_hypot
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC	?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??0runtime_error@std@@QAE@PBD@Z			; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	??$swap@H@std@@YAXAAH0@Z			; std::swap<int>
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	??0StaticString@Json@@QAE@PBD@Z			; Json::StaticString::StaticString
PUBLIC	??BStaticString@Json@@QBEPBDXZ			; Json::StaticString::operator char const *
PUBLIC	?c_str@StaticString@Json@@QBEPBDXZ		; Json::StaticString::c_str
PUBLIC	??0CZString@Value@Json@@QAE@H@Z			; Json::Value::CZString::CZString
PUBLIC	??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ; Json::Value::CZString::CZString
PUBLIC	??0CZString@Value@Json@@QAE@ABV012@@Z		; Json::Value::CZString::CZString
PUBLIC	??1CZString@Value@Json@@QAE@XZ			; Json::Value::CZString::~CZString
PUBLIC	??4CZString@Value@Json@@QAEAAV012@ABV012@@Z	; Json::Value::CZString::operator=
PUBLIC	??MCZString@Value@Json@@QBE_NABV012@@Z		; Json::Value::CZString::operator<
PUBLIC	??8CZString@Value@Json@@QBE_NABV012@@Z		; Json::Value::CZString::operator==
PUBLIC	?index@CZString@Value@Json@@QBEHXZ		; Json::Value::CZString::index
PUBLIC	?c_str@CZString@Value@Json@@QBEPBDXZ		; Json::Value::CZString::c_str
PUBLIC	?isStaticString@CZString@Value@Json@@QBE_NXZ	; Json::Value::CZString::isStaticString
PUBLIC	?swap@CZString@Value@Json@@AAEXAAV123@@Z	; Json::Value::CZString::swap
PUBLIC	??0Value@Json@@QAE@W4ValueType@1@@Z		; Json::Value::Value
PUBLIC	??0Value@Json@@QAE@H@Z				; Json::Value::Value
PUBLIC	??0Value@Json@@QAE@I@Z				; Json::Value::Value
PUBLIC	??0Value@Json@@QAE@N@Z				; Json::Value::Value
PUBLIC	??0Value@Json@@QAE@PBD@Z			; Json::Value::Value
PUBLIC	??0Value@Json@@QAE@PBD0@Z			; Json::Value::Value
PUBLIC	??0Value@Json@@QAE@ABVStaticString@1@@Z		; Json::Value::Value
PUBLIC	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::Value
PUBLIC	??0Value@Json@@QAE@_N@Z				; Json::Value::Value
PUBLIC	??0Value@Json@@QAE@ABV01@@Z			; Json::Value::Value
PUBLIC	??1Value@Json@@QAE@XZ				; Json::Value::~Value
PUBLIC	??4Value@Json@@QAEAAV01@ABV01@@Z		; Json::Value::operator=
PUBLIC	?swap@Value@Json@@QAEXAAV12@@Z			; Json::Value::swap
PUBLIC	?type@Value@Json@@QBE?AW4ValueType@2@XZ		; Json::Value::type
PUBLIC	??MValue@Json@@QBE_NABV01@@Z			; Json::Value::operator<
PUBLIC	??NValue@Json@@QBE_NABV01@@Z			; Json::Value::operator<=
PUBLIC	??PValue@Json@@QBE_NABV01@@Z			; Json::Value::operator>=
PUBLIC	??OValue@Json@@QBE_NABV01@@Z			; Json::Value::operator>
PUBLIC	??8Value@Json@@QBE_NABV01@@Z			; Json::Value::operator==
PUBLIC	??9Value@Json@@QBE_NABV01@@Z			; Json::Value::operator!=
PUBLIC	?compare@Value@Json@@QAEHABV12@@Z		; Json::Value::compare
PUBLIC	?asCString@Value@Json@@QBEPBDXZ			; Json::Value::asCString
PUBLIC	?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Value::asString
PUBLIC	?asInt@Value@Json@@QBEHXZ			; Json::Value::asInt
PUBLIC	?asUInt@Value@Json@@QBEIXZ			; Json::Value::asUInt
PUBLIC	?asDouble@Value@Json@@QBENXZ			; Json::Value::asDouble
PUBLIC	?asBool@Value@Json@@QBE_NXZ			; Json::Value::asBool
PUBLIC	?isNull@Value@Json@@QBE_NXZ			; Json::Value::isNull
PUBLIC	?isBool@Value@Json@@QBE_NXZ			; Json::Value::isBool
PUBLIC	?isInt@Value@Json@@QBE_NXZ			; Json::Value::isInt
PUBLIC	?isUInt@Value@Json@@QBE_NXZ			; Json::Value::isUInt
PUBLIC	?isIntegral@Value@Json@@QBE_NXZ			; Json::Value::isIntegral
PUBLIC	?isDouble@Value@Json@@QBE_NXZ			; Json::Value::isDouble
PUBLIC	?isNumeric@Value@Json@@QBE_NXZ			; Json::Value::isNumeric
PUBLIC	?isString@Value@Json@@QBE_NXZ			; Json::Value::isString
PUBLIC	?isArray@Value@Json@@QBE_NXZ			; Json::Value::isArray
PUBLIC	?isObject@Value@Json@@QBE_NXZ			; Json::Value::isObject
PUBLIC	?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z ; Json::Value::isConvertibleTo
PUBLIC	?size@Value@Json@@QBEIXZ			; Json::Value::size
PUBLIC	?empty@Value@Json@@QBE_NXZ			; Json::Value::empty
PUBLIC	??7Value@Json@@QBE_NXZ				; Json::Value::operator!
PUBLIC	?clear@Value@Json@@QAEXXZ			; Json::Value::clear
PUBLIC	?resize@Value@Json@@QAEXI@Z			; Json::Value::resize
PUBLIC	??AValue@Json@@QAEAAV01@I@Z			; Json::Value::operator[]
PUBLIC	??AValue@Json@@QBEABV01@I@Z			; Json::Value::operator[]
PUBLIC	?get@Value@Json@@QBE?AV12@IABV12@@Z		; Json::Value::get
PUBLIC	?isValidIndex@Value@Json@@QBE_NI@Z		; Json::Value::isValidIndex
PUBLIC	?append@Value@Json@@QAEAAV12@ABV12@@Z		; Json::Value::append
PUBLIC	??AValue@Json@@QAEAAV01@PBD@Z			; Json::Value::operator[]
PUBLIC	??AValue@Json@@QBEABV01@PBD@Z			; Json::Value::operator[]
PUBLIC	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
PUBLIC	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
PUBLIC	??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z	; Json::Value::operator[]
PUBLIC	?get@Value@Json@@QBE?AV12@PBDABV12@@Z		; Json::Value::get
PUBLIC	?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ; Json::Value::get
PUBLIC	?removeMember@Value@Json@@QAE?AV12@PBD@Z	; Json::Value::removeMember
PUBLIC	?removeMember@Value@Json@@QAE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::removeMember
PUBLIC	?isMember@Value@Json@@QBE_NPBD@Z		; Json::Value::isMember
PUBLIC	?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::isMember
PUBLIC	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
PUBLIC	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment
PUBLIC	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
PUBLIC	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
PUBLIC	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
PUBLIC	?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Value::toStyledString
PUBLIC	?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ ; Json::Value::begin
PUBLIC	?end@Value@Json@@QBE?AVValueConstIterator@2@XZ	; Json::Value::end
PUBLIC	?begin@Value@Json@@QAE?AVValueIterator@2@XZ	; Json::Value::begin
PUBLIC	?end@Value@Json@@QAE?AVValueIterator@2@XZ	; Json::Value::end
PUBLIC	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z	; Json::Value::resolveReference
PUBLIC	??0CommentInfo@Value@Json@@QAE@XZ		; Json::Value::CommentInfo::CommentInfo
PUBLIC	??1CommentInfo@Value@Json@@QAE@XZ		; Json::Value::CommentInfo::~CommentInfo
PUBLIC	?setComment@CommentInfo@Value@Json@@QAEXPBD@Z	; Json::Value::CommentInfo::setComment
PUBLIC	??_ECommentInfo@Value@Json@@QAEPAXI@Z		; Json::Value::CommentInfo::`vector deleting destructor'
PUBLIC	??0PathArgument@Json@@QAE@XZ			; Json::PathArgument::PathArgument
PUBLIC	??0PathArgument@Json@@QAE@I@Z			; Json::PathArgument::PathArgument
PUBLIC	??0PathArgument@Json@@QAE@PBD@Z			; Json::PathArgument::PathArgument
PUBLIC	??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::PathArgument::PathArgument
PUBLIC	??1PathArgument@Json@@QAE@XZ			; Json::PathArgument::~PathArgument
PUBLIC	??0PathArgument@Json@@QAE@ABV01@@Z		; Json::PathArgument::PathArgument
PUBLIC	??_GPathArgument@Json@@QAEPAXI@Z		; Json::PathArgument::`scalar deleting destructor'
PUBLIC	??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z ; Json::Path::Path
PUBLIC	?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z	; Json::Path::resolve
PUBLIC	?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z	; Json::Path::resolve
PUBLIC	?make@Path@Json@@QBEAAVValue@2@AAV32@@Z		; Json::Path::make
PUBLIC	?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z ; Json::Path::makePath
PUBLIC	??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
PUBLIC	?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::deallocate
PUBLIC	?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::allocate
PUBLIC	?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument const *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAIABV?$allocator@PBVPathArgument@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::PathArgument const *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::_Wrap_alloc<std::allocator<Json::PathArgument const *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEPAPBVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Json::PathArgument const *> >::_Vector_val<std::_Simple_types<Json::PathArgument const *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PBVPathArgument@Json@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal
PUBLIC	??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEX$$QAPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back
PUBLIC	??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
PUBLIC	?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
PUBLIC	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
PUBLIC	?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
PUBLIC	?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEII@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBE_NPBQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Orphan_range
PUBLIC	?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@4@W4Kind@PathArgument@2@@Z ; Json::Path::addPathInArg
PUBLIC	?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::Path::invalidPath
PUBLIC	??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ	; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
PUBLIC	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate
PUBLIC	?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::allocate
PUBLIC	?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ; std::allocator<Json::PathArgument>::construct
PUBLIC	?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAIABV?$allocator@VPathArgument@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::_Wrap_alloc<std::allocator<Json::PathArgument> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Json::PathArgument> >::_Vector_val<std::_Simple_types<Json::PathArgument> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
PUBLIC	??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEX$$QAVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
PUBLIC	??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
PUBLIC	?_Unused_capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Unused_capacity
PUBLIC	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
PUBLIC	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
PUBLIC	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
PUBLIC	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
PUBLIC	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
PUBLIC	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy
PUBLIC	?_Grow_to@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEII@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Grow_to
PUBLIC	?_Inside@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBE_NPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Inside
PUBLIC	?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reallocate
PUBLIC	?_Reserve@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reserve
PUBLIC	?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy
PUBLIC	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Orphan_range
PUBLIC	??1ValueAllocator@Json@@UAE@XZ			; Json::ValueAllocator::~ValueAllocator
PUBLIC	??0ValueAllocator@Json@@QAE@XZ			; Json::ValueAllocator::ValueAllocator
PUBLIC	??_GValueAllocator@Json@@UAEPAXI@Z		; Json::ValueAllocator::`scalar deleting destructor'
PUBLIC	??0ValueIteratorBase@Json@@QAE@XZ		; Json::ValueIteratorBase::ValueIteratorBase
PUBLIC	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
PUBLIC	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	?select_on_container_copy_construction@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBE?AV12@XZ ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::select_on_container_copy_construction
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocate
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::max_size
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Min
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Buyheadnode
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Freeheadnode
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
PUBLIC	??0?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Freenode0
PUBLIC	??1?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@XZ ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Destroy_if_not_nil
PUBLIC	?_Eqrange@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Eqrange
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
PUBLIC	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::`scalar deleting destructor'
PUBLIC	??0ValueIteratorBase@Json@@QAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ; Json::ValueIteratorBase::ValueIteratorBase
PUBLIC	?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ	; Json::ValueIteratorBase::key
PUBLIC	?index@ValueIteratorBase@Json@@QBEIXZ		; Json::ValueIteratorBase::index
PUBLIC	?memberName@ValueIteratorBase@Json@@QBEPBDXZ	; Json::ValueIteratorBase::memberName
PUBLIC	?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ	; Json::ValueIteratorBase::deref
PUBLIC	?increment@ValueIteratorBase@Json@@IAEXXZ	; Json::ValueIteratorBase::increment
PUBLIC	?decrement@ValueIteratorBase@Json@@IAEXXZ	; Json::ValueIteratorBase::decrement
PUBLIC	?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z ; Json::ValueIteratorBase::computeDistance
PUBLIC	?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z	; Json::ValueIteratorBase::isEqual
PUBLIC	?copy@ValueIteratorBase@Json@@IAEXABV12@@Z	; Json::ValueIteratorBase::copy
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>
PUBLIC	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator!=
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
PUBLIC	?_Unchecked@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Unchecked
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator!=
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator->
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--
PUBLIC	??0ValueConstIterator@Json@@QAE@XZ		; Json::ValueConstIterator::ValueConstIterator
PUBLIC	??0ValueConstIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ; Json::ValueConstIterator::ValueConstIterator
PUBLIC	??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z ; Json::ValueConstIterator::operator=
PUBLIC	??0ValueIterator@Json@@QAE@XZ			; Json::ValueIterator::ValueIterator
PUBLIC	??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z ; Json::ValueIterator::ValueIterator
PUBLIC	??0ValueIterator@Json@@QAE@ABV01@@Z		; Json::ValueIterator::ValueIterator
PUBLIC	??0ValueIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ; Json::ValueIterator::ValueIterator
PUBLIC	??4ValueIterator@Json@@QAEAAV01@ABV01@@Z	; Json::ValueIterator::operator=
PUBLIC	??1StyledWriter@Json@@UAE@XZ			; Json::StyledWriter::~StyledWriter
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@$$QAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Assign_rv@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_rv
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
PUBLIC	?_Unused_capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unused_capacity
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Grow_to@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEII@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Grow_to
PUBLIC	?_Inside@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Inside
PUBLIC	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
PUBLIC	?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
PUBLIC	??_GStyledWriter@Json@@UAEPAXI@Z		; Json::StyledWriter::`scalar deleting destructor'
PUBLIC	??1DefaultValueAllocator@Json@@UAE@XZ		; Json::DefaultValueAllocator::~DefaultValueAllocator
PUBLIC	?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z ; Json::DefaultValueAllocator::makeMemberName
PUBLIC	?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z ; Json::DefaultValueAllocator::releaseMemberName
PUBLIC	?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z ; Json::DefaultValueAllocator::duplicateStringValue
PUBLIC	?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z ; Json::DefaultValueAllocator::releaseStringValue
PUBLIC	??0DefaultValueAllocator@Json@@QAE@XZ		; Json::DefaultValueAllocator::DefaultValueAllocator
PUBLIC	??_GDefaultValueAllocator@Json@@UAEPAXI@Z	; Json::DefaultValueAllocator::`scalar deleting destructor'
PUBLIC	??0DummyValueAllocatorInitializer@Json@@QAE@XZ	; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer
PUBLIC	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ ; std::pair<Json::Value::CZString const ,Json::Value>::~pair<Json::Value::CZString const ,Json::Value>
PUBLIC	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
PUBLIC	??_G?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAEPAXI@Z ; std::pair<Json::Value::CZString const ,Json::Value>::`scalar deleting destructor'
PUBLIC	??$swap@PBD@std@@YAXAAPBD0@Z			; std::swap<char const *>
PUBLIC	??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z ; std::swap<Json::Value::ValueHolder>
PUBLIC	??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value><Json::Value::CZString &,Json::Value const &,void>
PUBLIC	??$insert@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert<std::pair<Json::Value::CZString const ,Json::Value> &>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::operator*
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::operator==
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::_Compat
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEABVPathArgument@Json@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::_Compat
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPBV12@@Z ; std::addressof<Json::PathArgument const *>
PUBLIC	??$forward@PBVPathArgument@Json@@@std@@YA$$QAPBVPathArgument@Json@@AAPBV12@@Z ; std::forward<Json::PathArgument const *>
PUBLIC	??$construct@PBVPathArgument@Json@@PBV12@@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::construct<Json::PathArgument const *,Json::PathArgument const *>
PUBLIC	??$addressof@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAV12@@Z ; std::addressof<Json::PathArgument>
PUBLIC	??$forward@VPathArgument@Json@@@std@@YA$$QAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument>
PUBLIC	??$construct@VPathArgument@Json@@V12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>
PUBLIC	??$addressof@$$CBVPathArgument@Json@@@std@@YAPBVPathArgument@Json@@ABV12@@Z ; std::addressof<Json::PathArgument const >
PUBLIC	??$construct@VPathArgument@Json@@AAV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument &>
PUBLIC	??$construct@VPathArgument@Json@@ABV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@ABV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument const &>
PUBLIC	??$?0U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> ><std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	??$addressof@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAPAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::addressof<std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,unsigned int>
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@SAPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@AAU32@@Z ; std::pointer_traits<std::pair<Json::Value::CZString const ,Json::Value> *>::pointer_to
PUBLIC	??$forward@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAV10@@Z ; std::forward<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy<std::integral_constant<bool,0> >
PUBLIC	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
PUBLIC	??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
PUBLIC	??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@0@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,void>
PUBLIC	??$_Kfn@$$CBVCZString@Value@Json@@V23@@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn<Json::Value::CZString const ,Json::Value>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z ; std::_Allocate<Json::PathArgument const *>
PUBLIC	??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ; std::_Allocate<Json::PathArgument>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
PUBLIC	??$_Move@AAH@std@@YA$$QAHAAH@Z			; std::_Move<int &>
PUBLIC	??$_Move@AAPBD@std@@YA$$QAPBDAAPBD@Z		; std::_Move<char const * &>
PUBLIC	??$_Move@AATValueHolder@Value@Json@@@std@@YA$$QATValueHolder@Value@Json@@AAT123@@Z ; std::_Move<Json::Value::ValueHolder &>
PUBLIC	??$lexicographical_compare@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@000@Z ; std::lexicographical_compare<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
PUBLIC	??$equal@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@00@Z ; std::equal<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
PUBLIC	??$forward@AAVCZString@Value@Json@@@std@@YAAAVCZString@Value@Json@@AAV123@@Z ; std::forward<Json::Value::CZString &>
PUBLIC	??$forward@ABVValue@Json@@@std@@YAABVValue@Json@@ABV12@@Z ; std::forward<Json::Value const &>
PUBLIC	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
PUBLIC	??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Buynode<std::pair<Json::Value::CZString const ,Json::Value> &>
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_hint<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
PUBLIC	??$construct@PBVPathArgument@Json@@PBV12@@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@PBVPathArgument@Json@@@1@PAPBVPathArgument@Json@@$$QAPBV34@@Z ; std::allocator_traits<std::allocator<Json::PathArgument const *> >::construct<Json::PathArgument const *,Json::PathArgument const *>
PUBLIC	??$construct@VPathArgument@Json@@V12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@$$QAV34@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>
PUBLIC	??$forward@AAVPathArgument@Json@@@std@@YAAAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument &>
PUBLIC	??$construct@VPathArgument@Json@@AAV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@AAV34@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument &>
PUBLIC	??$forward@ABVPathArgument@Json@@@std@@YAABVPathArgument@Json@@ABV12@@Z ; std::forward<Json::PathArgument const &>
PUBLIC	??$construct@VPathArgument@Json@@ABV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@ABV34@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument const &>
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
PUBLIC	??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
PUBLIC	??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,unsigned int>
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
PUBLIC	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$_Ptr_cat@PBVPathArgument@Json@@PBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument const *,Json::PathArgument const *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
PUBLIC	??$_Uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z ; std::_Uninitialized_move<Json::PathArgument const * *,Json::PathArgument const * *,std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
PUBLIC	??$_Ptr_cat@VPathArgument@Json@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument,Json::PathArgument>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
PUBLIC	??$_Uninitialized_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ; std::_Uninitialized_move<Json::PathArgument *,Json::PathArgument *,std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
PUBLIC	??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
PUBLIC	??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
PUBLIC	??$_Lexicographical_compare@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@000@Z ; std::_Lexicographical_compare<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0> >
PUBLIC	??$_Equal@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@00@Z ; std::_Equal<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0> >
PUBLIC	??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_nohint<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
PUBLIC	??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z ; std::allocator<Json::PathArgument const *>::construct<Json::PathArgument const *,Json::PathArgument const *>
PUBLIC	??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z ; std::allocator<Json::PathArgument>::construct<Json::PathArgument,Json::PathArgument>
PUBLIC	??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z ; std::allocator<Json::PathArgument>::construct<Json::PathArgument,Json::PathArgument &>
PUBLIC	??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$_Copy_or_move@U?$integral_constant@_N$0A@@std@@U?$integral_constant@_N$00@2@U12@H@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@U?$integral_constant@_N$0A@@1@U?$integral_constant@_N$00@1@1H@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_or_move<std::integral_constant<bool,0>,std::integral_constant<bool,1>,std::integral_constant<bool,0>,int>
PUBLIC	??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$_Rechecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Unchecked@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z ; std::_Unchecked<Json::PathArgument const * *>
PUBLIC	??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z ; std::_Uninit_move<Json::PathArgument const * *,Json::PathArgument const * *,std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
PUBLIC	??$_Rechecked@PAPBVPathArgument@Json@@PAPBV12@@std@@YAAAPAPBVPathArgument@Json@@AAPAPBV12@PAPBV12@@Z ; std::_Rechecked<Json::PathArgument const * *,Json::PathArgument const * *>
PUBLIC	??$destroy@VPathArgument@Json@@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::destroy<Json::PathArgument>
PUBLIC	??$_Unchecked@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z ; std::_Unchecked<Json::PathArgument *>
PUBLIC	??$_Uninit_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
PUBLIC	??$_Rechecked@PAVPathArgument@Json@@PAV12@@std@@YAAAPAVPathArgument@Json@@AAPAV12@PAV12@@Z ; std::_Rechecked<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
PUBLIC	??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator<<Json::Value::CZString const ,Json::Value>
PUBLIC	??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator==<Json::Value::CZString const ,Json::Value>
PUBLIC	??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>
PUBLIC	??$_Buynode_if_nil@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode_if_nil<std::pair<Json::Value::CZString const ,Json::Value> &>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool,void>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,bool,void>
PUBLIC	??$_Val_type@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Val_type@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z ; std::_Val_type<Json::PathArgument const * *>
PUBLIC	??$_Uninit_move@PBVPathArgument@Json@@PBV12@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Json::PathArgument const *,Json::PathArgument const *,Json::PathArgument const *>
PUBLIC	??$destroy@VPathArgument@Json@@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::destroy<Json::PathArgument>
PUBLIC	??$_Val_type@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z ; std::_Val_type<Json::PathArgument *>
PUBLIC	??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument>,Json::PathArgument>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$destroy@VPathArgument@Json@@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy<Json::PathArgument>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?null@Value@Json@@2V12@B			; Json::Value::null
PUBLIC	??_7ValueAllocator@Json@@6B@			; Json::ValueAllocator::`vftable'
PUBLIC	??_7StyledWriter@Json@@6B@			; Json::StyledWriter::`vftable'
PUBLIC	??_7DefaultValueAllocator@Json@@6B@		; Json::DefaultValueAllocator::`vftable'
PUBLIC	??_C@_0BL@DKGNIMPN@Comments?5must?5start?5with?5?1?$AA@ ; `string'
PUBLIC	??_C@_0CC@BNBMBIGA@Type?5is?5not?5convertible?5to?5strin@ ; `string'
PUBLIC	??_C@_0CE@MKMAPPKF@integer?5out?5of?5signed?5integer?5ra@ ; `string'
PUBLIC	??_C@_0CB@PBEICPFN@Real?5out?5of?5signed?5integer?5range@ ; `string'
PUBLIC	??_C@_0BP@KDDCHLKA@Type?5is?5not?5convertible?5to?5int?$AA@ ; `string'
PUBLIC	??_C@_0DK@NAHIGMFE@Negative?5integer?5can?5not?5be?5conv@ ; `string'
PUBLIC	??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@ ; `string'
PUBLIC	??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@ ; `string'
PUBLIC	??_C@_0CC@ICOHKFIF@Type?5is?5not?5convertible?5to?5doubl@ ; `string'
PUBLIC	??_C@_02GLFAOOJA@?$FL?4?$AA@			; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Writer@Json@@8			; Json::Writer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVWriter@Json@@@8				; Json::Writer `RTTI Type Descriptor'
PUBLIC	??_R3Writer@Json@@8				; Json::Writer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Writer@Json@@8				; Json::Writer::`RTTI Base Class Array'
PUBLIC	??_R4StyledWriter@Json@@6B@			; Json::StyledWriter::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVStyledWriter@Json@@@8			; Json::StyledWriter `RTTI Type Descriptor'
PUBLIC	??_R3StyledWriter@Json@@8			; Json::StyledWriter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2StyledWriter@Json@@8			; Json::StyledWriter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@StyledWriter@Json@@8		; Json::StyledWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ValueAllocator@Json@@6B@			; Json::ValueAllocator::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVValueAllocator@Json@@@8			; Json::ValueAllocator `RTTI Type Descriptor'
PUBLIC	??_R3ValueAllocator@Json@@8			; Json::ValueAllocator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ValueAllocator@Json@@8			; Json::ValueAllocator::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ValueAllocator@Json@@8		; Json::ValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4DefaultValueAllocator@Json@@6B@		; Json::DefaultValueAllocator::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDefaultValueAllocator@Json@@@8		; Json::DefaultValueAllocator `RTTI Type Descriptor'
PUBLIC	??_R3DefaultValueAllocator@Json@@8		; Json::DefaultValueAllocator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DefaultValueAllocator@Json@@8		; Json::DefaultValueAllocator::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DefaultValueAllocator@Json@@8	; Json::DefaultValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@41efffffffe00000
PUBLIC	__real@c1e0000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__imp___hypot:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
EXTRN	__imp_?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	__imp_??0id@locale@std@@QAE@I@Z:PROC
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	__imp_?_Syserror_map@std@@YAPBDH@Z:PROC
EXTRN	__imp_?_Winerror_map@std@@YAPBDH@Z:PROC
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	??_EValueAllocator@Json@@UAEPAXI@Z:PROC		; Json::ValueAllocator::`vector deleting destructor'
EXTRN	??1Writer@Json@@UAE@XZ:PROC			; Json::Writer::~Writer
EXTRN	??0StyledWriter@Json@@QAE@XZ:PROC		; Json::StyledWriter::StyledWriter
EXTRN	?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z:PROC ; Json::StyledWriter::write
EXTRN	??_EStyledWriter@Json@@UAEPAXI@Z:PROC		; Json::StyledWriter::`vector deleting destructor'
EXTRN	??_EDefaultValueAllocator@Json@@UAEPAXI@Z:PROC	; Json::DefaultValueAllocator::`vector deleting destructor'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__dtoui3:PROC
EXTRN	_memcpy:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

?null@Value@Json@@2V12@B DB 010H DUP (?)		; Json::Value::null
_BSS	ENDS
;	COMDAT ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A
_BSS	SEGMENT
?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A DD 01H DUP (?) ; `Json::valueAllocator'::`2'::defaultAllocator
_BSS	ENDS
;	COMDAT ?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
_BSS	SEGMENT
?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA DD 01H DUP (?) ; `Json::valueAllocator'::`2'::$S1
_BSS	ENDS
_BSS	SEGMENT
_dummyValueAllocatorInitializer DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c1e0000000000000
CONST	SEGMENT
__real@c1e0000000000000 DQ 0c1e0000000000000r	; -2.14748e+009
CONST	ENDS
;	COMDAT __real@41efffffffe00000
CONST	SEGMENT
__real@41efffffffe00000 DQ 041efffffffe00000r	; 4.29497e+009
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@DefaultValueAllocator@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DefaultValueAllocator@Json@@8 DD FLAT:??_R0?AVDefaultValueAllocator@Json@@@8 ; Json::DefaultValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DefaultValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2DefaultValueAllocator@Json@@8
rdata$r	SEGMENT
??_R2DefaultValueAllocator@Json@@8 DD FLAT:??_R1A@?0A@EA@DefaultValueAllocator@Json@@8 ; Json::DefaultValueAllocator::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3DefaultValueAllocator@Json@@8
rdata$r	SEGMENT
??_R3DefaultValueAllocator@Json@@8 DD 00H		; Json::DefaultValueAllocator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2DefaultValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDefaultValueAllocator@Json@@@8
data$r	SEGMENT
??_R0?AVDefaultValueAllocator@Json@@@8 DD FLAT:??_7type_info@@6B@ ; Json::DefaultValueAllocator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDefaultValueAllocator@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R4DefaultValueAllocator@Json@@6B@
rdata$r	SEGMENT
??_R4DefaultValueAllocator@Json@@6B@ DD 00H		; Json::DefaultValueAllocator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDefaultValueAllocator@Json@@@8
	DD	FLAT:??_R3DefaultValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ValueAllocator@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ValueAllocator@Json@@8 DD FLAT:??_R0?AVValueAllocator@Json@@@8 ; Json::ValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2ValueAllocator@Json@@8
rdata$r	SEGMENT
??_R2ValueAllocator@Json@@8 DD FLAT:??_R1A@?0A@EA@ValueAllocator@Json@@8 ; Json::ValueAllocator::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ValueAllocator@Json@@8
rdata$r	SEGMENT
??_R3ValueAllocator@Json@@8 DD 00H			; Json::ValueAllocator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVValueAllocator@Json@@@8
data$r	SEGMENT
??_R0?AVValueAllocator@Json@@@8 DD FLAT:??_7type_info@@6B@ ; Json::ValueAllocator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVValueAllocator@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R4ValueAllocator@Json@@6B@
rdata$r	SEGMENT
??_R4ValueAllocator@Json@@6B@ DD 00H			; Json::ValueAllocator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVValueAllocator@Json@@@8
	DD	FLAT:??_R3ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@StyledWriter@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@StyledWriter@Json@@8 DD FLAT:??_R0?AVStyledWriter@Json@@@8 ; Json::StyledWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3StyledWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2StyledWriter@Json@@8
rdata$r	SEGMENT
??_R2StyledWriter@Json@@8 DD FLAT:??_R1A@?0A@EA@StyledWriter@Json@@8 ; Json::StyledWriter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3StyledWriter@Json@@8
rdata$r	SEGMENT
??_R3StyledWriter@Json@@8 DD 00H			; Json::StyledWriter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2StyledWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVStyledWriter@Json@@@8
data$r	SEGMENT
??_R0?AVStyledWriter@Json@@@8 DD FLAT:??_7type_info@@6B@ ; Json::StyledWriter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVStyledWriter@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R4StyledWriter@Json@@6B@
rdata$r	SEGMENT
??_R4StyledWriter@Json@@6B@ DD 00H			; Json::StyledWriter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVStyledWriter@Json@@@8
	DD	FLAT:??_R3StyledWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2Writer@Json@@8
rdata$r	SEGMENT
??_R2Writer@Json@@8 DD FLAT:??_R1A@?0A@EA@Writer@Json@@8 ; Json::Writer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Writer@Json@@8
rdata$r	SEGMENT
??_R3Writer@Json@@8 DD 00H				; Json::Writer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWriter@Json@@@8
data$r	SEGMENT
??_R0?AVWriter@Json@@@8 DD FLAT:??_7type_info@@6B@	; Json::Writer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWriter@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Writer@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Writer@Json@@8 DD FLAT:??_R0?AVWriter@Json@@@8 ; Json::Writer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02GLFAOOJA@?$FL?4?$AA@
CONST	SEGMENT
??_C@_02GLFAOOJA@?$FL?4?$AA@ DB '[.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ICOHKFIF@Type?5is?5not?5convertible?5to?5doubl@
CONST	SEGMENT
??_C@_0CC@ICOHKFIF@Type?5is?5not?5convertible?5to?5doubl@ DB 'Type is not'
	DB	' convertible to double', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@
CONST	SEGMENT
??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@ DB 'Type is '
	DB	'not convertible to uint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@
CONST	SEGMENT
??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@ DB 'Real out of'
	DB	' unsigned integer range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NAHIGMFE@Negative?5integer?5can?5not?5be?5conv@
CONST	SEGMENT
??_C@_0DK@NAHIGMFE@Negative?5integer?5can?5not?5be?5conv@ DB 'Negative in'
	DB	'teger can not be converted to unsigned integer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KDDCHLKA@Type?5is?5not?5convertible?5to?5int?$AA@
CONST	SEGMENT
??_C@_0BP@KDDCHLKA@Type?5is?5not?5convertible?5to?5int?$AA@ DB 'Type is n'
	DB	'ot convertible to int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PBEICPFN@Real?5out?5of?5signed?5integer?5range@
CONST	SEGMENT
??_C@_0CB@PBEICPFN@Real?5out?5of?5signed?5integer?5range@ DB 'Real out of'
	DB	' signed integer range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MKMAPPKF@integer?5out?5of?5signed?5integer?5ra@
CONST	SEGMENT
??_C@_0CE@MKMAPPKF@integer?5out?5of?5signed?5integer?5ra@ DB 'integer out'
	DB	' of signed integer range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BNBMBIGA@Type?5is?5not?5convertible?5to?5strin@
CONST	SEGMENT
??_C@_0CC@BNBMBIGA@Type?5is?5not?5convertible?5to?5strin@ DB 'Type is not'
	DB	' convertible to string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DKGNIMPN@Comments?5must?5start?5with?5?1?$AA@
CONST	SEGMENT
??_C@_0BL@DKGNIMPN@Comments?5must?5start?5with?5?1?$AA@ DB 'Comments must'
	DB	' start with /', 00H				; `string'
CONST	ENDS
;	COMDAT ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
_DATA	SEGMENT
?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A DD FLAT:?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A ; `Json::valueAllocator'::`2'::valueAllocator
_DATA	ENDS
;	COMDAT ??_7DefaultValueAllocator@Json@@6B@
CONST	SEGMENT
??_7DefaultValueAllocator@Json@@6B@ DD FLAT:??_R4DefaultValueAllocator@Json@@6B@ ; Json::DefaultValueAllocator::`vftable'
	DD	FLAT:??_EDefaultValueAllocator@Json@@UAEPAXI@Z
	DD	FLAT:?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z
	DD	FLAT:?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z
	DD	FLAT:?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z
	DD	FLAT:?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z
CONST	ENDS
;	COMDAT ??_7StyledWriter@Json@@6B@
CONST	SEGMENT
??_7StyledWriter@Json@@6B@ DD FLAT:??_R4StyledWriter@Json@@6B@ ; Json::StyledWriter::`vftable'
	DD	FLAT:??_EStyledWriter@Json@@UAEPAXI@Z
	DD	FLAT:?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
CONST	ENDS
;	COMDAT ??_7ValueAllocator@Json@@6B@
CONST	SEGMENT
??_7ValueAllocator@Json@@6B@ DD FLAT:??_R4ValueAllocator@Json@@6B@ ; Json::ValueAllocator::`vftable'
	DD	FLAT:??_EValueAllocator@Json@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z$0
__ehfuncinfo$??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z$0
__ehfuncinfo$??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z$0
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z$0
__ehfuncinfo$??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z$0
__ehfuncinfo$??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z$0
__ehfuncinfo$??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$2
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z$0
__unwindtable$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z$2
__ehfuncinfo$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$2
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z$0
__unwindtable$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z$2
__ehfuncinfo$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z$0
__ehfuncinfo$??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z$0
__ehfuncinfo$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ$0
__ehfuncinfo$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?index@ValueIteratorBase@Json@@QBEIXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?index@ValueIteratorBase@Json@@QBEIXZ$0
__ehfuncinfo$?index@ValueIteratorBase@Json@@QBEIXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?index@ValueIteratorBase@Json@@QBEIXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ$0
__ehfuncinfo$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$0
__unwindtable$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$2
__ehfuncinfo$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$0
__unwindtable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$2
__ehfuncinfo$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z$0
__ehfuncinfo$?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$2
__ehfuncinfo$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z$1
__ehfuncinfo$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$2
__ehfuncinfo$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
__ehfuncinfo$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z$0
__ehfuncinfo$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$2
__ehfuncinfo$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?removeMember@Value@Json@@QAE?AV12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$2
__ehfuncinfo$?removeMember@Value@Json@@QAE?AV12@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?removeMember@Value@Json@@QAE?AV12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??AValue@Json@@QBEABV01@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??AValue@Json@@QBEABV01@PBD@Z$0
__ehfuncinfo$??AValue@Json@@QBEABV01@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??AValue@Json@@QBEABV01@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??AValue@Json@@QBEABV01@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??AValue@Json@@QBEABV01@I@Z$0
__ehfuncinfo$??AValue@Json@@QBEABV01@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??AValue@Json@@QBEABV01@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??AValue@Json@@QAEAAV01@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$2
__ehfuncinfo$??AValue@Json@@QAEAAV01@I@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??AValue@Json@@QAEAAV01@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?resize@Value@Json@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resize@Value@Json@@QAEXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?resize@Value@Json@@QAEXI@Z$1
__ehfuncinfo$?resize@Value@Json@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?resize@Value@Json@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4Value@Json@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4Value@Json@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4Value@Json@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4Value@Json@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Value@Json@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Value@Json@@QAE@ABV01@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Value@Json@@QAE@ABV01@@Z$1
__ehfuncinfo$??0Value@Json@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Value@Json@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Value@Json@@QAE@W4ValueType@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Value@Json@@QAE@W4ValueType@1@@Z$0
__ehfuncinfo$??0Value@Json@@QAE@W4ValueType@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Value@Json@@QAE@W4ValueType@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z$0
__ehfuncinfo$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?null$initializer$@Value@Json@@2P6AXXZA DD FLAT:??__E?null@Value@Json@@2V12@B@@YAXXZ ; Json::Value::null$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_dummyValueAllocatorInitializer$initializer$ DD FLAT:??__EdummyValueAllocatorInitializer@Json@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VPathArgument@Json@@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@VPathArgument@Json@@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z PROC ; std::allocator<Json::PathArgument>::destroy<Json::PathArgument>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_GPathArgument@Json@@QAEPAXI@Z

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@VPathArgument@Json@@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ENDP ; std::allocator<Json::PathArgument>::destroy<Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv76 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv76[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument>,Json::PathArgument>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 438  : 	_DEBUG_RANGE(_First, _Last);
; 439  : 	_DEBUG_POINTER(_Dest);
; 440  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 441  : 
; 442  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_mov:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@VPathArgument@Json@@V12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>
	jmp	SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
	jmp	SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov

; 447  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@VPathArgument@Json@@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::destroy<Json::PathArgument>
	jmp	SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 448  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 449  : 	_CATCH_END

	mov	eax, $LN13@Uninit_mov
	ret	0
$LN10@Uninit_mov:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
$LN13@Uninit_mov:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 450  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 451  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument>,Json::PathArgument>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z PROC ; std::_Val_type<Json::PathArgument *>, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	ebp
	ret	0
??$_Val_type@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z ENDP ; std::_Val_type<Json::PathArgument *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VPathArgument@Json@@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@VPathArgument@Json@@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::PathArgument> >::destroy<Json::PathArgument>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@VPathArgument@Json@@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy<Json::PathArgument>

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@VPathArgument@Json@@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::PathArgument> >::destroy<Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PBVPathArgument@Json@@PBV12@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PBVPathArgument@Json@@PBV12@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<Json::PathArgument const *,Json::PathArgument const *,Json::PathArgument const *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	push	ecx

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 475  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PBVPathArgument@Json@@PBV12@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Json::PathArgument const *,Json::PathArgument const *,Json::PathArgument const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z PROC ; std::_Val_type<Json::PathArgument const * *>, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	ebp
	ret	0
??$_Val_type@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z ENDP ; std::_Val_type<Json::PathArgument const * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 438  : 	_DEBUG_RANGE(_First, _Last);
; 439  : 	_DEBUG_POINTER(_Dest);
; 440  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 441  : 
; 442  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_mov:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	jmp	SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
	jmp	SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov

; 447  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	jmp	SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 448  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 449  : 	_CATCH_END

	mov	eax, $LN13@Uninit_mov
	ret	0
$LN10@Uninit_mov:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
$LN13@Uninit_mov:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 450  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 451  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z PROC ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	ebp
	ret	0
??$_Val_type@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ENDP ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR __Val2$[ebp]
	push	eax
	call	??$forward@_N@std@@YA$$QA_NAA_N@Z	; std::forward<bool>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], dl

; 145  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,bool,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR __Val2$[ebp]
	push	eax
	call	??$forward@_N@std@@YA$$QA_NAA_N@Z	; std::forward<bool>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], dl

; 145  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Node$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode_if_nil<std::pair<Json::Value::CZString const ,Json::Value> &>, COMDAT
; _this$ = ecx

; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);

	mov	eax, DWORD PTR __Node$[ebp]

; 1639 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Buynode_if_nil@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode_if_nil<std::pair<Json::Value::CZString const ,Json::Value> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z
_TEXT	SEGMENT
tv78 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z PROC ; std::operator==<Json::Value::CZString const ,Json::Value>, COMDAT

; 216  : 	{	// test for pair equality

	push	ebp
	mov	ebp, esp
	push	ecx

; 217  : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??8CZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@operator
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR __Left$[ebp]
	add	ecx, 8
	call	??8Value@Json@@QBE_NABV01@@Z		; Json::Value::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 218  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ENDP ; std::operator==<Json::Value::CZString const ,Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z
_TEXT	SEGMENT
tv85 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z PROC ; std::operator<<Json::Value::CZString const ,Json::Value>, COMDAT

; 232  : 	{	// test if _Left < _Right for pairs

	push	ebp
	mov	ebp, esp
	push	ecx

; 233  : 	return (_Left.first < _Right.first ||
; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@operator
	mov	edx, DWORD PTR __Left$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR __Left$[ebp]
	add	ecx, 8
	call	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv85[ebp], 0
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv85[ebp], 1
$LN5@operator:
	mov	al, BYTE PTR tv85[ebp]

; 235  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ENDP ; std::operator<<Json::Value::CZString const ,Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAVPathArgument@Json@@PAV12@@std@@YAAAPAVPathArgument@Json@@AAPAV12@PAV12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAVPathArgument@Json@@PAV12@@std@@YAAAPAVPathArgument@Json@@AAPAV12@PAV12@@Z PROC ; std::_Rechecked<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 289  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 290  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 291  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAVPathArgument@Json@@PAV12@@std@@YAAAPAVPathArgument@Json@@AAPAV12@PAV12@@Z ENDP ; std::_Rechecked<Json::PathArgument *,Json::PathArgument *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z PROC ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::_Wrap_alloc<std::allocator<Json::PathArgument> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@VPathArgument@Json@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument,Json::PathArgument>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z ; std::_Val_type<Json::PathArgument *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@V12@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument>,Json::PathArgument>
	add	esp, 24					; 00000018H

; 485  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ENDP ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z PROC ; std::_Unchecked<Json::PathArgument *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z ENDP ; std::_Unchecked<Json::PathArgument *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VPathArgument@Json@@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@VPathArgument@Json@@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::destroy<Json::PathArgument>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@VPathArgument@Json@@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::destroy<Json::PathArgument>
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@VPathArgument@Json@@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::destroy<Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPBVPathArgument@Json@@PAPBV12@@std@@YAAAPAPBVPathArgument@Json@@AAPAPBV12@PAPBV12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPBVPathArgument@Json@@PAPBV12@@std@@YAAAPAPBVPathArgument@Json@@AAPAPBV12@PAPBV12@@Z PROC ; std::_Rechecked<Json::PathArgument const * *,Json::PathArgument const * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 289  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 290  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 291  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAPBVPathArgument@Json@@PAPBV12@@std@@YAAAPAPBVPathArgument@Json@@AAPAPBV12@PAPBV12@@Z ENDP ; std::_Rechecked<Json::PathArgument const * *,Json::PathArgument const * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z PROC ; std::_Uninit_move<Json::PathArgument const * *,Json::PathArgument const * *,std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PBVPathArgument@Json@@PBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument const *,Json::PathArgument const *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z ; std::_Val_type<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PBVPathArgument@Json@@PBV12@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Json::PathArgument const *,Json::PathArgument const *,Json::PathArgument const *>
	add	esp, 24					; 00000018H

; 485  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z ENDP ; std::_Uninit_move<Json::PathArgument const * *,Json::PathArgument const * *,std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z PROC ; std::_Unchecked<Json::PathArgument const * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z ENDP ; std::_Unchecked<Json::PathArgument const * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@PAV10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@PAV10@@Z PROC ; std::_Rechecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 289  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 290  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 291  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@PAV10@@Z ENDP ; std::_Rechecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 24					; 00000018H

; 485  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z PROC ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ENDP ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Copy_or_move@U?$integral_constant@_N$0A@@std@@U?$integral_constant@_N$00@2@U12@H@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@U?$integral_constant@_N$0A@@1@U?$integral_constant@_N$00@1@1H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Copy_or_move@U?$integral_constant@_N$0A@@std@@U?$integral_constant@_N$00@2@U12@H@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@U?$integral_constant@_N$0A@@1@U?$integral_constant@_N$00@1@1H@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_or_move<std::integral_constant<bool,0>,std::integral_constant<bool,1>,std::integral_constant<bool,0>,int>, COMDAT
; _this$ = ecx

; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));

	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Buynode<std::pair<Json::Value::CZString const ,Json::Value> &>

; 1952 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Copy_or_move@U?$integral_constant@_N$0A@@std@@U?$integral_constant@_N$00@2@U12@H@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@U?$integral_constant@_N$0A@@1@U?$integral_constant@_N$00@1@1H@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_or_move<std::integral_constant<bool,0>,std::integral_constant<bool,1>,std::integral_constant<bool,0>,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv76 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv76[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_G?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAEPAXI@Z

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv76 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z PROC ; std::allocator<Json::PathArgument>::construct<Json::PathArgument,Json::PathArgument &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAVPathArgument@Json@@@std@@YAAAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0PathArgument@Json@@QAE@ABV01@@Z
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv76[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z ENDP ; std::allocator<Json::PathArgument>::construct<Json::PathArgument,Json::PathArgument &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv76 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z PROC ; std::allocator<Json::PathArgument>::construct<Json::PathArgument,Json::PathArgument>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@VPathArgument@Json@@@std@@YA$$QAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0PathArgument@Json@@QAE@ABV01@@Z
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv76[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z ENDP ; std::allocator<Json::PathArgument>::construct<Json::PathArgument,Json::PathArgument>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z PROC ; std::allocator<Json::PathArgument const *>::construct<Json::PathArgument const *,Json::PathArgument const *>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PBVPathArgument@Json@@@std@@YA$$QAPBVPathArgument@Json@@AAPBV12@@Z ; std::forward<Json::PathArgument const *>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z ENDP ; std::allocator<Json::PathArgument const *>::construct<Json::PathArgument const *,Json::PathArgument const *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T2 = -152						; size = 4
$T3 = -148						; size = 4
$T4 = -144						; size = 4
$T5 = -140						; size = 4
tv264 = -136						; size = 4
tv252 = -132						; size = 4
tv259 = -128						; size = 4
tv262 = -124						; size = 4
tv275 = -120						; size = 4
tv256 = -116						; size = 4
tv274 = -112						; size = 4
tv265 = -108						; size = 4
tv272 = -104						; size = 4
tv263 = -100						; size = 4
tv271 = -96						; size = 4
tv260 = -92						; size = 4
tv269 = -88						; size = 4
tv258 = -84						; size = 4
tv270 = -80						; size = 4
tv255 = -76						; size = 4
tv268 = -72						; size = 4
tv253 = -68						; size = 4
tv267 = -64						; size = 4
tv254 = -60						; size = 4
tv153 = -56						; size = 4
tv128 = -52						; size = 4
$T6 = -47						; size = 1
$T7 = -46						; size = 1
$T8 = -45						; size = 1
__Where$9 = -44						; size = 4
__Wherenode$10 = -40					; size = 4
__Trynode$11 = -36					; size = 4
$T12 = -32						; size = 1
tv261 = -31						; size = 1
tv273 = -30						; size = 1
$T13 = -29						; size = 1
tv266 = -28						; size = 1
tv257 = -27						; size = 1
$T14 = -26						; size = 1
$T15 = -25						; size = 1
_this$ = -24						; size = 4
__Addleft$16 = -17					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_nohint<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>, COMDAT
; _this$ = ecx

; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1781 : 		_Nodeptr _Trynode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	DWORD PTR tv252[ebp], eax
	mov	eax, DWORD PTR tv252[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Trynode$11[ebp], ecx

; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$10[ebp], eax

; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$16[ebp], 1
$LN12@Insert_noh:

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

	mov	ecx, DWORD PTR __Trynode$11[ebp]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	mov	DWORD PTR tv253[ebp], eax
	mov	edx, DWORD PTR tv253[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	$LN11@Insert_noh

; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$11[ebp]
	mov	DWORD PTR __Wherenode$10[ebp], ecx

; 1788 : 			if (_Leftish)

	movzx	edx, BYTE PTR __Leftish$[ebp]
	test	edx, edx
	je	SHORT $LN10@Insert_noh

; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv254[ebp], eax
	mov	ecx, DWORD PTR __Trynode$11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv255[ebp], eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv256[ebp], eax
	mov	eax, DWORD PTR tv254[ebp]
	push	eax
	mov	ecx, DWORD PTR tv255[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv256[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv257[ebp], al
	movzx	edx, BYTE PTR tv257[ebp]
	test	edx, edx
	jne	SHORT $LN16@Insert_noh
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN17@Insert_noh
$LN16@Insert_noh:
	mov	DWORD PTR tv128[ebp], 0
$LN17@Insert_noh:
	mov	al, BYTE PTR tv128[ebp]
	mov	BYTE PTR __Addleft$16[ebp], al

; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else

	jmp	SHORT $LN9@Insert_noh
$LN10@Insert_noh:

; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

	mov	ecx, DWORD PTR __Trynode$11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv258[ebp], eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv259[ebp], eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv260[ebp], eax
	mov	ecx, DWORD PTR tv258[ebp]
	push	ecx
	mov	edx, DWORD PTR tv259[ebp]
	push	edx
	mov	ecx, DWORD PTR tv260[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv261[ebp], al
	mov	al, BYTE PTR tv261[ebp]
	mov	BYTE PTR __Addleft$16[ebp], al
$LN9@Insert_noh:

; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);

	movzx	ecx, BYTE PTR __Addleft$16[ebp]
	test	ecx, ecx
	je	SHORT $LN18@Insert_noh
	mov	edx, DWORD PTR __Trynode$11[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	DWORD PTR tv262[ebp], eax
	mov	eax, DWORD PTR tv262[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv153[ebp], ecx
	jmp	SHORT $LN19@Insert_noh
$LN18@Insert_noh:
	mov	edx, DWORD PTR __Trynode$11[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	DWORD PTR tv263[ebp], eax
	mov	eax, DWORD PTR tv263[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv153[ebp], ecx
$LN19@Insert_noh:
	mov	edx, DWORD PTR tv153[ebp]
	mov	DWORD PTR __Trynode$11[ebp], edx

; 1798 : 			}

	jmp	$LN12@Insert_noh
$LN11@Insert_noh:

; 1799 : 
; 1800 : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@Insert_noh

; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	mov	BYTE PTR $T13[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv264[ebp], eax
	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv264[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$10[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Addleft$16[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	DWORD PTR tv265[ebp], eax
	lea	ecx, DWORD PTR $T13[ebp]
	push	ecx
	mov	edx, DWORD PTR tv265[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool,void>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN15@Insert_noh

; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else

	jmp	$LN7@Insert_noh
$LN8@Insert_noh:

; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$10[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Where$9[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >

; 1806 : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$16[ebp]
	test	edx, edx
	jne	SHORT $LN6@Insert_noh

; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())

	jmp	SHORT $LN5@Insert_noh
$LN6@Insert_noh:
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$9[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	mov	BYTE PTR tv266[ebp], al
	movzx	ecx, BYTE PTR tv266[ebp]
	test	ecx, ecx
	je	SHORT $LN4@Insert_noh

; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	mov	BYTE PTR $T12[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv267[ebp], eax
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv267[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$10[ebp]
	push	edx
	push	1
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	DWORD PTR tv268[ebp], eax
	lea	ecx, DWORD PTR $T12[ebp]
	push	ecx
	mov	edx, DWORD PTR tv268[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool,void>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN15@Insert_noh

; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else

	jmp	SHORT $LN5@Insert_noh
$LN4@Insert_noh:

; 1812 : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$9[ebp]
	call	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--
$LN5@Insert_noh:

; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv269[ebp], eax
	lea	ecx, DWORD PTR __Where$9[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv270[ebp], eax
	mov	ecx, DWORD PTR tv270[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv271[ebp], eax
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv272[ebp], eax
	mov	eax, DWORD PTR tv269[ebp]
	push	eax
	mov	ecx, DWORD PTR tv271[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv272[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv273[ebp], al
	movzx	edx, BYTE PTR tv273[ebp]
	test	edx, edx
	je	SHORT $LN2@Insert_noh

; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	mov	BYTE PTR $T14[ebp], 1
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv274[ebp], eax
	mov	ecx, DWORD PTR __Newnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv274[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$10[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Addleft$16[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	DWORD PTR tv275[ebp], eax
	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	mov	ecx, DWORD PTR tv275[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool,void>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN15@Insert_noh

; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else

	jmp	SHORT $LN7@Insert_noh
$LN2@Insert_noh:

; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);

	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Destroy_if_not_nil

; 1822 : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T15[ebp], 0
	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$9[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,bool,void>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN15@Insert_noh
$LN7@Insert_noh:
	jmp	SHORT $LN20@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$0:

; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);

	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Destroy_if_not_nil

; 1827 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1828 : 		_CATCH_END

	mov	eax, $LN23@Insert_noh
	ret	0
$LN20@Insert_noh:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@Insert_noh
$LN23@Insert_noh:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN15@Insert_noh:

; 1829 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_nohint<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z
_TEXT	SEGMENT
__Newnode$ = -12					; size = 4
_this$ = -8						; size = 4
__Pnode$1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>, COMDAT
; _this$ = ecx

; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	ja	SHORT $LN17@Insert_at

; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);

	mov	edx, DWORD PTR __Node$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Destroy_if_not_nil

; 1839 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Insert_at:

; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Node$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Buynode_if_nil@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode_if_nil<std::pair<Json::Value::CZString const ,Json::Value> &>
	mov	DWORD PTR __Newnode$[ebp], eax

; 1843 : 
; 1844 : 		++this->_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1845 : 		_Newnode->_Parent = _Wherenode;

	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN16@Insert_at

; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1850 : 			_Lmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 1851 : 			_Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN15@Insert_at
$LN16@Insert_at:

; 1852 : 			}
; 1853 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN14@Insert_at

; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1856 : 			if (_Wherenode == _Lmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN13@Insert_at

; 1857 : 				_Lmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN13@Insert_at:

; 1858 : 			}
; 1859 : 		else

	jmp	SHORT $LN15@Insert_at
$LN14@Insert_at:

; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1862 : 			if (_Wherenode == _Rmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN15@Insert_at

; 1863 : 				_Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN15@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;

	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$1[ebp], edx
$LN10@Insert_at:

; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR __Pnode$1[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	$LN9@Insert_at

; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	eax, DWORD PTR __Pnode$1[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN8@Insert_at

; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN7@Insert_at

; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1876 : 					this->_Color(_Wherenode) = this->_Black;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;

	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$1[ebp], ecx

; 1880 : 					}
; 1881 : 				else

	jmp	$LN6@Insert_at
$LN7@Insert_at:

; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN5@Insert_at

; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$1[ebp], eax

; 1886 : 						_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
$LN5@Insert_at:

; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
$LN6@Insert_at:

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

	jmp	$LN4@Insert_at
$LN8@Insert_at:

; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Insert_at

; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1902 : 					this->_Color(_Wherenode) = this->_Black;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$1[ebp], eax

; 1906 : 					}
; 1907 : 				else

	jmp	$LN4@Insert_at
$LN3@Insert_at:

; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@Insert_at

; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$1[ebp], eax

; 1912 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
$LN1@Insert_at:

; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
$LN4@Insert_at:

; 1919 : 					}
; 1920 : 				}

	jmp	$LN10@Insert_at
$LN9@Insert_at:

; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1923 : 		return (iterator(_Newnode, this));

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert_at:

; 1924 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Equal@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@00@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
??$_Equal@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@00@Z PROC ; std::_Equal<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0> >, COMDAT

; 2735 : 	{	// compare [_First1, _Last1) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 2736 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	jmp	SHORT $LN4@Equal
$LN3@Equal:
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator++
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator++
$LN4@Equal:
	lea	eax, DWORD PTR __Last1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Equal

; 2737 : 		if (!(*_First1 == *_First2))

	lea	ecx, DWORD PTR __First2$[ebp]
	call	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator*
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator*
	push	eax
	call	??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator==<Json::Value::CZString const ,Json::Value>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@Equal

; 2738 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Equal
$LN1@Equal:

; 2739 : 	return (true);

	jmp	SHORT $LN3@Equal
$LN2@Equal:
	mov	al, 1
$LN5@Equal:

; 2740 : 	}

	pop	ebp
	ret	0
??$_Equal@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@00@Z ENDP ; std::_Equal<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Lexicographical_compare@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@000@Z
_TEXT	SEGMENT
tv136 = -4						; size = 4
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
??$_Lexicographical_compare@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@000@Z PROC ; std::_Lexicographical_compare<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0> >, COMDAT

; 2891 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)

	push	ebp
	mov	ebp, esp
	push	ecx

; 2892 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)

	jmp	SHORT $LN6@Lexicograp
$LN5@Lexicograp:
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator++
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator++
$LN6@Lexicograp:
	lea	eax, DWORD PTR __Last1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Lexicograp
	lea	edx, DWORD PTR __Last2$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Lexicograp

; 2893 : 		if (_DEBUG_LT(*_First1, *_First2))

	lea	ecx, DWORD PTR __First2$[ebp]
	call	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator*
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator*
	push	eax
	call	??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator<<Json::Value::CZString const ,Json::Value>
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Lexicograp

; 2894 : 			return (true);

	mov	al, 1
	jmp	SHORT $LN7@Lexicograp
	jmp	SHORT $LN2@Lexicograp
$LN3@Lexicograp:

; 2895 : 		else if (*_First2 < *_First1)

	lea	ecx, DWORD PTR __First1$[ebp]
	call	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator*
	push	eax
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator*
	push	eax
	call	??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator<<Json::Value::CZString const ,Json::Value>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Lexicograp

; 2896 : 			return (false);

	xor	al, al
	jmp	SHORT $LN7@Lexicograp
$LN2@Lexicograp:

; 2897 : 	return (_First1 == _Last1 && _First2 != _Last2);

	jmp	$LN5@Lexicograp
$LN4@Lexicograp:
	lea	eax, DWORD PTR __Last1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@Lexicograp
	lea	edx, DWORD PTR __Last2$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Lexicograp
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN10@Lexicograp
$LN9@Lexicograp:
	mov	DWORD PTR tv136[ebp], 0
$LN10@Lexicograp:
	mov	al, BYTE PTR tv136[ebp]
$LN7@Lexicograp:

; 2898 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lexicographical_compare@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@000@Z ENDP ; std::_Lexicographical_compare<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iter$ = 12						; size = 4
??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >, COMDAT

; 348  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp

; 349  : 	return (_Iter._Unchecked());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	?_Unchecked@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Unchecked
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 350  : 	}

	pop	ebp
	ret	0
??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 80   : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 81   : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 82   : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 83   : 	}

	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 444  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 447  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_move<Json::PathArgument *,Json::PathArgument *,std::_Wrap_alloc<std::allocator<Json::PathArgument> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z ; std::_Unchecked<Json::PathArgument *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z ; std::_Unchecked<Json::PathArgument *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@PAV12@@Z ; std::_Unchecked<Json::PathArgument *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAVPathArgument@Json@@PAV12@@std@@YAAAPAVPathArgument@Json@@AAPAV12@PAV12@@Z ; std::_Rechecked<Json::PathArgument *,Json::PathArgument *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 496  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<Json::PathArgument *,Json::PathArgument *,std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument> > >, COMDAT

; 80   : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 81   : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 82   : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@VPathArgument@Json@@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::destroy<Json::PathArgument>
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 83   : 	}

	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@VPathArgument@Json@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@VPathArgument@Json@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPathArgument@Json@@0@Z PROC ; std::_Ptr_cat<Json::PathArgument,Json::PathArgument>, COMDAT

; 444  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 447  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@VPathArgument@Json@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPathArgument@Json@@0@Z ENDP ; std::_Ptr_cat<Json::PathArgument,Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_move<Json::PathArgument const * *,Json::PathArgument const * *,std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z ; std::_Unchecked<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z ; std::_Unchecked<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@@Z ; std::_Unchecked<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z ; std::_Uninit_move<Json::PathArgument const * *,Json::PathArgument const * *,std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAPBVPathArgument@Json@@PAPBV12@@std@@YAAAPAPBVPathArgument@Json@@AAPAPBV12@PAPBV12@@Z ; std::_Rechecked<Json::PathArgument const * *,Json::PathArgument const * *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 496  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<Json::PathArgument const * *,Json::PathArgument const * *,std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >, COMDAT

; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 90   : 	}

	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PBVPathArgument@Json@@PBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PBVPathArgument@Json@@PBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z PROC ; std::_Ptr_cat<Json::PathArgument const *,Json::PathArgument const *>, COMDAT

; 444  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 447  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PBVPathArgument@Json@@PBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z ENDP ; std::_Ptr_cat<Json::PathArgument const *,Json::PathArgument const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 496  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
tv153 = -56						; size = 4
tv154 = -52						; size = 4
tv152 = -48						; size = 4
tv150 = -44						; size = 4
tv151 = -40						; size = 4
tv149 = -36						; size = 4
__Newroot$ = -32					; size = 4
_this$ = -28						; size = 4
__Pnode$2 = -24						; size = 4
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
__Movefl$ = 16						; size = 1
??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy_nodes

; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);

	xor	ecx, ecx
	mov	BYTE PTR $T4[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T3[ebp], dl
	push	0
	movzx	eax, BYTE PTR $T4[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T3[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Movefl$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Copy_or_move@U?$integral_constant@_N$0A@@std@@U?$integral_constant@_N$00@2@U12@H@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@U?$integral_constant@_N$0A@@1@U?$integral_constant@_N$00@1@1H@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_or_move<std::integral_constant<bool,0>,std::integral_constant<bool,1>,std::integral_constant<bool,0>,int>
	mov	DWORD PTR __Pnode$2[ebp], eax

; 1984 : 			_Pnode->_Parent = _Wherenode;

	mov	ecx, DWORD PTR __Pnode$2[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);

	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$2[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx+12], dl

; 1986 : 			if (this->_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy_nodes

; 1987 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$2[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy_nodes:

; 1988 : 
; 1989 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);

	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	DWORD PTR tv149[ebp], eax
	movzx	ecx, BYTE PTR __Movefl$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pnode$2[ebp]
	push	edx
	mov	eax, DWORD PTR tv149[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
	mov	DWORD PTR tv150[ebp], eax
	mov	edx, DWORD PTR __Pnode$2[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	DWORD PTR tv151[ebp], eax
	mov	eax, DWORD PTR tv151[ebp]
	mov	ecx, DWORD PTR tv150[ebp]
	mov	DWORD PTR [eax], ecx

; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	DWORD PTR tv152[ebp], eax
	movzx	eax, BYTE PTR __Movefl$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$2[ebp]
	push	ecx
	mov	edx, DWORD PTR tv152[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
	mov	DWORD PTR tv153[ebp], eax
	mov	ecx, DWORD PTR __Pnode$2[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	DWORD PTR tv154[ebp], eax
	mov	edx, DWORD PTR tv154[ebp]
	mov	eax, DWORD PTR tv153[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN6@Copy_nodes
__catch$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z$0:

; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	ecx, DWORD PTR __Newroot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase

; 1996 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1997 : 			_CATCH_END

	mov	eax, $LN9@Copy_nodes
	ret	0
$LN6@Copy_nodes:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN3@Copy_nodes
$LN9@Copy_nodes:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy_nodes:

; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy_nodes:

; 2001 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 724  : 		}

	pop	ebp
	ret	0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,unsigned int>, COMDAT

; 732  : 	{	// add to _Off distance between bidirectional iterators (redundant)

	push	ebp
	mov	ebp, esp

; 733  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Distance2
$LN2@Distance2:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
$LN3@Distance2:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Distance2

; 734  : 		++_Off;

	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN2@Distance2
$LN4@Distance2:

; 735  : 	}

	pop	ebp
	ret	0
??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

	pop	ebp
	ret	0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VPathArgument@Json@@ABV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@ABV34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@VPathArgument@Json@@ABV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@ABV34@@Z PROC ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABVPathArgument@Json@@@std@@YAABVPathArgument@Json@@ABV12@@Z ; std::forward<Json::PathArgument const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ; std::allocator<Json::PathArgument>::construct

; 724  : 		}

	pop	ebp
	ret	0
??$construct@VPathArgument@Json@@ABV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@ABV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABVPathArgument@Json@@@std@@YAABVPathArgument@Json@@ABV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABVPathArgument@Json@@@std@@YAABVPathArgument@Json@@ABV12@@Z PROC ; std::forward<Json::PathArgument const &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@ABVPathArgument@Json@@@std@@YAABVPathArgument@Json@@ABV12@@Z ENDP ; std::forward<Json::PathArgument const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VPathArgument@Json@@AAV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@AAV34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@VPathArgument@Json@@AAV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@AAV34@@Z PROC ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAVPathArgument@Json@@@std@@YAAAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@VPathArgument@Json@@AAV12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z ; std::allocator<Json::PathArgument>::construct<Json::PathArgument,Json::PathArgument &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@VPathArgument@Json@@AAV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@AAV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAVPathArgument@Json@@@std@@YAAAVPathArgument@Json@@AAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAVPathArgument@Json@@@std@@YAAAVPathArgument@Json@@AAV12@@Z PROC ; std::forward<Json::PathArgument &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAVPathArgument@Json@@@std@@YAAAVPathArgument@Json@@AAV12@@Z ENDP ; std::forward<Json::PathArgument &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VPathArgument@Json@@V12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@$$QAV34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@VPathArgument@Json@@V12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@$$QAV34@@Z PROC ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@VPathArgument@Json@@@std@@YA$$QAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@VPathArgument@Json@@V12@@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z ; std::allocator<Json::PathArgument>::construct<Json::PathArgument,Json::PathArgument>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@VPathArgument@Json@@V12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@$$QAV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PBVPathArgument@Json@@PBV12@@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@PBVPathArgument@Json@@@1@PAPBVPathArgument@Json@@$$QAPBV34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PBVPathArgument@Json@@PBV12@@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@PBVPathArgument@Json@@@1@PAPBVPathArgument@Json@@$$QAPBV34@@Z PROC ; std::allocator_traits<std::allocator<Json::PathArgument const *> >::construct<Json::PathArgument const *,Json::PathArgument const *>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@PBVPathArgument@Json@@@std@@YA$$QAPBVPathArgument@Json@@AAPBV12@@Z ; std::forward<Json::PathArgument const *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PBVPathArgument@Json@@PBV12@@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z ; std::allocator<Json::PathArgument const *>::construct<Json::PathArgument const *,Json::PathArgument const *>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PBVPathArgument@Json@@PBV12@@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@PBVPathArgument@Json@@@1@PAPBVPathArgument@Json@@$$QAPBV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::PathArgument const *> >::construct<Json::PathArgument const *,Json::PathArgument const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T2 = -444						; size = 8
$T3 = -436						; size = 4
$T4 = -432						; size = 4
$T5 = -428						; size = 4
$T6 = -424						; size = 4
$T7 = -420						; size = 4
$T8 = -416						; size = 4
tv765 = -412						; size = 4
tv717 = -408						; size = 4
tv756 = -404						; size = 4
tv726 = -400						; size = 4
tv745 = -396						; size = 4
tv737 = -392						; size = 4
tv760 = -388						; size = 4
tv815 = -384						; size = 4
tv752 = -380						; size = 4
tv814 = -376						; size = 4
tv741 = -372						; size = 4
tv813 = -368						; size = 4
tv732 = -364						; size = 4
tv812 = -360						; size = 4
tv722 = -356						; size = 4
tv811 = -352						; size = 4
tv711 = -348						; size = 4
tv810 = -344						; size = 4
tv762 = -340						; size = 4
tv809 = -336						; size = 4
tv758 = -332						; size = 4
tv807 = -328						; size = 4
tv753 = -324						; size = 4
tv806 = -320						; size = 4
tv747 = -316						; size = 4
tv805 = -312						; size = 4
tv743 = -308						; size = 4
tv804 = -304						; size = 4
tv739 = -300						; size = 4
tv802 = -296						; size = 4
tv734 = -292						; size = 4
tv800 = -288						; size = 4
tv729 = -284						; size = 4
tv799 = -280						; size = 4
tv725 = -276						; size = 4
tv797 = -272						; size = 4
tv720 = -268						; size = 4
tv798 = -264						; size = 4
tv714 = -260						; size = 4
tv796 = -256						; size = 4
tv766 = -252						; size = 4
tv795 = -248						; size = 4
tv764 = -244						; size = 4
tv794 = -240						; size = 4
tv761 = -236						; size = 4
tv793 = -232						; size = 4
tv759 = -228						; size = 4
tv792 = -224						; size = 4
tv757 = -220						; size = 4
tv791 = -216						; size = 4
tv754 = -212						; size = 4
tv790 = -208						; size = 4
tv751 = -204						; size = 4
tv788 = -200						; size = 4
tv749 = -196						; size = 4
tv787 = -192						; size = 4
tv709 = -188						; size = 4
tv784 = -184						; size = 4
tv744 = -180						; size = 4
tv786 = -176						; size = 4
tv742 = -172						; size = 4
tv785 = -168						; size = 4
tv740 = -164						; size = 4
tv782 = -160						; size = 4
tv738 = -156						; size = 4
tv781 = -152						; size = 4
tv735 = -148						; size = 4
tv780 = -144						; size = 4
tv733 = -140						; size = 4
tv779 = -136						; size = 4
tv731 = -132						; size = 4
tv778 = -128						; size = 4
tv728 = -124						; size = 4
tv777 = -120						; size = 4
tv727 = -116						; size = 4
tv775 = -112						; size = 4
tv724 = -108						; size = 4
tv774 = -104						; size = 4
tv721 = -100						; size = 4
tv772 = -96						; size = 4
tv719 = -92						; size = 4
tv773 = -88						; size = 4
tv716 = -84						; size = 4
tv770 = -80						; size = 4
tv713 = -76						; size = 4
tv769 = -72						; size = 4
tv712 = -68						; size = 4
tv767 = -64						; size = 4
tv746 = -60						; size = 4
$T9 = -55						; size = 1
$T10 = -54						; size = 1
$T11 = -53						; size = 1
$T12 = -52						; size = 1
$T13 = -51						; size = 1
$T14 = -50						; size = 1
$T15 = -49						; size = 1
$T16 = -48						; size = 1
$T17 = -47						; size = 1
$T18 = -46						; size = 1
$T19 = -45						; size = 1
$T20 = -44						; size = 1
tv715 = -43						; size = 1
tv768 = -42						; size = 1
tv736 = -41						; size = 1
tv748 = -40						; size = 1
tv730 = -39						; size = 1
tv755 = -38						; size = 1
tv803 = -37						; size = 1
tv771 = -36						; size = 1
tv710 = -35						; size = 1
tv763 = -34						; size = 1
tv789 = -33						; size = 1
tv750 = -32						; size = 1
tv783 = -31						; size = 1
tv718 = -30						; size = 1
tv776 = -29						; size = 1
tv723 = -28						; size = 1
tv808 = -27						; size = 1
tv801 = -26						; size = 1
__Leftish$ = -25					; size = 1
__Next$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_hint<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>, COMDAT
; _this$ = ecx

; 1661 : 		iterator _Insert_hint(const_iterator _Where,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 428				; 000001acH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;

	lea	ecx, DWORD PTR __Next$[ebp]
	call	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >

; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence

	mov	BYTE PTR __Leftish$[ebp], 0

; 1666 : 
; 1667 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	test	eax, eax
	jne	SHORT $LN33@Insert_hin

; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv709[ebp], eax
	mov	ecx, DWORD PTR __Newnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv709[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin
	jmp	$LN32@Insert_hin
$LN33@Insert_hin:

; 1677 : 		else if (this->_Multi)

	xor	eax, eax
	je	$LN31@Insert_hin

; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())

	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	mov	BYTE PTR tv710[ebp], al
	movzx	edx, BYTE PTR tv710[ebp]
	test	edx, edx
	je	$LN30@Insert_hin

; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv711[ebp], eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv712[ebp], eax
	mov	ecx, DWORD PTR tv712[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv713[ebp], eax
	lea	edx, DWORD PTR $T20[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv714[ebp], eax
	mov	eax, DWORD PTR tv711[ebp]
	push	eax
	mov	ecx, DWORD PTR tv713[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv714[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv715[ebp], al
	movzx	edx, BYTE PTR tv715[ebp]
	test	edx, edx
	jne	SHORT $LN29@Insert_hin

; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv716[ebp], eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv717[ebp], eax
	mov	ecx, DWORD PTR __Newnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv716[ebp]
	push	edx
	mov	eax, DWORD PTR tv717[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin
$LN29@Insert_hin:

; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence

	mov	BYTE PTR __Leftish$[ebp], 1

; 1686 : 				}
; 1687 : 			else if (_Where == end())

	jmp	$LN28@Insert_hin
$LN30@Insert_hin:
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	mov	BYTE PTR tv718[ebp], al
	movzx	eax, BYTE PTR tv718[ebp]
	test	eax, eax
	je	$LN27@Insert_hin

; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	DWORD PTR tv719[ebp], eax
	mov	ecx, DWORD PTR tv719[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv720[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv721[ebp], eax
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv722[ebp], eax
	mov	edx, DWORD PTR tv720[ebp]
	push	edx
	mov	eax, DWORD PTR tv721[ebp]
	push	eax
	mov	ecx, DWORD PTR tv722[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv723[ebp], al
	movzx	ecx, BYTE PTR tv723[ebp]
	test	ecx, ecx
	jne	SHORT $LN26@Insert_hin

; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv724[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	DWORD PTR tv725[ebp], eax
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv724[ebp]
	push	ecx
	mov	edx, DWORD PTR tv725[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin
$LN26@Insert_hin:

; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),

	jmp	$LN28@Insert_hin
$LN27@Insert_hin:

; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv726[ebp], eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv727[ebp], eax
	mov	eax, DWORD PTR tv727[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv728[ebp], eax
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv729[ebp], eax
	mov	edx, DWORD PTR tv726[ebp]
	push	edx
	mov	eax, DWORD PTR tv728[ebp]
	push	eax
	mov	ecx, DWORD PTR tv729[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv730[ebp], al
	movzx	ecx, BYTE PTR tv730[ebp]
	test	ecx, ecx
	jne	$LN24@Insert_hin
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--
	mov	DWORD PTR tv731[ebp], eax
	mov	ecx, DWORD PTR tv731[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv732[ebp], eax
	mov	eax, DWORD PTR tv732[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv733[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv734[ebp], eax
	lea	edx, DWORD PTR $T18[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv735[ebp], eax
	mov	eax, DWORD PTR tv733[ebp]
	push	eax
	mov	ecx, DWORD PTR tv734[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv735[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv736[ebp], al
	movzx	edx, BYTE PTR tv736[ebp]
	test	edx, edx
	jne	$LN24@Insert_hin

; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv737[ebp], eax
	mov	eax, DWORD PTR tv737[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	DWORD PTR tv738[ebp], eax
	mov	ecx, DWORD PTR tv738[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	mov	DWORD PTR tv739[ebp], eax
	mov	eax, DWORD PTR tv739[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN23@Insert_hin

; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv740[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv741[ebp], eax
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv740[ebp]
	push	ecx
	mov	edx, DWORD PTR tv741[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin

; 1703 : 				else

	jmp	SHORT $LN22@Insert_hin
$LN23@Insert_hin:

; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv742[ebp], eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv743[ebp], eax
	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv742[ebp]
	push	eax
	mov	ecx, DWORD PTR tv743[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin
$LN22@Insert_hin:

; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),

	jmp	$LN28@Insert_hin
$LN24@Insert_hin:

; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv744[ebp], eax
	mov	eax, DWORD PTR tv744[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv745[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv746[ebp], eax
	lea	edx, DWORD PTR $T10[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv747[ebp], eax
	mov	eax, DWORD PTR tv745[ebp]
	push	eax
	mov	ecx, DWORD PTR tv746[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv747[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv748[ebp], al
	movzx	edx, BYTE PTR tv748[ebp]
	test	edx, edx
	jne	$LN20@Insert_hin
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
	mov	DWORD PTR tv749[ebp], eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	mov	ecx, DWORD PTR tv749[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	mov	BYTE PTR tv750[ebp], al
	movzx	edx, BYTE PTR tv750[ebp]
	test	edx, edx
	jne	SHORT $LN19@Insert_hin
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv751[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv752[ebp], eax
	mov	ecx, DWORD PTR tv752[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv753[ebp], eax
	lea	edx, DWORD PTR $T16[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv754[ebp], eax
	mov	eax, DWORD PTR tv751[ebp]
	push	eax
	mov	ecx, DWORD PTR tv753[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv754[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv755[ebp], al
	movzx	edx, BYTE PTR tv755[ebp]
	test	edx, edx
	jne	$LN20@Insert_hin
$LN19@Insert_hin:

; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv756[ebp], eax
	mov	eax, DWORD PTR tv756[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	DWORD PTR tv757[ebp], eax
	mov	ecx, DWORD PTR tv757[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	mov	DWORD PTR tv758[ebp], eax
	mov	eax, DWORD PTR tv758[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN18@Insert_hin

; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv759[ebp], eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv760[ebp], eax
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv759[ebp]
	push	ecx
	mov	edx, DWORD PTR tv760[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin

; 1716 : 				else

	jmp	SHORT $LN17@Insert_hin
$LN18@Insert_hin:

; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv761[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv762[ebp], eax
	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv761[ebp]
	push	eax
	mov	ecx, DWORD PTR tv762[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin
$LN17@Insert_hin:

; 1719 : 				}
; 1720 : 			else

	jmp	SHORT $LN28@Insert_hin
$LN20@Insert_hin:

; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence

	mov	BYTE PTR __Leftish$[ebp], 1
$LN28@Insert_hin:

; 1722 : 			}
; 1723 : 		else

	jmp	$LN32@Insert_hin
$LN31@Insert_hin:

; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())

	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	mov	BYTE PTR tv763[ebp], al
	movzx	ecx, BYTE PTR tv763[ebp]
	test	ecx, ecx
	je	$LN14@Insert_hin

; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv764[ebp], eax
	mov	edx, DWORD PTR tv764[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv765[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv766[ebp], eax
	lea	ecx, DWORD PTR $T12[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv767[ebp], eax
	mov	edx, DWORD PTR tv765[ebp]
	push	edx
	mov	eax, DWORD PTR tv766[ebp]
	push	eax
	mov	ecx, DWORD PTR tv767[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv768[ebp], al
	movzx	ecx, BYTE PTR tv768[ebp]
	test	ecx, ecx
	je	SHORT $LN13@Insert_hin

; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv769[ebp], eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv770[ebp], eax
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv769[ebp]
	push	ecx
	mov	edx, DWORD PTR tv770[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin
$LN13@Insert_hin:

; 1731 : 				}
; 1732 : 			else if (_Where == end())

	jmp	$LN32@Insert_hin
$LN14@Insert_hin:
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	mov	BYTE PTR tv771[ebp], al
	movzx	edx, BYTE PTR tv771[ebp]
	test	edx, edx
	je	$LN11@Insert_hin

; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv772[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	DWORD PTR tv773[ebp], eax
	mov	ecx, DWORD PTR tv773[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv774[ebp], eax
	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv775[ebp], eax
	mov	ecx, DWORD PTR tv772[ebp]
	push	ecx
	mov	edx, DWORD PTR tv774[ebp]
	push	edx
	mov	ecx, DWORD PTR tv775[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv776[ebp], al
	movzx	eax, BYTE PTR tv776[ebp]
	test	eax, eax
	je	SHORT $LN10@Insert_hin

; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv777[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	DWORD PTR tv778[ebp], eax
	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv777[ebp]
	push	eax
	mov	ecx, DWORD PTR tv778[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin
$LN10@Insert_hin:

; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),

	jmp	$LN32@Insert_hin
$LN11@Insert_hin:

; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv779[ebp], eax
	mov	ecx, DWORD PTR tv779[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv780[ebp], eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv781[ebp], eax
	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv782[ebp], eax
	mov	ecx, DWORD PTR tv780[ebp]
	push	ecx
	mov	edx, DWORD PTR tv781[ebp]
	push	edx
	mov	ecx, DWORD PTR tv782[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv783[ebp], al
	movzx	eax, BYTE PTR tv783[ebp]
	test	eax, eax
	je	$LN8@Insert_hin
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv784[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--
	mov	DWORD PTR tv785[ebp], eax
	mov	ecx, DWORD PTR tv785[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv786[ebp], eax
	mov	eax, DWORD PTR tv786[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv787[ebp], eax
	lea	ecx, DWORD PTR $T17[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv788[ebp], eax
	mov	edx, DWORD PTR tv784[ebp]
	push	edx
	mov	eax, DWORD PTR tv787[ebp]
	push	eax
	mov	ecx, DWORD PTR tv788[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv789[ebp], al
	movzx	ecx, BYTE PTR tv789[ebp]
	test	ecx, ecx
	je	$LN8@Insert_hin

; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv790[ebp], eax
	mov	edx, DWORD PTR tv790[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	DWORD PTR tv791[ebp], eax
	mov	eax, DWORD PTR tv791[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	mov	DWORD PTR tv792[ebp], eax
	mov	edx, DWORD PTR tv792[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN7@Insert_hin

; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv793[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv794[ebp], eax
	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv793[ebp]
	push	eax
	mov	ecx, DWORD PTR tv794[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin

; 1748 : 				else

	jmp	SHORT $LN6@Insert_hin
$LN7@Insert_hin:

; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv795[ebp], eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv796[ebp], eax
	mov	ecx, DWORD PTR __Newnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv795[ebp]
	push	edx
	mov	eax, DWORD PTR tv796[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin
$LN6@Insert_hin:

; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),

	jmp	$LN32@Insert_hin
$LN8@Insert_hin:

; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv797[ebp], eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv798[ebp], eax
	mov	eax, DWORD PTR tv798[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv799[ebp], eax
	lea	ecx, DWORD PTR $T15[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv800[ebp], eax
	mov	edx, DWORD PTR tv797[ebp]
	push	edx
	mov	eax, DWORD PTR tv799[ebp]
	push	eax
	mov	ecx, DWORD PTR tv800[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv801[ebp], al
	movzx	ecx, BYTE PTR tv801[ebp]
	test	ecx, ecx
	je	$LN32@Insert_hin
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
	mov	DWORD PTR tv802[ebp], eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	mov	ecx, DWORD PTR tv802[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	mov	BYTE PTR tv803[ebp], al
	movzx	ecx, BYTE PTR tv803[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@Insert_hin
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv804[ebp], eax
	mov	edx, DWORD PTR tv804[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	mov	DWORD PTR tv805[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
	mov	DWORD PTR tv806[ebp], eax
	lea	ecx, DWORD PTR $T13[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	DWORD PTR tv807[ebp], eax
	mov	edx, DWORD PTR tv805[ebp]
	push	edx
	mov	eax, DWORD PTR tv806[ebp]
	push	eax
	mov	ecx, DWORD PTR tv807[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR tv808[ebp], al
	movzx	ecx, BYTE PTR tv808[ebp]
	test	ecx, ecx
	je	$LN32@Insert_hin
$LN3@Insert_hin:

; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv809[ebp], eax
	mov	edx, DWORD PTR tv809[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	DWORD PTR tv810[ebp], eax
	mov	eax, DWORD PTR tv810[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	mov	DWORD PTR tv811[ebp], eax
	mov	edx, DWORD PTR tv811[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN2@Insert_hin

; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv812[ebp], eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv813[ebp], eax
	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv812[ebp]
	push	eax
	mov	ecx, DWORD PTR tv813[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN36@Insert_hin

; 1761 : 				else

	jmp	SHORT $LN32@Insert_hin
$LN2@Insert_hin:

; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv814[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR tv815[ebp], eax
	mov	ecx, DWORD PTR __Newnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv814[ebp]
	push	edx
	mov	eax, DWORD PTR tv815[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@1@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_at<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN36@Insert_hin
$LN32@Insert_hin:
	jmp	SHORT $LN37@Insert_hin
__catch$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$0:

; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);

	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Destroy_if_not_nil

; 1768 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1769 : 		_CATCH_END

	mov	eax, $LN40@Insert_hin
	ret	0
$LN37@Insert_hin:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$1
$LN40@Insert_hin:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z$1:

; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);

	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	push	eax
	movzx	edx, BYTE PTR __Leftish$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_nohint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_nohint<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN36@Insert_hin:

; 1773 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-448]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_hint<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
_TEXT	SEGMENT
tv93 = -40						; size = 4
tv92 = -36						; size = 4
tv91 = -32						; size = 4
_this$ = -28						; size = 4
__Pnode$ = -24						; size = 4
$T2 = -17						; size = 1
__$EHRec$ = -16						; size = 16
_<_Val_0>$ = 8						; size = 4
??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z PROC ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Buynode<std::pair<Json::Value::CZString const ,Json::Value> &>, COMDAT
; _this$ = ecx

; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Buynode0
	mov	DWORD PTR __Pnode$[ebp], eax

; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 928  : 		this->_Isnil(_Pnode) = false;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 929  : 
; 930  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 931  : 		this->_Getal().construct(
; 932  : 			_STD addressof(this->_Myval(_Pnode)),
; 933  : 				_STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR _<_Val_0>$[ebp]
	push	edx
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	mov	DWORD PTR tv91[ebp], eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
	add	esp, 4
	mov	DWORD PTR tv92[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	DWORD PTR tv93[ebp], eax
	mov	edx, DWORD PTR tv91[ebp]
	push	edx
	mov	eax, DWORD PTR tv92[ebp]
	push	eax
	call	??$addressof@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAPAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::addressof<std::pair<Json::Value::CZString const ,Json::Value> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR tv93[ebp]
	call	??$construct@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@AAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::pair<Json::Value::CZString const ,Json::Value>,std::pair<Json::Value::CZString const ,Json::Value> &>
	jmp	SHORT $LN4@Buynode
__catch$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z$0:

; 934  : 		_CATCH_ALL
; 935  : 		_Freenode0(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Freenode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Freenode0

; 936  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 937  : 		_CATCH_END

	mov	eax, $LN7@Buynode
	ret	0
$LN4@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z$1
$LN7@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z$1:

; 938  : 
; 939  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$LN3@Buynode:

; 940  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ENDP ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Buynode<std::pair<Json::Value::CZString const ,Json::Value> &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z PROC ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ENDP ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABVValue@Json@@@std@@YAABVValue@Json@@ABV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABVValue@Json@@@std@@YAABVValue@Json@@ABV12@@Z PROC ; std::forward<Json::Value const &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@ABVValue@Json@@@std@@YAABVValue@Json@@ABV12@@Z ENDP ; std::forward<Json::Value const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAVCZString@Value@Json@@@std@@YAAAVCZString@Value@Json@@AAV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAVCZString@Value@Json@@@std@@YAAAVCZString@Value@Json@@AAV123@@Z PROC ; std::forward<Json::Value::CZString &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAVCZString@Value@Json@@@std@@YAAAVCZString@Value@Json@@AAV123@@Z ENDP ; std::forward<Json::Value::CZString &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$equal@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@00@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
??$equal@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@00@Z PROC ; std::equal<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >, COMDAT

; 2765 : 	{	// compare [_First1, _Last1) to [_First2, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2766 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2767 : 		_Unchecked(_First2)));

	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$_Equal@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@00@Z ; std::_Equal<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0> >
	add	esp, 12					; 0000000cH

; 2768 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$equal@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@00@Z ENDP ; std::equal<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$lexicographical_compare@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@000@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
??$lexicographical_compare@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@000@Z PROC ; std::lexicographical_compare<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >, COMDAT

; 2926 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2927 : 	_DEBUG_RANGE(_First1, _Last1);
; 2928 : 	_DEBUG_RANGE(_First2, _Last2);
; 2929 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2930 : 		_Unchecked(_First2), _Unchecked(_Last2)));

	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Unchecked@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@YA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$_Lexicographical_compare@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA_NV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@0@000@Z ; std::_Lexicographical_compare<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0> >
	add	esp, 16					; 00000010H

; 2931 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$lexicographical_compare@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@000@Z ENDP ; std::lexicographical_compare<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AATValueHolder@Value@Json@@@std@@YA$$QATValueHolder@Value@Json@@AAT123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AATValueHolder@Value@Json@@@std@@YA$$QATValueHolder@Value@Json@@AAT123@@Z PROC ; std::_Move<Json::Value::ValueHolder &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

	pop	ebp
	ret	0
??$_Move@AATValueHolder@Value@Json@@@std@@YA$$QATValueHolder@Value@Json@@AAT123@@Z ENDP ; std::_Move<Json::Value::ValueHolder &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPBD@std@@YA$$QAPBDAAPBD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPBD@std@@YA$$QAPBDAAPBD@Z PROC		; std::_Move<char const * &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

	pop	ebp
	ret	0
??$_Move@AAPBD@std@@YA$$QAPBDAAPBD@Z ENDP		; std::_Move<char const * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAH@std@@YA$$QAHAAH@Z PROC			; std::_Move<int &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

	pop	ebp
	ret	0
??$_Move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::_Move<int &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 107374182	; 06666666H
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 40
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z PROC ; std::_Allocate<Json::PathArgument>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 134217727	; 07ffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ENDP ; std::_Allocate<Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z PROC ; std::_Allocate<Json::PathArgument const *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z ENDP ; std::_Allocate<Json::PathArgument const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 178956970	; 0aaaaaaaH
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 24
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 95   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 16					; 00000010H

; 97   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBVCZString@Value@Json@@V23@@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBVCZString@Value@Json@@V23@@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z PROC ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn<Json::Value::CZString const ,Json::Value>, COMDAT

; 57   : 		static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)

	push	ebp
	mov	ebp, esp

; 58   : 		{	// extract key from element value
; 59   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[ebp]

; 60   : 		}

	pop	ebp
	ret	0
??$_Kfn@$$CBVCZString@Value@Json@@V23@@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ENDP ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn<Json::Value::CZString const ,Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@0@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR __Val2$[ebp]
	push	eax
	call	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 145  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@0@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal

; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_move@PAVPathArgument@Json@@PAV12@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ; std::_Uninitialized_move<Json::PathArgument *,Json::PathArgument *,std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
	add	esp, 16					; 00000010H

; 1649 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument> > >, COMDAT

; 95   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@VPathArgument@Json@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument,Json::PathArgument>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
	add	esp, 16					; 00000010H

; 97   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal

; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z ; std::_Uninitialized_move<Json::PathArgument const * *,Json::PathArgument const * *,std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
	add	esp, 16					; 00000010H

; 1649 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >, COMDAT

; 95   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PBVPathArgument@Json@@PBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument const *,Json::PathArgument const *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
	add	esp, 16					; 00000010H

; 97   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal

; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 16					; 00000010H

; 1649 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Movefl$ = 12						; size = 1
??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy<std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 1927 : 		void _Copy(const _Myt& _Right,

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);

	movzx	eax, BYTE PTR __Movefl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1931 : 		this->_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1932 : 		if (!this->_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy

; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1935 : 			_Rmost() = this->_Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1936 : 			}
; 1937 : 		else

	jmp	SHORT $LN3@Copy
$LN2@Copy:

; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1940 : 			_Rmost() = this->_Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Copy:

; 1941 : 			}
; 1942 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy<std::integral_constant<bool,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAV10@@Z PROC ; std::forward<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAV10@@Z ENDP ; std::forward<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@SAPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@SAPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<Json::Value::CZString const ,Json::Value> *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

	push	ebp
	mov	ebp, esp

; 234  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAPAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::addressof<std::pair<Json::Value::CZString const ,Json::Value> >
	add	esp, 4

; 235  : 		}

	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@SAPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<Json::Value::CZString const ,Json::Value> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAI@Z PROC ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,unsigned int>, COMDAT

; 765  : 	{	// add to _Off distance between iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,unsigned int>
	add	esp, 16					; 00000010H

; 767  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@PAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAPAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAPAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z PROC ; std::addressof<std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAPAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ENDP ; std::addressof<std::pair<Json::Value::CZString const ,Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	??$_Move@AAD@std@@YA$$QADAAD@Z		; std::_Move<char &>
	add	esp, 4
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR __Tmp$[ebp], cl

; 53   : 	_Left = _Move(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	call	??$_Move@AAD@std@@YA$$QADAAD@Z		; std::_Move<char &>
	add	esp, 4
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl

; 54   : 	_Right = _Move(_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	call	??$_Move@AAD@std@@YA$$QADAAD@Z		; std::_Move<char &>
	add	esp, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl

; 55   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z PROC ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> ><std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >, COMDAT
; _this$ = ecx

; 561  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z ENDP ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> ><std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VPathArgument@Json@@ABV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@ABV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPathArgument@Json@@ABV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@ABV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABVPathArgument@Json@@@std@@YAABVPathArgument@Json@@ABV12@@Z ; std::forward<Json::PathArgument const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@VPathArgument@Json@@ABV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@ABV34@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument const &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@VPathArgument@Json@@ABV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@ABV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VPathArgument@Json@@AAV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPathArgument@Json@@AAV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAVPathArgument@Json@@@std@@YAAAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@VPathArgument@Json@@AAV12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@AAV34@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@VPathArgument@Json@@AAV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBVPathArgument@Json@@@std@@YAPBVPathArgument@Json@@ABV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBVPathArgument@Json@@@std@@YAPBVPathArgument@Json@@ABV12@@Z PROC ; std::addressof<Json::PathArgument const >, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@$$CBVPathArgument@Json@@@std@@YAPBVPathArgument@Json@@ABV12@@Z ENDP ; std::addressof<Json::PathArgument const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VPathArgument@Json@@V12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPathArgument@Json@@V12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@VPathArgument@Json@@@std@@YA$$QAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@VPathArgument@Json@@V12@@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@VPathArgument@Json@@@1@PAVPathArgument@Json@@$$QAV34@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@VPathArgument@Json@@V12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@VPathArgument@Json@@@std@@YA$$QAVPathArgument@Json@@AAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@VPathArgument@Json@@@std@@YA$$QAVPathArgument@Json@@AAV12@@Z PROC ; std::forward<Json::PathArgument>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@VPathArgument@Json@@@std@@YA$$QAVPathArgument@Json@@AAV12@@Z ENDP ; std::forward<Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAV12@@Z PROC ; std::addressof<Json::PathArgument>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAV12@@Z ENDP ; std::addressof<Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PBVPathArgument@Json@@PBV12@@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PBVPathArgument@Json@@PBV12@@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::construct<Json::PathArgument const *,Json::PathArgument const *>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@PBVPathArgument@Json@@@std@@YA$$QAPBVPathArgument@Json@@AAPBV12@@Z ; std::forward<Json::PathArgument const *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PBVPathArgument@Json@@PBV12@@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAXAAV?$allocator@PBVPathArgument@Json@@@1@PAPBVPathArgument@Json@@$$QAPBV34@@Z ; std::allocator_traits<std::allocator<Json::PathArgument const *> >::construct<Json::PathArgument const *,Json::PathArgument const *>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PBVPathArgument@Json@@PBV12@@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::construct<Json::PathArgument const *,Json::PathArgument const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PBVPathArgument@Json@@@std@@YA$$QAPBVPathArgument@Json@@AAPBV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PBVPathArgument@Json@@@std@@YA$$QAPBVPathArgument@Json@@AAPBV12@@Z PROC ; std::forward<Json::PathArgument const *>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@PBVPathArgument@Json@@@std@@YA$$QAPBVPathArgument@Json@@AAPBV12@@Z ENDP ; std::forward<Json::PathArgument const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPBV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPBV12@@Z PROC ; std::addressof<Json::PathArgument const *>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPBV12@@Z ENDP ; std::addressof<Json::PathArgument const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::_Compat, COMDAT
; _this$ = ecx

; 254  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 255  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::_Compat

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 206  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 113  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEABVPathArgument@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEABVPathArgument@Json@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEABVPathArgument@Json@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	edx, DWORD PTR __Pvector$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z	; std::_Iterator_base0::_Adopt

; 49   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::_Compat, COMDAT
; _this$ = ecx

; 254  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 255  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::_Compat

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 206  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	edx, DWORD PTR __Pvector$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z	; std::_Iterator_base0::_Adopt

; 49   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$insert@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Newnode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert<std::pair<Json::Value::CZString const ,Json::Value> &>, COMDAT
; _this$ = ecx

; 1164 : 		typename enable_if<is_convertible<_Valty, value_type>::value,

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1165 : 			iterator>::type
; 1166 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1167 : 		{	// try to insert node with value _Val using _Where as a hint
; 1168 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAAAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::forward<std::pair<Json::Value::CZString const ,Json::Value> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Buynode@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Buynode<std::pair<Json::Value::CZString const ,Json::Value> &>
	mov	DWORD PTR __Newnode$[ebp], eax

; 1169 : 		return (_Insert_hint(_Where,
; 1170 : 			this->_Myval(_Newnode), _Newnode));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_hint@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert_hint<std::pair<Json::Value::CZString const ,Json::Value> &,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1171 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$insert@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert<std::pair<Json::Value::CZString const ,Json::Value> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z PROC ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value><Json::Value::CZString &,Json::Value const &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@AAVCZString@Value@Json@@@std@@YAAAVCZString@Value@Json@@AAV123@@Z ; std::forward<Json::Value::CZString &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR __Val2$[ebp]
	push	ecx
	call	??$forward@ABVValue@Json@@@std@@YAABVValue@Json@@ABV12@@Z ; std::forward<Json::Value const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value

; 145  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value><Json::Value::CZString &,Json::Value const &,void>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
tv84 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z PROC ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT

; 2247 : 	{	// test for _Tree equality

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 2248 : 	return (_Left.size() == _Right.size()
; 2249 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	ecx, DWORD PTR __Left$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	cmp	esi, eax
	jne	SHORT $LN3@operator
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$equal@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@00@Z ; std::equal<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv84[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv84[ebp]

; 2250 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z PROC ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT

; 2260 : 	{	// test if _Less < _Right for _Trees

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2261 : 	return (lexicographical_compare(_Left.begin(), _Left.end(),
; 2262 : 		_Right.begin(), _Right.end()));

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$lexicographical_compare@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@YA_NV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@000@Z ; std::lexicographical_compare<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >
	add	esp, 16					; 00000010H

; 2263 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z PROC ; std::swap<Json::Value::ValueHolder>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	??$_Move@AATValueHolder@Value@Json@@@std@@YA$$QATValueHolder@Value@Json@@AAT123@@Z ; std::_Move<Json::Value::ValueHolder &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 53   : 	_Left = _Move(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$_Move@AATValueHolder@Value@Json@@@std@@YA$$QATValueHolder@Value@Json@@AAT123@@Z ; std::_Move<Json::Value::ValueHolder &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 54   : 	_Right = _Move(_Tmp);

	lea	ecx, DWORD PTR __Tmp$[ebp]
	push	ecx
	call	??$_Move@AATValueHolder@Value@Json@@@std@@YA$$QATValueHolder@Value@Json@@AAT123@@Z ; std::_Move<Json::Value::ValueHolder &>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 55   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z ENDP ; std::swap<Json::Value::ValueHolder>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@PBD@std@@YAXAAPBD0@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PBD@std@@YAXAAPBD0@Z PROC			; std::swap<char const *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	??$_Move@AAPBD@std@@YA$$QAPBDAAPBD@Z	; std::_Move<char const * &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 53   : 	_Left = _Move(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	call	??$_Move@AAPBD@std@@YA$$QAPBDAAPBD@Z	; std::_Move<char const * &>
	add	esp, 4
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 54   : 	_Right = _Move(_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	call	??$_Move@AAPBD@std@@YA$$QAPBDAAPBD@Z	; std::_Move<char const * &>
	add	esp, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 55   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@PBD@std@@YAXAAPBD0@Z ENDP			; std::swap<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAEPAXI@Z PROC ; std::pair<Json::Value::CZString const ,Json::Value>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAEPAXI@Z ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z PROC ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ PROC ; std::pair<Json::Value::CZString const ,Json::Value>::~pair<Json::Value::CZString const ,Json::Value>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::~pair<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??__EdummyValueAllocatorInitializer@Json@@YAXXZ
text$di	SEGMENT
??__EdummyValueAllocatorInitializer@Json@@YAXXZ PROC	; Json::`dynamic initializer for 'dummyValueAllocatorInitializer'', COMDAT

; 110  : } dummyValueAllocatorInitializer;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _dummyValueAllocatorInitializer
	call	??0DummyValueAllocatorInitializer@Json@@QAE@XZ ; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer
	pop	ebp
	ret	0
??__EdummyValueAllocatorInitializer@Json@@YAXXZ ENDP	; Json::`dynamic initializer for 'dummyValueAllocatorInitializer''
text$di	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0DummyValueAllocatorInitializer@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DummyValueAllocatorInitializer@Json@@QAE@XZ PROC	; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer, COMDAT
; _this$ = ecx

; 106  :    DummyValueAllocatorInitializer() 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  :    {
; 108  :       valueAllocator();      // ensure valueAllocator() statics are initialized before main().

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator

; 109  :    }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DummyValueAllocatorInitializer@Json@@QAE@XZ ENDP	; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FdefaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ@YAXXZ
text$yd	SEGMENT
??__FdefaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ@YAXXZ PROC ; `Json::valueAllocator'::`2'::`dynamic atexit destructor for 'defaultAllocator'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A
	call	??1DefaultValueAllocator@Json@@UAE@XZ	; Json::DefaultValueAllocator::~DefaultValueAllocator
	pop	ebp
	ret	0
??__FdefaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ@YAXXZ ENDP ; `Json::valueAllocator'::`2'::`dynamic atexit destructor for 'defaultAllocator''
text$yd	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ
_TEXT	SEGMENT
?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ PROC	; Json::valueAllocator, COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp

; 100  :    static DefaultValueAllocator defaultAllocator;

	mov	eax, DWORD PTR ?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	and	eax, 1
	jne	SHORT $LN1@valueAlloc
	mov	ecx, DWORD PTR ?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, ecx
	mov	ecx, OFFSET ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A
	call	??0DefaultValueAllocator@Json@@QAE@XZ
	push	OFFSET ??__FdefaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ@YAXXZ ; `Json::valueAllocator'::`2'::`dynamic atexit destructor for 'defaultAllocator''
	call	_atexit
	add	esp, 4
$LN1@valueAlloc:

; 101  :    static ValueAllocator *valueAllocator = &defaultAllocator;
; 102  :    return valueAllocator;

	mov	eax, OFFSET ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A

; 103  : }

	pop	ebp
	ret	0
?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ENDP	; Json::valueAllocator
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GDefaultValueAllocator@Json@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDefaultValueAllocator@Json@@UAEPAXI@Z PROC		; Json::DefaultValueAllocator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DefaultValueAllocator@Json@@UAE@XZ	; Json::DefaultValueAllocator::~DefaultValueAllocator
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDefaultValueAllocator@Json@@UAEPAXI@Z ENDP		; Json::DefaultValueAllocator::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0DefaultValueAllocator@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DefaultValueAllocator@Json@@QAE@XZ PROC		; Json::DefaultValueAllocator::DefaultValueAllocator, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueAllocator@Json@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DefaultValueAllocator@Json@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DefaultValueAllocator@Json@@QAE@XZ ENDP		; Json::DefaultValueAllocator::DefaultValueAllocator
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z PROC ; Json::DefaultValueAllocator::releaseStringValue, COMDAT
; _this$ = ecx

; 92   :    {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   :       if ( value )

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN2@releaseStr

; 94   :          free( value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN2@releaseStr:

; 95   :    }

	mov	esp, ebp
	pop	ebp
	ret	4
?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z ENDP ; Json::DefaultValueAllocator::releaseStringValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv67 = -20						; size = 4
tv80 = -16						; size = 4
_newString$ = -12					; size = 4
tv77 = -8						; size = 4
tv83 = -1						; size = 1
_value$ = 8						; size = 4
_length$ = 12						; size = 4
?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z PROC ; Json::DefaultValueAllocator::duplicateStringValue, COMDAT
; _this$ = ecx

; 78   :    {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 79   :       //@todo invesgate this old optimization
; 80   :       //if ( !value  ||  value[0] == 0 )
; 81   :       //   return 0;
; 82   : 
; 83   :       if ( length == unknown )

	cmp	DWORD PTR _length$[ebp], -1
	jne	SHORT $LN1@duplicateS

; 84   :          length = (unsigned int)strlen(value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	mov	ecx, DWORD PTR tv77[ebp]
	add	ecx, 1
	mov	DWORD PTR tv80[ebp], ecx
$LL4@duplicateS:
	mov	edx, DWORD PTR tv77[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv83[ebp], al
	add	DWORD PTR tv77[ebp], 1
	cmp	BYTE PTR tv83[ebp], 0
	jne	SHORT $LL4@duplicateS
	mov	ecx, DWORD PTR tv77[ebp]
	sub	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _length$[ebp], edx
$LN1@duplicateS:

; 85   :       char *newString = static_cast<char *>( malloc( length + 1 ) );

	mov	eax, DWORD PTR _length$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _newString$[ebp], eax

; 86   :       memcpy( newString, value, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _newString$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 87   :       newString[length] = 0;

	mov	ecx, DWORD PTR _newString$[ebp]
	add	ecx, DWORD PTR _length$[ebp]
	mov	BYTE PTR [ecx], 0

; 88   :       return newString;

	mov	eax, DWORD PTR _newString$[ebp]

; 89   :    }

	mov	esp, ebp
	pop	ebp
	ret	8
?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z ENDP ; Json::DefaultValueAllocator::duplicateStringValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_memberName$ = 8					; size = 4
?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z PROC ; Json::DefaultValueAllocator::releaseMemberName, COMDAT
; _this$ = ecx

; 72   :    {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   :       releaseStringValue( memberName );

	mov	eax, DWORD PTR _memberName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 74   :    }

	mov	esp, ebp
	pop	ebp
	ret	4
?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z ENDP ; Json::DefaultValueAllocator::releaseMemberName
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_memberName$ = 8					; size = 4
?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z PROC ; Json::DefaultValueAllocator::makeMemberName, COMDAT
; _this$ = ecx

; 67   :    {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   :       return duplicateStringValue( memberName );

	push	-1
	mov	eax, DWORD PTR _memberName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 69   :    }

	mov	esp, ebp
	pop	ebp
	ret	4
?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z ENDP ; Json::DefaultValueAllocator::makeMemberName
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??1DefaultValueAllocator@Json@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DefaultValueAllocator@Json@@UAE@XZ PROC		; Json::DefaultValueAllocator::~DefaultValueAllocator, COMDAT
; _this$ = ecx

; 63   :    {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DefaultValueAllocator@Json@@6B@

; 64   :    }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ValueAllocator@Json@@UAE@XZ		; Json::ValueAllocator::~ValueAllocator
	mov	esp, ebp
	pop	ebp
	ret	0
??1DefaultValueAllocator@Json@@UAE@XZ ENDP		; Json::DefaultValueAllocator::~DefaultValueAllocator
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?null@Value@Json@@2V12@B@@YAXXZ
text$yd	SEGMENT
??__F?null@Value@Json@@2V12@B@@YAXXZ PROC		; `dynamic atexit destructor for 'Json::Value::null'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	pop	ebp
	ret	0
??__F?null@Value@Json@@2V12@B@@YAXXZ ENDP		; `dynamic atexit destructor for 'Json::Value::null''
text$yd	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??__E?null@Value@Json@@2V12@B@@YAXXZ
text$di	SEGMENT
??__E?null@Value@Json@@2V12@B@@YAXXZ PROC		; `dynamic initializer for 'Json::Value::null'', COMDAT

; 22   : const Value Value::null;

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	push	OFFSET ??__F?null@Value@Json@@2V12@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Value::null''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?null@Value@Json@@2V12@B@@YAXXZ ENDP		; `dynamic initializer for 'Json::Value::null''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GStyledWriter@Json@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GStyledWriter@Json@@UAEPAXI@Z PROC			; Json::StyledWriter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1StyledWriter@Json@@UAE@XZ		; Json::StyledWriter::~StyledWriter
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GStyledWriter@Json@@UAEPAXI@Z ENDP			; Json::StyledWriter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range, COMDAT
; _this$ = ecx

; 1780 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1781 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT
; _this$ = ecx

; 1753 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN2@Xlen:

; 1755 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1623 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	mov	eax, ecx
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate

; 1629 : 			this->_Myfirst = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1630 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1631 : 			this->_Myend = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN2@Tidy:

; 1632 : 			}
; 1633 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1613 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1616 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$LN1@Reserve:

; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEII@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN4@Reserve:

; 1618 : 			}
; 1619 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -32						; size = 4
__Ptr$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1589 : 
; 1590 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$0:

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate

; 1594 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1595 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$1:

; 1596 : 
; 1597 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1598 : 		if (this->_Myfirst != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Reallocate

; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
$LN1@Reallocate:

; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1606 : 		this->_Myend = _Ptr + _Count;

	imul	edx, DWORD PTR __Count$[ebp], 24
	add	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1607 : 		this->_Mylast = _Ptr + _Size;

	imul	ecx, DWORD PTR __Size$[ebp], 24
	add	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1608 : 		this->_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@Reallocate:

; 1609 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1584 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Capacity$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEII@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1572 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1576 : 		if (_Capacity < _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1577 : 			_Capacity = _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx
$LN1@Grow_to:

; 1578 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1579 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEII@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1565 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1566 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal

; 1567 : 		_Destroy_range(_First, _Last, _Alval);

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 12					; 0000000cH

; 1568 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 1152 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1153 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size

; 1154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 1147 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1014 : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx

; 1016 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT
; _this$ = ecx

; 1009 : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx

; 1011 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve, COMDAT
; _this$ = ecx

; 999  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1000 : 		if (capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@reserve

; 1003 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$LN1@reserve:

; 1004 : 			_Reallocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN4@reserve:

; 1005 : 			}
; 1006 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Idx$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 865  : 		{	// insert by moving into element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 866  : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@push_back

; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR __Idx$1[ebp], eax

; 869  : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@push_back

; 870  : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
$LN3@push_back:

; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range

; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

	imul	eax, DWORD PTR __Idx$1[ebp], 24
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	ecx, eax
	call	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 874  : 			++this->_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 875  : 			}
; 876  : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN1@push_back

; 879  : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
$LN1@push_back:

; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range

; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	ecx, eax
	call	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 883  : 			++this->_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN5@push_back:

; 884  : 			}
; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_rv, COMDAT
; _this$ = ecx

; 837  : 		{	// move from _Right, stealing its contents

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 838  : 		this->_Swap_all((_Myt&)_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z

; 839  : 		this->_Myfirst = _Right._Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 840  : 		this->_Mylast = _Right._Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 841  : 		this->_Myend = _Right._Myend;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 842  : 
; 843  : 		_Right._Myfirst = pointer();

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [ecx], 0

; 844  : 		_Right._Mylast = pointer();

	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [edx+4], 0

; 845  : 		_Right._Myend = pointer();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [eax+8], 0

; 846  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Assign_rv@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@$$QAV01@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 812  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());

	xor	ecx, ecx
	mov	BYTE PTR $T2[ebp], cl
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAV10@@Z ; std::forward<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_rv@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_rv

; 814  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 680  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 681  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 480  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 483  : 		_Mylast = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 485  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 178956970				; 0aaaaaaaH

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\include\json\writer.h
;	COMDAT ??1StyledWriter@Json@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1StyledWriter@Json@@UAE@XZ PROC			; Json::StyledWriter::~StyledWriter, COMDAT
; _this$ = ecx

; 69   :       virtual ~StyledWriter(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7StyledWriter@Json@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Writer@Json@@UAE@XZ			; Json::Writer::~Writer
	mov	esp, ebp
	pop	ebp
	ret	0
??1StyledWriter@Json@@UAE@XZ ENDP			; Json::StyledWriter::~StyledWriter
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??4ValueIterator@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4ValueIterator@Json@@QAEAAV01@ABV01@@Z PROC		; Json::ValueIterator::operator=, COMDAT
; _this$ = ecx

; 289  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 290  :    copy( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?copy@ValueIteratorBase@Json@@IAEXABV12@@Z ; Json::ValueIteratorBase::copy

; 291  :    return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??4ValueIterator@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::ValueIterator::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_current$ = 8						; size = 4
??0ValueIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z PROC ; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = ecx

; 263  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _current$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueIteratorBase@Json@@QAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ; Json::ValueIteratorBase::ValueIteratorBase

; 264  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ENDP ; Json::ValueIterator::ValueIterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueIterator@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??0ValueIterator@Json@@QAE@ABV01@@Z PROC		; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = ecx

; 284  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 285  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueIterator@Json@@QAE@ABV01@@Z ENDP		; Json::ValueIterator::ValueIterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z PROC ; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 280  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z ENDP ; Json::ValueIterator::ValueIterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueIterator@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ValueIterator@Json@@QAE@XZ PROC			; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = ecx

; 256  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueIteratorBase@Json@@QAE@XZ	; Json::ValueIteratorBase::ValueIteratorBase

; 257  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ValueIterator@Json@@QAE@XZ ENDP			; Json::ValueIterator::ValueIterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z PROC ; Json::ValueConstIterator::operator=, COMDAT
; _this$ = ecx

; 241  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  :    copy( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?copy@ValueIteratorBase@Json@@IAEXABV12@@Z ; Json::ValueIteratorBase::copy

; 243  :    return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z ENDP ; Json::ValueConstIterator::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueConstIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_current$ = 8						; size = 4
??0ValueConstIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z PROC ; Json::ValueConstIterator::ValueConstIterator, COMDAT
; _this$ = ecx

; 225  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _current$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueIteratorBase@Json@@QAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ; Json::ValueIteratorBase::ValueIteratorBase

; 226  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueConstIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ENDP ; Json::ValueConstIterator::ValueConstIterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueConstIterator@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ValueConstIterator@Json@@QAE@XZ PROC			; Json::ValueConstIterator::ValueConstIterator, COMDAT
; _this$ = ecx

; 218  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueIteratorBase@Json@@QAE@XZ	; Json::ValueIteratorBase::ValueIteratorBase

; 219  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ValueConstIterator@Json@@QAE@XZ ENDP			; Json::ValueConstIterator::ValueConstIterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 425  : 		--(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--

; 426  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 427  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++, COMDAT
; _this$ = ecx

; 411  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 412  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++

; 413  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 414  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator->, COMDAT
; _this$ = ecx

; 406  : 		{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	push	eax
	call	?pointer_to@?$pointer_traits@PAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@SAPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@AAU32@@Z ; std::pointer_traits<std::pair<Json::Value::CZString const ,Json::Value> *>::pointer_to
	add	esp, 4

; 408  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*, COMDAT
; _this$ = ecx

; 401  : 		{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*

; 403  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >

; 385  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >, COMDAT
; _this$ = ecx

; 378  : 	_Tree_iterator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >

; 379  : 		{	// construct with null node
; 380  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 342  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv75 = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv75[ebp]

; 337  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator--

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 312  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 278  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++

; 279  : 		return (_Tmp);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 280  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++, COMDAT
; _this$ = ecx

; 256  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*, COMDAT
; _this$ = ecx

; 231  : 		{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
	add	esp, 4

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Unchecked@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Unchecked, COMDAT
; _this$ = ecx

; 226  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 228  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Unchecked@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>

; 215  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >, COMDAT
; _this$ = ecx

; 209  : 		{	// construct with null node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>

; 210  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 124  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator!=, COMDAT
; _this$ = ecx

; 117  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator==, COMDAT
; _this$ = ecx

; 112  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv67[ebp]

; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$1 = -8						; size = 4
_this$ = -4						; size = 4
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN8@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	jmp	$LN7@operator
$LN8@operator:

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@operator

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Max
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 90   : 		else

	jmp	SHORT $LN7@operator
$LN4@operator:

; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$1[ebp], edx
	mov	eax, DWORD PTR __Pnode$1[ebp]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$1[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN4@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else

	jmp	SHORT $LN7@operator
$LN2@operator:

; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$1[ebp]
	mov	DWORD PTR [edx], eax
$LN7@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 102  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$1 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN6@operator
	jmp	$LN5@operator
$LN6@operator:

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@operator

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Min
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 65   : 		else

	jmp	SHORT $LN5@operator
$LN2@operator:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$1[ebp], ecx
	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN1@operator
	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$1[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$1[ebp]
	mov	DWORD PTR [ecx], edx
$LN5@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = ecx

; 49   : 		{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		return (_Mytree::_Myval(_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
	add	esp, 4

; 51   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 45   : 		this->_Adopt(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z	; std::_Iterator_base0::_Adopt

; 46   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ?copy@ValueIteratorBase@Json@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?copy@ValueIteratorBase@Json@@IAEXABV12@@Z PROC		; Json::ValueIteratorBase::copy, COMDAT
; _this$ = ecx

; 144  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 146  :    current_ = other.current_;

	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 147  : #else
; 148  :    if ( isArray_ )
; 149  :       iterator_.array_ = other.iterator_.array_;
; 150  :    iterator_.map_ = other.iterator_.map_;
; 151  : #endif
; 152  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?copy@ValueIteratorBase@Json@@IAEXABV12@@Z ENDP		; Json::ValueIteratorBase::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z PROC	; Json::ValueIteratorBase::isEqual, COMDAT
; _this$ = ecx

; 127  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 129  :    if ( isNull_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN1@isEqual

; 130  :    {
; 131  :       return other.isNull_;

	mov	edx, DWORD PTR _other$[ebp]
	mov	al, BYTE PTR [edx+4]
	jmp	SHORT $LN2@isEqual
$LN1@isEqual:

; 132  :    }
; 133  :    return current_ == other.current_;

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
$LN2@isEqual:

; 134  : #else
; 135  :    if ( isArray_ )
; 136  :       return ValueInternalArray::equals( iterator_.array_, other.iterator_.array_ );
; 137  :    return ValueInternalMap::equals( iterator_.map_, other.iterator_.map_ );
; 138  : #endif
; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z ENDP	; Json::ValueIteratorBase::isEqual
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z
_TEXT	SEGMENT
_it$1 = -12						; size = 4
_this$ = -8						; size = 4
_myDistance$ = -4					; size = 4
_other$ = 8						; size = 4
?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z PROC ; Json::ValueIteratorBase::computeDistance, COMDAT
; _this$ = ecx

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 91   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 92   : # ifdef JSON_USE_CPPTL_SMALLMAP
; 93   :    return current_ - other.current_;
; 94   : # else
; 95   :    // Iterator for null value are initialized using the default
; 96   :    // constructor, which initialize current_ to the default
; 97   :    // std::map::iterator. As begin() and end() are two instance 
; 98   :    // of the default std::map::iterator, they can not be compared.
; 99   :    // To allow this, we handle this comparison specifically.
; 100  :    if ( isNull_  &&  other.isNull_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN4@computeDis
	mov	edx, DWORD PTR _other$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	test	eax, eax
	je	SHORT $LN4@computeDis

; 101  :    {
; 102  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN5@computeDis
$LN4@computeDis:

; 103  :    }
; 104  : 
; 105  : 
; 106  :    // Usage of std::distance is not portable (does not compile with Sun Studio 12 RogueWave STL,
; 107  :    // which is the one used by default).
; 108  :    // Using a portable hand-made version for non random iterator instead:
; 109  :    //   return difference_type( std::distance( current_, other.current_ ) );
; 110  :    difference_type myDistance = 0;

	mov	DWORD PTR _myDistance$[ebp], 0

; 111  :    for ( Value::ObjectValues::iterator it = current_; it != other.current_; ++it )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _it$1[ebp], edx
	jmp	SHORT $LN3@computeDis
$LN2@computeDis:
	lea	ecx, DWORD PTR _it$1[ebp]
	call	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
$LN3@computeDis:
	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	lea	ecx, DWORD PTR _it$1[ebp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@computeDis

; 112  :    {
; 113  :       ++myDistance;

	mov	edx, DWORD PTR _myDistance$[ebp]
	add	edx, 1
	mov	DWORD PTR _myDistance$[ebp], edx

; 114  :    }

	jmp	SHORT $LN2@computeDis
$LN1@computeDis:

; 115  :    return myDistance;

	mov	eax, DWORD PTR _myDistance$[ebp]
$LN5@computeDis:

; 116  : # endif
; 117  : #else
; 118  :    if ( isArray_ )
; 119  :       return ValueInternalArray::distance( iterator_.array_, other.iterator_.array_ );
; 120  :    return ValueInternalMap::distance( iterator_.map_, other.iterator_.map_ );
; 121  : #endif
; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z ENDP ; Json::ValueIteratorBase::computeDistance
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ?decrement@ValueIteratorBase@Json@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?decrement@ValueIteratorBase@Json@@IAEXXZ PROC		; Json::ValueIteratorBase::decrement, COMDAT
; _this$ = ecx

; 77   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 79   :    --current_;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--

; 80   : #else
; 81   :    if ( isArray_ )
; 82   :       ValueInternalArray::decrement( iterator_.array_ );
; 83   :    ValueInternalMap::decrement( iterator_.map_ );
; 84   : #endif
; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?decrement@ValueIteratorBase@Json@@IAEXXZ ENDP		; Json::ValueIteratorBase::decrement
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ?increment@ValueIteratorBase@Json@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?increment@ValueIteratorBase@Json@@IAEXXZ PROC		; Json::ValueIteratorBase::increment, COMDAT
; _this$ = ecx

; 64   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 66   :    ++current_;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++

; 67   : #else
; 68   :    if ( isArray_ )
; 69   :       ValueInternalArray::increment( iterator_.array_ );
; 70   :    ValueInternalMap::increment( iterator_.map_ );
; 71   : #endif
; 72   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?increment@ValueIteratorBase@Json@@IAEXXZ ENDP		; Json::ValueIteratorBase::increment
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ PROC	; Json::ValueIteratorBase::deref, COMDAT
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 52   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 53   :    return current_->second;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator->
	add	eax, 8

; 54   : #else
; 55   :    if ( isArray_ )
; 56   :       return ValueInternalArray::dereference( iterator_.array_ );
; 57   :    return ValueInternalMap::value( iterator_.map_ );
; 58   : #endif
; 59   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ ENDP	; Json::ValueIteratorBase::deref
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ?memberName@ValueIteratorBase@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv71 = -8						; size = 4
_name$ = -4						; size = 4
?memberName@ValueIteratorBase@Json@@QBEPBDXZ PROC	; Json::ValueIteratorBase::memberName, COMDAT
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 198  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 199  :    const char *name = (*current_).first.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	mov	ecx, eax
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	mov	DWORD PTR _name$[ebp], eax

; 200  :    return name ? name : "";

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN3@memberName
	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@memberName
$LN3@memberName:
	mov	DWORD PTR tv71[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@memberName:
	mov	eax, DWORD PTR tv71[ebp]

; 201  : #else
; 202  :    if ( !isArray_ )
; 203  :       return ValueInternalMap::key( iterator_.map_ );
; 204  :    return "";
; 205  : #endif
; 206  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?memberName@ValueIteratorBase@Json@@QBEPBDXZ ENDP	; Json::ValueIteratorBase::memberName
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ?index@ValueIteratorBase@Json@@QBEIXZ
_TEXT	SEGMENT
_czstring$ = -32					; size = 8
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?index@ValueIteratorBase@Json@@QBEIXZ PROC		; Json::ValueIteratorBase::index, COMDAT
; _this$ = ecx

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?index@ValueIteratorBase@Json@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 182  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 183  :    const Value::CZString czstring = (*current_).first;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	push	eax
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 184  :    if ( !czstring.c_str() )

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	test	eax, eax
	jne	SHORT $LN1@index

; 185  :       return czstring.index();

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?index@CZString@Value@Json@@QBEHXZ	; Json::Value::CZString::index
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN2@index
$LN1@index:

; 186  :    return Value::UInt( -1 );

	mov	DWORD PTR $T2[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T2[ebp]
$LN2@index:

; 187  : #else
; 188  :    if ( isArray_ )
; 189  :       return Value::UInt( ValueInternalArray::indexOf( iterator_.array_ ) );
; 190  :    return Value::UInt( -1 );
; 191  : #endif
; 192  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?index@ValueIteratorBase@Json@@QBEIXZ$0:
	lea	ecx, DWORD PTR _czstring$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$?index@ValueIteratorBase@Json@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?index@ValueIteratorBase@Json@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?index@ValueIteratorBase@Json@@QBEIXZ ENDP		; Json::ValueIteratorBase::index
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
_TEXT	SEGMENT
_czstring$ = -32					; size = 8
$T2 = -24						; size = 4
_this$ = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ PROC	; Json::ValueIteratorBase::key, COMDAT
; _this$ = ecx

; 157  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T3[ebp], 0

; 158  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 159  :    const Value::CZString czstring = (*current_).first;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	push	eax
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 160  :    if ( czstring.c_str() )

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	test	eax, eax
	je	SHORT $LN2@key

; 161  :    {
; 162  :       if ( czstring.isStaticString() )

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?isStaticString@CZString@Value@Json@@QBE_NXZ ; Json::Value::CZString::isStaticString
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@key

; 163  :          return Value( StaticString( czstring.c_str() ) );

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0StaticString@Json@@QAE@PBD@Z		; Json::StaticString::StaticString
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABVStaticString@1@@Z	; Json::Value::Value
	mov	ecx, DWORD PTR $T3[ebp]
	or	ecx, 1
	mov	DWORD PTR $T3[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@key
$LN1@key:

; 164  :       return Value( czstring.c_str() );

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@PBD@Z		; Json::Value::Value
	mov	edx, DWORD PTR $T3[ebp]
	or	edx, 1
	mov	DWORD PTR $T3[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@key
$LN2@key:

; 165  :    }
; 166  :    return Value( czstring.index() );

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?index@CZString@Value@Json@@QBEHXZ	; Json::Value::CZString::index
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@H@Z			; Json::Value::Value
	mov	eax, DWORD PTR $T3[ebp]
	or	eax, 1
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@key:

; 167  : #else
; 168  :    if ( isArray_ )
; 169  :       return Value( ValueInternalArray::indexOf( iterator_.array_ ) );
; 170  :    bool isStatic;
; 171  :    const char *memberName = ValueInternalMap::key( iterator_.map_, isStatic );
; 172  :    if ( isStatic )
; 173  :       return Value( StaticString( memberName ) );
; 174  :    return Value( memberName );
; 175  : #endif
; 176  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ$0:
	lea	ecx, DWORD PTR _czstring$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__unwindfunclet$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ$1:
	mov	eax, DWORD PTR $T3[ebp]
	and	eax, 1
	je	$LN7@key
	and	DWORD PTR $T3[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN7@key:
	ret	0
__ehhandler$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ ENDP	; Json::ValueIteratorBase::key
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueIteratorBase@Json@@QAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_current$ = 8						; size = 4
??0ValueIteratorBase@Json@@QAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z PROC ; Json::ValueIteratorBase::ValueIteratorBase, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 33   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueIteratorBase@Json@@QAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ENDP ; Json::ValueIteratorBase::ValueIteratorBase
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z PROC ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ PROC ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z PROC ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = ecx

; 109  : 		{	// construct map by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::select_on_container_copy_construction
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$?0U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> ><std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >

; 110  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ PROC ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >

; 96   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key, COMDAT
; _this$ = ecx

; 2239 : 		{	// return reference to key in node

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2240 : 		return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn

; 2241 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2234 : 		{	// get key from value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2235 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$_Kfn@$$CBVCZString@Value@Json@@V23@@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn<Json::Value::CZString const ,Json::Value>
	add	esp, 4

; 2236 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Kfn@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2230 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T5[ebp], ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase

; 2231 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2157 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate

; 2166 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate
$LN4@Rrotate:

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2169 : 		else

	jmp	SHORT $LN3@Rrotate
$LN2@Rrotate:

; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate:

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2174 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root, COMDAT
; _this$ = ecx

; 2152 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2153 : 		return (this->_Parent(this->_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4

; 2154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 2147 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2148 : 		return (this->_Right(this->_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4

; 2149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2127 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate

; 2136 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate
$LN4@Lrotate:

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2139 : 		else

	jmp	SHORT $LN3@Lrotate
$LN2@Lrotate:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2144 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2122 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2123 : 		return (this->_Left(this->_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4

; 2124 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
__Wherenode$ = -16					; size = 4
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
$T1 = -1						; size = 1
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 2105 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2106 : 		_Nodeptr _Pnode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Wherenode$[ebp], edx
$LN4@Lbound:

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@Lbound

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

	mov	edx, DWORD PTR __Keyval$[ebp]
	push	edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	ecx, eax
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Lbound

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 2112 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 2116 : 				}

	jmp	SHORT $LN4@Lbound
$LN3@Lbound:

; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 2119 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$1 = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2074 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$1[ebp], eax

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	jmp	SHORT $LN3@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$1[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase:
	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase

; 2079 : 			_Pnode = this->_Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$1[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$1[ebp], ecx

; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
	add	esp, 4
	push	eax
	call	??$addressof@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAPAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::addressof<std::pair<Json::Value::CZString const ,Json::Value> >
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >

; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);

	push	1
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate

; 2084 : 			}

	jmp	$LN2@Erase
$LN4@Erase:

; 2085 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Eqrange@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
__Lonode$ = -24						; size = 4
tv160 = -20						; size = 4
__Hinode$ = -16						; size = 4
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?_Eqrange@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Eqrange, COMDAT
; _this$ = ecx

; 2039 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2040 : 		_Nodeptr _Pnode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Lonode$[ebp], edx

; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Hinode$[ebp], ecx
$LN9@Eqrange:

; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN8@Eqrange

; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	ecx, eax
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@Eqrange

; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 2047 : 			else

	jmp	SHORT $LN6@Eqrange
$LN7@Eqrange:

; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

	mov	ecx, DWORD PTR __Hinode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN5@Eqrange
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	ecx, eax
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Eqrange

; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Hinode$[ebp], ecx
$LN5@Eqrange:

; 2053 : 				_Lonode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Lonode$[ebp], edx

; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN6@Eqrange:

; 2055 : 				}

	jmp	$LN9@Eqrange
$LN8@Eqrange:

; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound

	mov	edx, DWORD PTR __Hinode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN12@Eqrange
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv160[ebp], ecx
	jmp	SHORT $LN13@Eqrange
$LN12@Eqrange:
	mov	edx, DWORD PTR __Hinode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv160[ebp], eax
$LN13@Eqrange:
	mov	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN4@Eqrange:

; 2059 : 		while (!this->_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Eqrange

; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	push	eax
	mov	edx, DWORD PTR __Keyval$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	ecx, eax
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Eqrange

; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Hinode$[ebp], edx

; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 2064 : 				}
; 2065 : 			else

	jmp	SHORT $LN1@Eqrange
$LN2@Eqrange:

; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN1@Eqrange:
	jmp	SHORT $LN4@Eqrange
$LN3@Eqrange:

; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lonode$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >

; 2069 : 		iterator _Last = iterator(_Hinode, this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Hinode$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >

; 2070 : 		return (_Pairii(_First, _Last));

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@0@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > > &,void>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2071 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Eqrange@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Eqrange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1648 : 		{	// node exists, destroy it

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));

	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
	add	esp, 4
	push	eax
	call	??$addressof@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAPAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::addressof<std::pair<Json::Value::CZString const ,Json::Value> >
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >

; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);

	push	1
	mov	edx, DWORD PTR __Newnode$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate

; 1653 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range, COMDAT
; _this$ = ecx

; 1594 : 		{	// find range equivalent to _Keyval in mutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1595 : 		return (_Eqrange(_Keyval));

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eqrange@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Eqrange
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1596 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1575 : 		return (iterator(_Lbound(_Keyval), this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1576 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
tv140 = -16						; size = 4
__Where$ = -12						; size = 4
_this$ = -8						; size = 4
$T5 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find, COMDAT
; _this$ = ecx

; 1548 : 		{	// find an element in mutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1549 : 		iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound

; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@find
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEABVCZString@Value@Json@@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	ecx, eax
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@find
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	lea	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR tv140[ebp], edx
	jmp	SHORT $LN4@find
$LN3@find:
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	DWORD PTR tv140[ebp], eax
$LN4@find:
	mov	ecx, DWORD PTR tv140[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1554 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear, COMDAT
; _this$ = ecx

; 1535 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase

; 1541 : 		_Root() = this->_Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1542 : 		_Lmost() = this->_Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1543 : 		_Rmost() = this->_Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1544 : 		this->_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1545 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
__Where$ = -28						; size = 8
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase, COMDAT
; _this$ = ecx

; 1526 : 		{	// erase and count all that match _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1527 : 		_Pairii _Where = equal_range(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@V12@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range

; 1528 : 		size_type _Num = 0;

	mov	DWORD PTR __Num$[ebp], 0

; 1529 : 		_Distance(_Where.first, _Where.second, _Num);

	lea	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >,unsigned int>
	add	esp, 12					; 0000000cH

; 1530 : 		erase(_Where.first, _Where.second);

	mov	edx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR $T3[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase

; 1531 : 		return (_Num);

	mov	eax, DWORD PTR __Num$[ebp]

; 1532 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase, COMDAT
; _this$ = ecx

; 1511 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1512 : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase

; 1513 : 			{	// erase all
; 1514 : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear

; 1515 : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase

; 1516 : 			}
; 1517 : 		else

	jmp	SHORT $LN5@erase
$LN2@erase:

; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase

; 1520 : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
	jmp	SHORT $LN2@erase
$LN1@erase:

; 1521 : 			return (iterator(_First._Ptr, this));

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 1522 : 			}
; 1523 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv171 = -32						; size = 4
tv159 = -28						; size = 4
_this$ = -24						; size = 4
__Erasednode$ = -20					; size = 4
__Fixnode$ = -16					; size = 4
__Fixnodeparent$ = -12					; size = 4
__Pnode$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase, COMDAT
; _this$ = ecx

; 1328 : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 1338 : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++

; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase

; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase
$LN39@erase:

; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase

; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 1349 : 		else

	jmp	SHORT $LN38@erase
$LN37@erase:

; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase:

; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase

; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 1358 : 			if (!this->_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase

; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase:

; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase

; 1362 : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase
$LN33@erase:

; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase

; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 1365 : 			else

	jmp	SHORT $LN32@erase
$LN31@erase:

; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase:

; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN42@erase
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv159[ebp], edx
	jmp	SHORT $LN43@erase
$LN42@erase:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Min
	add	esp, 4
	mov	DWORD PTR tv159[ebp], eax
$LN43@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv159[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase:

; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN44@erase
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv171[ebp], edx
	jmp	SHORT $LN45@erase
$LN44@erase:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Max
	add	esp, 4
	mov	DWORD PTR tv171[ebp], eax
$LN45@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv171[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase:

; 1378 : 			}
; 1379 : 		else

	jmp	$LN27@erase
$LN35@erase:

; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase

; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 1388 : 			else

	jmp	$LN25@erase
$LN26@erase:

; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 1392 : 				if (!this->_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase

; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase:

; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase:

; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase

; 1402 : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase
$LN23@erase:

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase

; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1406 : 			else

	jmp	SHORT $LN22@erase
$LN21@erase:

; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase:

; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase:

; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	jmp	SHORT $LN18@erase
$LN17@erase:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase

; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase

; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1424 : 					if (this->_Color(_Pnode) == this->_Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase

; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1428 : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate

; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase:

; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase

; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

	jmp	$LN12@erase
$LN13@erase:

; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase

; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1438 : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 1439 : 						}
; 1440 : 					else

	jmp	$LN12@erase
$LN11@erase:

; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase

; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1446 : 							this->_Color(_Pnode) = this->_Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1447 : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate

; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase:

; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1454 : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate

; 1455 : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase
$LN12@erase:

; 1456 : 						}
; 1457 : 					}
; 1458 : 				else

	jmp	$LN8@erase
$LN15@erase:

; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1461 : 					if (this->_Color(_Pnode) == this->_Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase

; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1465 : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate

; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase:

; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase

; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==

	jmp	$LN8@erase
$LN6@erase:

; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase

; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1476 : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 1477 : 						}
; 1478 : 					else

	jmp	$LN8@erase
$LN4@erase:

; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase

; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1483 : 							this->_Color(_Pnode) = this->_Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1484 : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate

; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase:

; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1491 : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate

; 1492 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN8@erase:

; 1493 : 						}
; 1494 : 					}

	jmp	$LN17@erase
$LN16@erase:

; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase:

; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
	add	esp, 4
	push	eax
	call	??$addressof@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@YAPAU?$pair@$$CBVCZString@Value@Json@@V23@@0@AAU10@@Z ; std::addressof<std::pair<Json::Value::CZString const ,Json::Value> >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::pair<Json::Value::CZString const ,Json::Value> >

; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);

	push	1
	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate

; 1503 : 
; 1504 : 		if (0 < this->_Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jbe	SHORT $LN1@erase

; 1505 : 			--this->_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN1@erase:

; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1508 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 1291 : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1292 : 		return (this->_Getcomp());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1293 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty, COMDAT
; _this$ = ecx

; 1281 : 		{	// return true only if sequence is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1282 : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	test	eax, eax
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv67[ebp], 0
$LN4@empty:
	mov	al, BYTE PTR tv67[ebp]

; 1283 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1276 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1277 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::max_size

; 1278 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size, COMDAT
; _this$ = ecx

; 1271 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1272 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1273 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end, COMDAT
; _this$ = ecx

; 1226 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1227 : 		return (const_iterator(this->_Myhead, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1228 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end, COMDAT
; _this$ = ecx

; 1221 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1222 : 		return (iterator(this->_Myhead, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1223 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin, COMDAT
; _this$ = ecx

; 1216 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1217 : 		return (const_iterator(_Lmost(), this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1218 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin, COMDAT
; _this$ = ecx

; 1211 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1212 : 		return (iterator(_Lmost(), this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1213 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 1191 : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1192 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy

; 1193 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T2 = -18						; size = 1
$T3 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 1083 : 		{	// construct tree by copying _Right, allocator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1084 : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 1085 : 		_Copy(_Right, false_type());

	xor	edx, edx
	mov	BYTE PTR $T3[ebp], dl
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy<std::integral_constant<bool,0> >
	jmp	SHORT $LN4@Tree
__catch$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z$0:

; 1086 : 		_CATCH_ALL
; 1087 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy

; 1088 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1089 : 		_CATCH_END

	mov	eax, $LN8@Tree
	ret	0
$LN4@Tree:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN2@Tree
$LN8@Tree:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree:

; 1090 : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 1066 : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >

; 1067 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 1006 : 		{	// get ordering predicate

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1007 : 		return (key_compare());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1008 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 1002 : 		{	// construct ordering predicate

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >

; 1003 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_comp@$0A@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_comp<0,std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 1
$T2 = -3						; size = 1
$T3 = -2						; size = 1
$T4 = -1						; size = 1
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Freenode0, COMDAT
; _this$ = ecx

; 912  : 		{	// free non-value node using current allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 913  : 		this->_Getal().destroy(
; 914  : 			_STD addressof(this->_Left(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>

; 915  : 		this->_Getal().destroy(
; 916  : 			_STD addressof(this->_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>

; 917  : 		this->_Getal().destroy(
; 918  : 			_STD addressof(this->_Right(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>

; 919  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate

; 920  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
_TEXT	SEGMENT
tv181 = -56						; size = 4
tv180 = -52						; size = 4
tv179 = -48						; size = 4
tv178 = -44						; size = 4
tv177 = -40						; size = 4
tv176 = -36						; size = 4
__Pnode$ = -32						; size = 4
_this$ = -28						; size = 4
$T2 = -21						; size = 1
$T3 = -20						; size = 1
$T4 = -19						; size = 1
$T5 = -18						; size = 1
$T6 = -17						; size = 1
__$EHRec$ = -16						; size = 16
?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ PROC ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Buynode0, COMDAT
; _this$ = ecx

; 893  : 		{	// allocate a non-value node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 894  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);

	push	1
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 895  : 
; 896  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 897  : 		this->_Getal().construct(
; 898  : 			_STD addressof(this->_Left(_Pnode)), this->_Myhead);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	DWORD PTR tv176[ebp], eax
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	DWORD PTR tv177[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv176[ebp]
	push	ecx
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR tv177[ebp]
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>

; 899  : 		this->_Getal().construct(
; 900  : 			_STD addressof(this->_Parent(_Pnode)), this->_Myhead);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	DWORD PTR tv178[ebp], eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	DWORD PTR tv179[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv178[ebp]
	push	edx
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR tv179[ebp]
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>

; 901  : 		this->_Getal().construct(
; 902  : 			_STD addressof(this->_Right(_Pnode)), this->_Myhead);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	DWORD PTR tv180[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	DWORD PTR tv181[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR tv180[ebp]
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR tv181[ebp]
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
	jmp	SHORT $LN4@Buynode0
__catch$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$0:

; 903  : 		_CATCH_ALL
; 904  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate

; 905  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 906  : 		_CATCH_END

	mov	eax, $LN7@Buynode0
	ret	0
$LN4@Buynode0:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$1
$LN7@Buynode0:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$1:

; 907  : 
; 908  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$LN3@Buynode0:

; 909  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode0@?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ENDP ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Buynode0
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??0?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = ecx

; 889  : 		{	// construct from allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >

; 890  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tree_buy@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::_Tree_buy<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal, COMDAT
; _this$ = ecx

; 868  : 		{	// get allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 870  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 1
$T2 = -3						; size = 1
$T3 = -2						; size = 1
$T4 = -1						; size = 1
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 857  : 		{	// free head node using current allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>

; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>

; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::destroy<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate

; 865  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
_TEXT	SEGMENT
tv150 = -56						; size = 4
tv149 = -52						; size = 4
tv148 = -48						; size = 4
tv147 = -44						; size = 4
tv146 = -40						; size = 4
tv145 = -36						; size = 4
_this$ = -32						; size = 4
__Pnode$ = -28						; size = 4
$T2 = -21						; size = 1
$T3 = -20						; size = 1
$T4 = -19						; size = 1
$T5 = -18						; size = 1
$T6 = -17						; size = 1
__$EHRec$ = -16						; size = 16
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 836  : 		{	// get head node using current allocator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);

	push	1
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 838  : 
; 839  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	DWORD PTR tv145[ebp], eax
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	DWORD PTR tv146[ebp], eax
	lea	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv145[ebp]
	push	ecx
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR tv146[ebp]
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>

; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
	add	esp, 4
	mov	DWORD PTR tv147[ebp], eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	DWORD PTR tv148[ebp], eax
	lea	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv147[ebp]
	push	edx
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR tv148[ebp]
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>

; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	DWORD PTR tv149[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	DWORD PTR tv150[ebp], eax
	lea	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv149[ebp]
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR tv150[ebp]
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::construct<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> *,std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> * &>
	jmp	SHORT $LN4@Buyheadnod
__catch$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$0:

; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate

; 848  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 849  : 		_CATCH_END

	mov	eax, $LN7@Buyheadnod
	ret	0
$LN4@Buyheadnod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$1
$LN7@Buyheadnod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ$1:

; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 852  : 		this->_Isnil(_Pnode) = true;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 853  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$LN3@Buyheadnod:

; 854  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Buyheadnode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >, COMDAT
; _this$ = ecx

; 777  : 		{	// destroy head node

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 778  : 		_Freeheadnode(this->_Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Freeheadnode

; 779  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >, COMDAT
; _this$ = ecx

; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >

; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Buyheadnode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 774  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Min, COMDAT

; 615  : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min:

; 616  : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min

; 617  : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min
$LN1@Min:

; 618  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 619  : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Min
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Max, COMDAT

; 608  : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max:

; 609  : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max

; 610  : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max
$LN1@Max:

; 611  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 612  : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Max
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval, COMDAT

; 603  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 604  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 605  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right, COMDAT

; 598  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 599  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 600  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Right
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent, COMDAT

; 593  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 595  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left, COMDAT

; 588  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 589  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 590  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Left
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil, COMDAT

; 583  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 584  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 585  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color, COMDAT

; 578  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 579  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 580  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = ecx

; 567  : 	_Tree_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 570  : 		this->_Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 571  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >, COMDAT
; _this$ = ecx

; 806  : 		{	// construct by copying base

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >

; 807  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?select_on_container_copy_construction@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBE?AV12@XZ ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::select_on_container_copy_construction
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 107374182				; 06666666H

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBE?AV12@XZ PROC ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@U?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@std@@@std@@QBE?AV12@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<Json::Value::CZString const ,Json::Value>,void *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z PROC ; std::less<Json::Value::CZString>::operator(), COMDAT
; _this$ = ecx

; 192  : 		{	// apply operator< to operands

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 193  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<

; 194  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ENDP ; std::less<Json::Value::CZString>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueIteratorBase@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ValueIteratorBase@Json@@QAE@XZ PROC			; Json::ValueIteratorBase::ValueIteratorBase, COMDAT
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 18   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ValueIteratorBase@Json@@QAE@XZ ENDP			; Json::ValueIteratorBase::ValueIteratorBase
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GValueAllocator@Json@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GValueAllocator@Json@@UAEPAXI@Z PROC			; Json::ValueAllocator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ValueAllocator@Json@@UAE@XZ		; Json::ValueAllocator::~ValueAllocator
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GValueAllocator@Json@@UAEPAXI@Z ENDP			; Json::ValueAllocator::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ValueAllocator@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ValueAllocator@Json@@QAE@XZ PROC			; Json::ValueAllocator::ValueAllocator, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ValueAllocator@Json@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ValueAllocator@Json@@QAE@XZ ENDP			; Json::ValueAllocator::ValueAllocator
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??1ValueAllocator@Json@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ValueAllocator@Json@@UAE@XZ PROC			; Json::ValueAllocator::~ValueAllocator, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ValueAllocator@Json@@6B@

; 57   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1ValueAllocator@Json@@UAE@XZ ENDP			; Json::ValueAllocator::~ValueAllocator
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXPAVPathArgument@Json@@0@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1780 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1781 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXPAVPathArgument@Json@@0@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen, COMDAT
; _this$ = ecx

; 1753 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN2@Xlen:

; 1755 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1623 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::deallocate

; 1629 : 			this->_Myfirst = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1630 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1631 : 			this->_Myend = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN2@Tidy:

; 1632 : 			}
; 1633 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1613 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1616 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
$LN1@Reserve:

; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEII@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reallocate
$LN4@Reserve:

; 1618 : 			}
; 1619 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -32						; size = 4
__Ptr$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1589 : 
; 1590 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z$0:

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::deallocate

; 1594 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1595 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z$1:

; 1596 : 
; 1597 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1598 : 		if (this->_Myfirst != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Reallocate

; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 5
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::deallocate
$LN1@Reallocate:

; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1606 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1607 : 		this->_Mylast = _Ptr + _Size;

	mov	edx, DWORD PTR __Size$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1608 : 		this->_Myfirst = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], edx
$LN4@Reallocate:

; 1609 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reallocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBE_NPBVPathArgument@Json@@@Z
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBE_NPBVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1584 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBE_NPBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Capacity$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEII@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1572 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1576 : 		if (_Capacity < _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1577 : 			_Capacity = _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx
$LN1@Grow_to:

; 1578 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1579 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEII@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy, COMDAT
; _this$ = ecx

; 1565 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1566 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal

; 1567 : 		_Destroy_range(_First, _Last, _Alval);

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAXPAVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument> > >
	add	esp, 12					; 0000000cH

; 1568 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Idx$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1244 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@$$CBVPathArgument@Json@@@std@@YAPBVPathArgument@Json@@ABV12@@Z ; std::addressof<Json::PathArgument const >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBE_NPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@push_back

; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$addressof@$$CBVPathArgument@Json@@@std@@YAPBVPathArgument@Json@@ABV12@@Z ; std::addressof<Json::PathArgument const >
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 5
	mov	DWORD PTR __Idx$1[ebp], eax

; 1247 : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Orphan_range

; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR __Idx$1[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
	mov	ecx, eax
	call	??$construct@VPathArgument@Json@@AAV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@AAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument &>

; 1252 : 			++this->_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1253 : 			}
; 1254 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reserve
$LN1@push_back:

; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Orphan_range

; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
	mov	ecx, eax
	call	??$construct@VPathArgument@Json@@ABV12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@ABV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument const &>

; 1261 : 			++this->_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN5@push_back:

; 1262 : 			}
; 1263 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size, COMDAT
; _this$ = ecx

; 1152 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1153 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::max_size

; 1154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size, COMDAT
; _this$ = ecx

; 1147 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 5

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1041 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1031 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1014 : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 5

; 1016 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity, COMDAT
; _this$ = ecx

; 1009 : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 5

; 1011 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy

; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEX$$QAVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Idx$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEX$$QAVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back, COMDAT
; _this$ = ecx

; 865  : 		{	// insert by moving into element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 866  : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAV12@@Z ; std::addressof<Json::PathArgument>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBE_NPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@push_back

; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$addressof@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAV12@@Z ; std::addressof<Json::PathArgument>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 5
	mov	DWORD PTR __Idx$1[ebp], eax

; 869  : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@push_back

; 870  : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reserve
$LN3@push_back:

; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Orphan_range

; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

	mov	eax, DWORD PTR __Idx$1[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	call	??$forward@VPathArgument@Json@@@std@@YA$$QAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
	mov	ecx, eax
	call	??$construct@VPathArgument@Json@@V12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>

; 874  : 			++this->_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 875  : 			}
; 876  : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN1@push_back

; 879  : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Reserve
$LN1@push_back:

; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Orphan_range

; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@VPathArgument@Json@@@std@@YA$$QAVPathArgument@Json@@AAV12@@Z ; std::forward<Json::PathArgument>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
	mov	ecx, eax
	call	??$construct@VPathArgument@Json@@V12@@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@$$QAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::construct<Json::PathArgument,Json::PathArgument>

; 883  : 			++this->_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN5@push_back:

; 884  : 			}
; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEX$$QAVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 680  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >

; 681  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::_Wrap_alloc<std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >, COMDAT
; _this$ = ecx

; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Json::PathArgument> >::_Vector_val<std::_Simple_types<Json::PathArgument> >

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument,std::allocator<Json::PathArgument> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Json::PathArgument> >::_Vector_val<std::_Simple_types<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 480  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 483  : 		_Mylast = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 485  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Json::PathArgument> >::_Vector_val<std::_Simple_types<Json::PathArgument> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAIABV?$allocator@VPathArgument@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::PathArgument> >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXPAVPathArgument@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEPAVPathArgument@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEPAVPathArgument@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::_Wrap_alloc<std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument> >::_Wrap_alloc<std::allocator<Json::PathArgument> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAIABV?$allocator@VPathArgument@Json@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAIABV?$allocator@VPathArgument@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::PathArgument> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument>::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@VPathArgument@Json@@@std@@@std@@SAIABV?$allocator@VPathArgument@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::PathArgument> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::PathArgument>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 134217727				; 07ffffffH

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::PathArgument>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv74 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z PROC ; std::allocator<Json::PathArgument>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0PathArgument@Json@@QAE@ABV01@@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 594  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ENDP ; std::allocator<Json::PathArgument>::construct
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ; std::_Allocate<Json::PathArgument>
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ PROC	; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ ENDP	; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_path$ = 8						; size = 4
_location$ = 12						; size = 4
?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; Json::Path::invalidPath, COMDAT
; _this$ = ecx

; 1626 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1627 :    // Error: invalid path.
; 1628 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; Json::Path::invalidPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@4@W4Kind@PathArgument@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_path$ = 8						; size = 4
_in$ = 12						; size = 4
_itInArg$ = 16						; size = 4
_kind$ = 20						; size = 4
?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@4@W4Kind@PathArgument@2@@Z PROC ; Json::Path::addPathInArg, COMDAT
; _this$ = ecx

; 1607 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1608 :    if ( itInArg == in.end() )

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
	push	eax
	mov	ecx, DWORD PTR _itInArg$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@addPathInA
	jmp	SHORT $LN5@addPathInA
$LN4@addPathInA:

; 1609 :    {
; 1610 :       // Error: missing argument %d
; 1611 :    }
; 1612 :    else if ( (*itInArg)->kind_ != kind )

	mov	ecx, DWORD PTR _itInArg$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::operator*
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR _kind$[ebp]
	je	SHORT $LN2@addPathInA

; 1613 :    {
; 1614 :       // Error: bad argument type
; 1615 :    }
; 1616 :    else

	jmp	SHORT $LN5@addPathInA
$LN2@addPathInA:

; 1617 :    {
; 1618 :       args_.push_back( **itInArg );

	mov	ecx, DWORD PTR _itInArg$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::operator*
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
$LN5@addPathInA:

; 1619 :    }
; 1620 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@4@W4Kind@PathArgument@2@@Z ENDP ; Json::Path::addPathInArg
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXPAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXPAPBVPathArgument@Json@@0@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1780 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1781 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXPAPBVPathArgument@Json@@0@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen, COMDAT
; _this$ = ecx

; 1753 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN2@Xlen:

; 1755 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1623 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy

; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::deallocate

; 1629 : 			this->_Myfirst = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1630 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1631 : 			this->_Myend = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN2@Tidy:

; 1632 : 			}
; 1633 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1613 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1616 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
$LN1@Reserve:

; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEII@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Reallocate
$LN4@Reserve:

; 1618 : 			}
; 1619 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -32						; size = 4
__Ptr$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEPAPBVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1589 : 
; 1590 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z$0:

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::deallocate

; 1594 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1595 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z$1:

; 1596 : 
; 1597 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1598 : 		if (this->_Myfirst != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Reallocate

; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy

; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::deallocate
$LN1@Reallocate:

; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1606 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1607 : 		this->_Mylast = _Ptr + _Size;

	mov	ecx, DWORD PTR __Size$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1608 : 		this->_Myfirst = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx], eax
$LN4@Reallocate:

; 1609 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Reallocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBE_NPBQBVPathArgument@Json@@@Z
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBE_NPBQBVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1584 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBE_NPBQBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Capacity$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEII@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1572 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1576 : 		if (_Capacity < _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1577 : 			_Capacity = _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx
$LN1@Grow_to:

; 1578 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1579 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEII@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy, COMDAT
; _this$ = ecx

; 1565 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1566 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal

; 1567 : 		_Destroy_range(_First, _Last, _Alval);

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::PathArgument const *> > >
	add	esp, 12					; 0000000cH

; 1568 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size, COMDAT
; _this$ = ecx

; 1152 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1153 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::max_size

; 1154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size, COMDAT
; _this$ = ecx

; 1147 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1041 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument const *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1031 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1014 : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1016 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity, COMDAT
; _this$ = ecx

; 1009 : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1011 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy

; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEX$$QAPBVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Idx$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEX$$QAPBVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back, COMDAT
; _this$ = ecx

; 865  : 		{	// insert by moving into element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 866  : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPBV12@@Z ; std::addressof<Json::PathArgument const *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBE_NPBQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@push_back

; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$addressof@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPBV12@@Z ; std::addressof<Json::PathArgument const *>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	mov	DWORD PTR __Idx$1[ebp], eax

; 869  : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@push_back

; 870  : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Reserve
$LN3@push_back:

; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Orphan_range

; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Idx$1[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$forward@PBVPathArgument@Json@@@std@@YA$$QAPBVPathArgument@Json@@AAPBV12@@Z ; std::forward<Json::PathArgument const *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PBVPathArgument@Json@@PBV12@@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::construct<Json::PathArgument const *,Json::PathArgument const *>

; 874  : 			++this->_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 875  : 			}
; 876  : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN1@push_back

; 879  : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXI@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Reserve
$LN1@push_back:

; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Orphan_range

; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@PBVPathArgument@Json@@@std@@YA$$QAPBVPathArgument@Json@@AAPBV12@@Z ; std::forward<Json::PathArgument const *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PBVPathArgument@Json@@PBV12@@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@$$QAPBV23@@Z ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::construct<Json::PathArgument const *,Json::PathArgument const *>

; 883  : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN5@push_back:

; 884  : 			}
; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEX$$QAPBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = ecx

; 680  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PBVPathArgument@Json@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >

; 681  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::_Wrap_alloc<std::allocator<Json::PathArgument const *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PBVPathArgument@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PBVPathArgument@Json@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >, COMDAT
; _this$ = ecx

; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Json::PathArgument const *> >::_Vector_val<std::_Simple_types<Json::PathArgument const *> >

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PBVPathArgument@Json@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >::_Vector_alloc<0,std::_Vec_base_types<Json::PathArgument const *,std::allocator<Json::PathArgument const *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Json::PathArgument const *> >::_Vector_val<std::_Simple_types<Json::PathArgument const *> >, COMDAT
; _this$ = ecx

; 480  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 483  : 		_Mylast = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 485  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Json::PathArgument const *> >::_Vector_val<std::_Simple_types<Json::PathArgument const *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAIABV?$allocator@PBVPathArgument@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::PathArgument const *> >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEPAPBVPathArgument@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEPAPBVPathArgument@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::_Wrap_alloc<std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::PathArgument const *> >::_Wrap_alloc<std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAIABV?$allocator@PBVPathArgument@Json@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAIABV?$allocator@PBVPathArgument@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::PathArgument const *> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument const *>::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@PBVPathArgument@Json@@@std@@@std@@SAIABV?$allocator@PBVPathArgument@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::PathArgument const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::PathArgument const *>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::PathArgument const *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument const *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z ; std::_Allocate<Json::PathArgument const *>
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument const *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument const *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument const *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ PROC	; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ ENDP	; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
_TEXT	SEGMENT
tv175 = -140						; size = 4
_beginName$2 = -136					; size = 4
tv95 = -132						; size = 4
tv135 = -128						; size = 4
_itInArg$ = -124					; size = 4
_index$3 = -120						; size = 4
_end$ = -116						; size = 4
_this$ = -112						; size = 4
_current$ = -108					; size = 4
$T4 = -104						; size = 24
$T5 = -80						; size = 32
$T6 = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
_in$ = 12						; size = 4
?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z PROC ; Json::Path::makePath, COMDAT
; _this$ = ecx

; 1561 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1562 :    const char *current = path.c_str();

	mov	ecx, DWORD PTR _path$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	DWORD PTR _current$[ebp], eax

; 1563 :    const char *end = current + path.length();

	mov	ecx, DWORD PTR _path$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	add	eax, DWORD PTR _current$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 1564 :    InArgs::const_iterator itInArg = in.begin();

	lea	eax, DWORD PTR _itInArg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
$LN17@makePath:

; 1565 :    while ( current != end )

	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	$LN18@makePath

; 1566 :    {
; 1567 :       if ( *current == '[' )

	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 91					; 0000005bH
	jne	$LN15@makePath

; 1568 :       {
; 1569 :          ++current;

	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx

; 1570 :          if ( *current == '%' )

	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN14@makePath

; 1571 :             addPathInArg( path, in, itInArg, PathArgument::kindIndex );

	push	1
	lea	ecx, DWORD PTR _itInArg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@4@W4Kind@PathArgument@2@@Z ; Json::Path::addPathInArg

; 1572 :          else

	jmp	SHORT $LN13@makePath
$LN14@makePath:

; 1573 :          {
; 1574 :             Value::UInt index = 0;

	mov	DWORD PTR _index$3[ebp], 0

; 1575 :             for ( ; current != end && *current >= '0'  &&  *current <= '9'; ++current )

	jmp	SHORT $LN12@makePath
$LN11@makePath:
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx
$LN12@makePath:
	mov	edx, DWORD PTR _current$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	je	SHORT $LN10@makePath
	mov	eax, DWORD PTR _current$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN10@makePath
	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN10@makePath

; 1576 :                index = index * 10 + Value::UInt(*current - '0');

	imul	ecx, DWORD PTR _index$3[ebp], 10
	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	DWORD PTR _index$3[ebp], ecx
	jmp	SHORT $LN11@makePath
$LN10@makePath:

; 1577 :             args_.push_back( index );

	mov	edx, DWORD PTR _index$3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0PathArgument@Json@@QAE@I@Z		; Json::PathArgument::PathArgument
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEX$$QAVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1PathArgument@Json@@QAE@XZ
$LN13@makePath:

; 1578 :          }
; 1579 :          if ( current == end  ||  *current++ != ']' )

	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	SHORT $LN8@makePath
	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx
	cmp	DWORD PTR tv135[ebp], 93		; 0000005dH
	je	SHORT $LN9@makePath
$LN8@makePath:

; 1580 :             invalidPath( path, int(current - path.c_str()) );

	mov	ecx, DWORD PTR _path$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	edx, DWORD PTR _current$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::Path::invalidPath
$LN9@makePath:

; 1581 :       }

	jmp	$LN7@makePath
$LN15@makePath:

; 1582 :       else if ( *current == '%' )

	mov	ecx, DWORD PTR _current$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	SHORT $LN6@makePath

; 1583 :       {
; 1584 :          addPathInArg( path, in, itInArg, PathArgument::kindKey );

	push	2
	lea	eax, DWORD PTR _itInArg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PBVPathArgument@Json@@@std@@@std@@@4@W4Kind@PathArgument@2@@Z ; Json::Path::addPathInArg

; 1585 :          ++current;

	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 1
	mov	DWORD PTR _current$[ebp], eax
	jmp	$LN7@makePath
$LN6@makePath:

; 1586 :       }
; 1587 :       else if ( *current == '.' )

	mov	ecx, DWORD PTR _current$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN4@makePath

; 1588 :       {
; 1589 :          ++current;

	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 1
	mov	DWORD PTR _current$[ebp], eax

; 1590 :       }
; 1591 :       else

	jmp	$LN7@makePath
$LN4@makePath:

; 1592 :       {
; 1593 :          const char *beginName = current;

	mov	ecx, DWORD PTR _current$[ebp]
	mov	DWORD PTR _beginName$2[ebp], ecx
$LN2@makePath:

; 1594 :          while ( current != end  &&  !strchr( "[.", *current ) )

	mov	edx, DWORD PTR _current$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	je	SHORT $LN1@makePath
	mov	eax, DWORD PTR _current$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_02GLFAOOJA@?$FL?4?$AA@
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@makePath

; 1595 :             ++current;

	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx
	jmp	SHORT $LN2@makePath
$LN1@makePath:

; 1596 :          args_.push_back( std::string( beginName, current ) );

	mov	eax, DWORD PTR _current$[ebp]
	push	eax
	mov	ecx, DWORD PTR _beginName$2[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv95[ebp], eax
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv175[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv175[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::PathArgument::PathArgument
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEX$$QAVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1PathArgument@Json@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN7@makePath:

; 1597 :       }
; 1598 :    }

	jmp	$LN17@makePath
$LN18@makePath:

; 1599 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$0:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1PathArgument@Json@@QAE@XZ
__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$1:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$2:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1PathArgument@Json@@QAE@XZ
__ehhandler$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z ENDP ; Json::Path::makePath
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?make@Path@Json@@QBEAAVValue@2@AAV32@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
_this$ = -16						; size = 4
_it$2 = -12						; size = 4
_arg$3 = -8						; size = 4
_node$ = -4						; size = 4
_root$ = 8						; size = 4
?make@Path@Json@@QBEAAVValue@2@AAV32@@Z PROC		; Json::Path::make, COMDAT
; _this$ = ecx

; 1692 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1693 :    Value *node = &root;

	mov	eax, DWORD PTR _root$[ebp]
	mov	DWORD PTR _node$[ebp], eax

; 1694 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	lea	ecx, DWORD PTR _it$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	jmp	SHORT $LN8@make
$LN7@make:
	lea	ecx, DWORD PTR _it$2[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator++
$LN8@make:
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
	push	eax
	lea	ecx, DWORD PTR _it$2[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@make

; 1695 :    {
; 1696 :       const PathArgument &arg = *it;

	lea	ecx, DWORD PTR _it$2[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEABVPathArgument@Json@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator*
	mov	DWORD PTR _arg$3[ebp], eax

; 1697 :       if ( arg.kind_ == PathArgument::kindIndex )

	mov	ecx, DWORD PTR _arg$3[ebp]
	cmp	DWORD PTR [ecx+28], 1
	jne	SHORT $LN5@make

; 1698 :       {
; 1699 :          if ( !node->isArray() )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray

; 1700 :          {
; 1701 :             // Error: node is not an array at position ...
; 1702 :          }
; 1703 :          node = &((*node)[arg.index_]);

	mov	eax, DWORD PTR _arg$3[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
	jmp	SHORT $LN3@make
$LN5@make:

; 1704 :       }
; 1705 :       else if ( arg.kind_ == PathArgument::kindKey )

	mov	edx, DWORD PTR _arg$3[ebp]
	cmp	DWORD PTR [edx+28], 2
	jne	SHORT $LN3@make

; 1706 :       {
; 1707 :          if ( !node->isObject() )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject

; 1708 :          {
; 1709 :             // Error: node is not an object at position...
; 1710 :          }
; 1711 :          node = &((*node)[arg.key_]);

	mov	ecx, DWORD PTR _arg$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
$LN3@make:

; 1712 :       }
; 1713 :    }

	jmp	SHORT $LN7@make
$LN6@make:

; 1714 :    return *node;

	mov	eax, DWORD PTR _node$[ebp]

; 1715 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?make@Path@Json@@QBEAAVValue@2@AAV32@@Z ENDP		; Json::Path::make
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
_this$ = -20						; size = 4
_it$2 = -16						; size = 4
_arg$3 = -12						; size = 4
$T4 = -8						; size = 4
_node$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z PROC	; Json::Path::resolve, COMDAT
; _this$ = ecx

; 1666 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T4[ebp], 0

; 1667 :    const Value *node = &root;

	mov	eax, DWORD PTR _root$[ebp]
	mov	DWORD PTR _node$[ebp], eax

; 1668 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	lea	ecx, DWORD PTR _it$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	jmp	SHORT $LN10@resolve
$LN9@resolve:
	lea	ecx, DWORD PTR _it$2[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator++
$LN10@resolve:
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
	push	eax
	lea	ecx, DWORD PTR _it$2[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN8@resolve

; 1669 :    {
; 1670 :       const PathArgument &arg = *it;

	lea	ecx, DWORD PTR _it$2[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEABVPathArgument@Json@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator*
	mov	DWORD PTR _arg$3[ebp], eax

; 1671 :       if ( arg.kind_ == PathArgument::kindIndex )

	mov	ecx, DWORD PTR _arg$3[ebp]
	cmp	DWORD PTR [ecx+28], 1
	jne	SHORT $LN7@resolve

; 1672 :       {
; 1673 :          if ( !node->isArray()  ||  node->isValidIndex( arg.index_ ) )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@resolve
	mov	eax, DWORD PTR _arg$3[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	?isValidIndex@Value@Json@@QBE_NI@Z	; Json::Value::isValidIndex
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@resolve
$LN5@resolve:

; 1674 :             return defaultValue;

	mov	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T4[ebp]
	or	ecx, 1
	mov	DWORD PTR $T4[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@resolve
$LN6@resolve:

; 1675 :          node = &((*node)[arg.index_]);

	mov	edx, DWORD PTR _arg$3[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
	jmp	SHORT $LN4@resolve
$LN7@resolve:

; 1676 :       }
; 1677 :       else if ( arg.kind_ == PathArgument::kindKey )

	mov	ecx, DWORD PTR _arg$3[ebp]
	cmp	DWORD PTR [ecx+28], 2
	jne	SHORT $LN4@resolve

; 1678 :       {
; 1679 :          if ( !node->isObject() )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@resolve

; 1680 :             return defaultValue;

	mov	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T4[ebp]
	or	ecx, 1
	mov	DWORD PTR $T4[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@resolve
$LN2@resolve:

; 1681 :          node = &((*node)[arg.key_]);

	mov	edx, DWORD PTR _arg$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax

; 1682 :          if ( node == &Value::null )

	cmp	DWORD PTR _node$[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	jne	SHORT $LN4@resolve

; 1683 :             return defaultValue;

	mov	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T4[ebp]
	or	ecx, 1
	mov	DWORD PTR $T4[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@resolve
$LN4@resolve:

; 1684 :       }
; 1685 :    }

	jmp	$LN9@resolve
$LN8@resolve:

; 1686 :    return *node;

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	eax, DWORD PTR $T4[ebp]
	or	eax, 1
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@resolve:

; 1687 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z ENDP	; Json::Path::resolve
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
_this$ = -16						; size = 4
_it$2 = -12						; size = 4
_arg$3 = -8						; size = 4
_node$ = -4						; size = 4
_root$ = 8						; size = 4
?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z PROC		; Json::Path::resolve, COMDAT
; _this$ = ecx

; 1633 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1634 :    const Value *node = &root;

	mov	eax, DWORD PTR _root$[ebp]
	mov	DWORD PTR _node$[ebp], eax

; 1635 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	lea	ecx, DWORD PTR _it$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	jmp	SHORT $LN10@resolve
$LN9@resolve:
	lea	ecx, DWORD PTR _it$2[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator++
$LN10@resolve:
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
	push	eax
	lea	ecx, DWORD PTR _it$2[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@resolve

; 1636 :    {
; 1637 :       const PathArgument &arg = *it;

	lea	ecx, DWORD PTR _it$2[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPathArgument@Json@@@std@@@std@@@std@@QBEABVPathArgument@Json@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Json::PathArgument> > >::operator*
	mov	DWORD PTR _arg$3[ebp], eax

; 1638 :       if ( arg.kind_ == PathArgument::kindIndex )

	mov	ecx, DWORD PTR _arg$3[ebp]
	cmp	DWORD PTR [ecx+28], 1
	jne	SHORT $LN7@resolve

; 1639 :       {
; 1640 :          if ( !node->isArray()  ||  node->isValidIndex( arg.index_ ) )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@resolve
	mov	eax, DWORD PTR _arg$3[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	?isValidIndex@Value@Json@@QBE_NI@Z	; Json::Value::isValidIndex
$LN6@resolve:

; 1641 :          {
; 1642 :             // Error: unable to resolve path (array value expected at position...
; 1643 :          }
; 1644 :          node = &((*node)[arg.index_]);

	mov	eax, DWORD PTR _arg$3[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
	jmp	SHORT $LN4@resolve
$LN7@resolve:

; 1645 :       }
; 1646 :       else if ( arg.kind_ == PathArgument::kindKey )

	mov	edx, DWORD PTR _arg$3[ebp]
	cmp	DWORD PTR [edx+28], 2
	jne	SHORT $LN4@resolve

; 1647 :       {
; 1648 :          if ( !node->isObject() )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject

; 1649 :          {
; 1650 :             // Error: unable to resolve path (object value expected at position...)
; 1651 :          }
; 1652 :          node = &((*node)[arg.key_]);

	mov	ecx, DWORD PTR _arg$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
$LN4@resolve:

; 1653 :          if ( node == &Value::null )
; 1654 :          {
; 1655 :             // Error: unable to resolve path (object has no member named '' at position...)
; 1656 :          }
; 1657 :       }
; 1658 :    }

	jmp	$LN9@resolve
$LN8@resolve:

; 1659 :    return *node;

	mov	eax, DWORD PTR _node$[ebp]

; 1660 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z ENDP		; Json::Path::resolve
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
_TEXT	SEGMENT
_in$ = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
_a1$ = 12						; size = 4
_a2$ = 16						; size = 4
_a3$ = 20						; size = 4
_a4$ = 24						; size = 4
_a5$ = 28						; size = 4
??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z PROC ; Json::Path::Path, COMDAT
; _this$ = ecx

; 1547 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1548 :    InArgs in;

	lea	ecx, DWORD PTR _in$[ebp]
	call	??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1549 :    in.push_back( &a1 );

	lea	eax, DWORD PTR _a1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEX$$QAPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1550 :    in.push_back( &a2 );

	lea	ecx, DWORD PTR _a2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEX$$QAPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1551 :    in.push_back( &a3 );

	lea	edx, DWORD PTR _a3$[ebp]
	push	edx
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEX$$QAPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1552 :    in.push_back( &a4 );

	lea	eax, DWORD PTR _a4$[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEX$$QAPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1553 :    in.push_back( &a5 );

	lea	ecx, DWORD PTR _a5$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEX$$QAPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1554 :    makePath( path, in );

	lea	edx, DWORD PTR _in$[ebp]
	push	edx
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z ; Json::Path::makePath

; 1555 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _in$[ebp]
	call	??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
__unwindfunclet$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z$1:
	lea	ecx, DWORD PTR _in$[ebp]
	jmp	??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
__ehhandler$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z ENDP ; Json::Path::Path
; Function compile flags: /Odtp
;	COMDAT ??_GPathArgument@Json@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GPathArgument@Json@@QAEPAXI@Z PROC			; Json::PathArgument::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1PathArgument@Json@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GPathArgument@Json@@QAEPAXI@Z ENDP			; Json::PathArgument::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0PathArgument@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0PathArgument@Json@@QAE@ABV01@@Z PROC			; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0PathArgument@Json@@QAE@ABV01@@Z ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1PathArgument@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PathArgument@Json@@QAE@XZ PROC			; Json::PathArgument::~PathArgument, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1PathArgument@Json@@QAE@XZ ENDP			; Json::PathArgument::~PathArgument
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx

; 1535 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _key$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 2

; 1536 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::PathArgument::PathArgument
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0PathArgument@Json@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??0PathArgument@Json@@QAE@PBD@Z PROC			; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx

; 1528 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 2

; 1529 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0PathArgument@Json@@QAE@PBD@Z ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0PathArgument@Json@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??0PathArgument@Json@@QAE@I@Z PROC			; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx

; 1521 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 1

; 1522 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0PathArgument@Json@@QAE@I@Z ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0PathArgument@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PathArgument@Json@@QAE@XZ PROC			; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx

; 1514 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1515 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PathArgument@Json@@QAE@XZ ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_ECommentInfo@Value@Json@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ECommentInfo@Value@Json@@QAEPAXI@Z PROC		; Json::Value::CommentInfo::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CommentInfo@Value@Json@@QAE@XZ	; Json::Value::CommentInfo::~CommentInfo
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ECommentInfo@Value@Json@@QAEPAXI@Z ENDP		; Json::Value::CommentInfo::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?setComment@CommentInfo@Value@Json@@QAEXPBD@Z
_TEXT	SEGMENT
$T1 = -24						; size = 12
tv90 = -12						; size = 4
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_text$ = 8						; size = 4
?setComment@CommentInfo@Value@Json@@QAEXPBD@Z PROC	; Json::Value::CommentInfo::setComment, COMDAT
; _this$ = ecx

; 152  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 153  :    if ( comment_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@setComment

; 154  :       valueAllocator()->releaseStringValue( comment_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv69[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv69[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv69[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@setComment:

; 155  :    JSON_ASSERT( text );
; 156  :    JSON_ASSERT_MESSAGE( text[0]=='\0' || text[0]=='/', "Comments must start with /");

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN1@setComment
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN1@setComment
	push	OFFSET ??_C@_0BL@DKGNIMPN@Comments?5must?5start?5with?5?1?$AA@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN1@setComment:

; 157  :    // It seems that /**/ style comments are acceptable as well.
; 158  :    comment_ = valueAllocator()->duplicateStringValue( text );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv90[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	mov	eax, DWORD PTR tv90[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv90[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN4@setComment:

; 159  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setComment@CommentInfo@Value@Json@@QAEXPBD@Z ENDP	; Json::Value::CommentInfo::setComment
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??1CommentInfo@Value@Json@@QAE@XZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
??1CommentInfo@Value@Json@@QAE@XZ PROC			; Json::Value::CommentInfo::~CommentInfo, COMDAT
; _this$ = ecx

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 145  :    if ( comment_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@CommentInf

; 146  :       valueAllocator()->releaseStringValue( comment_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv69[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv69[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv69[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@CommentInf:

; 147  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CommentInfo@Value@Json@@QAE@XZ ENDP			; Json::Value::CommentInfo::~CommentInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0CommentInfo@Value@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CommentInfo@Value@Json@@QAE@XZ PROC			; Json::Value::CommentInfo::CommentInfo, COMDAT
; _this$ = ecx

; 140  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 141  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CommentInfo@Value@Json@@QAE@XZ ENDP			; Json::Value::CommentInfo::CommentInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
_TEXT	SEGMENT
_defaultValue$ = -104					; size = 24
$T2 = -80						; size = 16
_actualKey$ = -64					; size = 8
$T3 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
_value$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
tv182 = -32						; size = 4
tv188 = -28						; size = 4
tv79 = -24						; size = 4
_this$ = -20						; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_key$ = 8						; size = 4
_isStatic$ = 12						; size = 1
?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z PROC	; Json::Value::resolveReference, COMDAT
; _this$ = ecx

; 1024 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1025 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1026 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	jne	SHORT $LN2@resolveRef

; 1027 :       *this = Value( objectValue );

	push	7
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv188[ebp], eax
	mov	edx, DWORD PTR tv188[ebp]
	mov	DWORD PTR tv182[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv182[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN2@resolveRef:

; 1028 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1029 :    CZString actualKey( key, isStatic ? CZString::noDuplication 
; 1030 :                                      : CZString::duplicateOnCopy );

	movzx	ecx, BYTE PTR _isStatic$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@resolveRef
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN6@resolveRef
$LN5@resolveRef:
	mov	DWORD PTR tv79[ebp], 2
$LN6@resolveRef:
	mov	edx, DWORD PTR tv79[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1031 :    ObjectValues::iterator it = value_.map_->lower_bound( actualKey );

	lea	ecx, DWORD PTR _actualKey$[ebp]
	push	ecx
	lea	edx, DWORD PTR _it$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound

; 1032 :    if ( it != value_.map_->end()  &&  (*it).first == actualKey )

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@resolveRef
	lea	ecx, DWORD PTR _actualKey$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _it$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	mov	ecx, eax
	call	??8CZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@resolveRef

; 1033 :       return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	add	eax, 8
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T7[ebp]
	jmp	SHORT $LN3@resolveRef
$LN1@resolveRef:

; 1034 : 
; 1035 :    ObjectValues::value_type defaultValue( actualKey, null );

	push	OFFSET ?null@Value@Json@@2V12@B		; Json::Value::null
	lea	eax, DWORD PTR _actualKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	call	??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value><Json::Value::CZString &,Json::Value const &,void>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1036 :    it = value_.map_->insert( it, defaultValue );

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	lea	edx, DWORD PTR _defaultValue$[ebp]
	push	edx
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	??$insert@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert<std::pair<Json::Value::CZString const ,Json::Value> &>
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _it$[ebp], eax

; 1037 :    Value &value = (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	add	eax, 8
	mov	DWORD PTR _value$[ebp], eax

; 1038 :    return value;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T5[ebp]
$LN3@resolveRef:

; 1039 : #else
; 1040 :    return value_.map_->resolveReference( key, isStatic );
; 1041 : #endif
; 1042 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$1:
	lea	ecx, DWORD PTR _actualKey$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$2:
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	jmp	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
__ehhandler$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ENDP	; Json::Value::resolveReference
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?end@Value@Json@@QAE?AVValueIterator@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@Value@Json@@QAE?AVValueIterator@2@XZ PROC		; Json::Value::end, COMDAT
; _this$ = ecx

; 1475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1476 :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN4@end
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@end
	jmp	SHORT $LN4@end
$LN3@end:

; 1477 :    {
; 1478 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1479 :    case arrayValue:
; 1480 :       if ( value_.array_ )
; 1481 :       {
; 1482 :          ValueInternalArray::IteratorState it;
; 1483 :          value_.array_->makeEndIterator( it );
; 1484 :          return iterator( it );
; 1485 :       }
; 1486 :       break;
; 1487 :    case objectValue:
; 1488 :       if ( value_.map_ )
; 1489 :       {
; 1490 :          ValueInternalMap::IteratorState it;
; 1491 :          value_.map_->makeEndIterator( it );
; 1492 :          return iterator( it );
; 1493 :       }
; 1494 :       break;
; 1495 : #else
; 1496 :    case arrayValue:
; 1497 :    case objectValue:
; 1498 :       if ( value_.map_ )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@end

; 1499 :          return iterator( value_.map_->end() );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN6@end
$LN4@end:

; 1500 :       break;
; 1501 : #endif
; 1502 :    default:
; 1503 :       break;
; 1504 :    }
; 1505 :    return iterator();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@QAE@XZ		; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN6@end:

; 1506 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?end@Value@Json@@QAE?AVValueIterator@2@XZ ENDP		; Json::Value::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?begin@Value@Json@@QAE?AVValueIterator@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@Value@Json@@QAE?AVValueIterator@2@XZ PROC	; Json::Value::begin, COMDAT
; _this$ = ecx

; 1440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1441 :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN4@begin
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@begin
	jmp	SHORT $LN4@begin
$LN3@begin:

; 1442 :    {
; 1443 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1444 :    case arrayValue:
; 1445 :       if ( value_.array_ )
; 1446 :       {
; 1447 :          ValueInternalArray::IteratorState it;
; 1448 :          value_.array_->makeBeginIterator( it );
; 1449 :          return iterator( it );
; 1450 :       }
; 1451 :       break;
; 1452 :    case objectValue:
; 1453 :       if ( value_.map_ )
; 1454 :       {
; 1455 :          ValueInternalMap::IteratorState it;
; 1456 :          value_.map_->makeBeginIterator( it );
; 1457 :          return iterator( it );
; 1458 :       }
; 1459 :       break;
; 1460 : #else
; 1461 :    case arrayValue:
; 1462 :    case objectValue:
; 1463 :       if ( value_.map_ )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@begin

; 1464 :          return iterator( value_.map_->begin() );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN6@begin
$LN4@begin:

; 1465 :       break;
; 1466 : #endif
; 1467 :    default:
; 1468 :       break;
; 1469 :    }
; 1470 :    return iterator();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@QAE@XZ		; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN6@begin:

; 1471 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@Value@Json@@QAE?AVValueIterator@2@XZ ENDP	; Json::Value::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?end@Value@Json@@QBE?AVValueConstIterator@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@Value@Json@@QBE?AVValueConstIterator@2@XZ PROC	; Json::Value::end, COMDAT
; _this$ = ecx

; 1404 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1405 :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN4@end
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@end
	jmp	SHORT $LN4@end
$LN3@end:

; 1406 :    {
; 1407 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1408 :    case arrayValue:
; 1409 :       if ( value_.array_ )
; 1410 :       {
; 1411 :          ValueInternalArray::IteratorState it;
; 1412 :          value_.array_->makeEndIterator( it );
; 1413 :          return const_iterator( it );
; 1414 :       }
; 1415 :       break;
; 1416 :    case objectValue:
; 1417 :       if ( value_.map_ )
; 1418 :       {
; 1419 :          ValueInternalMap::IteratorState it;
; 1420 :          value_.map_->makeEndIterator( it );
; 1421 :          return const_iterator( it );
; 1422 :       }
; 1423 :       break;
; 1424 : #else
; 1425 :    case arrayValue:
; 1426 :    case objectValue:
; 1427 :       if ( value_.map_ )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@end

; 1428 :          return const_iterator( value_.map_->end() );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueConstIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ; Json::ValueConstIterator::ValueConstIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN6@end
$LN4@end:

; 1429 :       break;
; 1430 : #endif
; 1431 :    default:
; 1432 :       break;
; 1433 :    }
; 1434 :    return const_iterator();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueConstIterator@Json@@QAE@XZ	; Json::ValueConstIterator::ValueConstIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN6@end:

; 1435 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?end@Value@Json@@QBE?AVValueConstIterator@2@XZ ENDP	; Json::Value::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ PROC	; Json::Value::begin, COMDAT
; _this$ = ecx

; 1369 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1370 :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN4@begin
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@begin
	jmp	SHORT $LN4@begin
$LN3@begin:

; 1371 :    {
; 1372 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1373 :    case arrayValue:
; 1374 :       if ( value_.array_ )
; 1375 :       {
; 1376 :          ValueInternalArray::IteratorState it;
; 1377 :          value_.array_->makeBeginIterator( it );
; 1378 :          return const_iterator( it );
; 1379 :       }
; 1380 :       break;
; 1381 :    case objectValue:
; 1382 :       if ( value_.map_ )
; 1383 :       {
; 1384 :          ValueInternalMap::IteratorState it;
; 1385 :          value_.map_->makeBeginIterator( it );
; 1386 :          return const_iterator( it );
; 1387 :       }
; 1388 :       break;
; 1389 : #else
; 1390 :    case arrayValue:
; 1391 :    case objectValue:
; 1392 :       if ( value_.map_ )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@begin

; 1393 :          return const_iterator( value_.map_->begin() );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueConstIterator@Json@@AAE@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@@Z ; Json::ValueConstIterator::ValueConstIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN6@begin
$LN4@begin:

; 1394 :       break;
; 1395 : #endif
; 1396 :    default:
; 1397 :       break;
; 1398 :    }
; 1399 :    return const_iterator();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueConstIterator@Json@@QAE@XZ	; Json::ValueConstIterator::ValueConstIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN6@begin:

; 1400 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ ENDP	; Json::Value::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T2 = -96						; size = 4
_writer$ = -92						; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Value::toStyledString, COMDAT
; _this$ = ecx

; 1361 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 1362 :    StyledWriter writer;

	lea	ecx, DWORD PTR _writer$[ebp]
	call	??0StyledWriter@Json@@QAE@XZ		; Json::StyledWriter::StyledWriter
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1363 :    return writer.write( *this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _writer$[ebp]
	call	?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::StyledWriter::write
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _writer$[ebp]
	call	??1StyledWriter@Json@@UAE@XZ		; Json::StyledWriter::~StyledWriter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1364 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
	lea	ecx, DWORD PTR _writer$[ebp]
	jmp	??1StyledWriter@Json@@UAE@XZ		; Json::StyledWriter::~StyledWriter
__unwindfunclet$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN5@toStyledSt
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@toStyledSt:
	ret	0
__ehhandler$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Value::toStyledString
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_placement$ = 12					; size = 4
?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z PROC ; Json::Value::getComment, COMDAT
; _this$ = ecx

; 1352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 1353 :    if ( hasComment(placement) )

	mov	eax, DWORD PTR _placement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@getComment

; 1354 :       return comments_[placement].comment_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _placement$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN2@getComment
$LN1@getComment:

; 1355 :    return "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN2@getComment:

; 1356 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ENDP ; Json::Value::getComment
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_placement$ = 8						; size = 4
?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z PROC ; Json::Value::hasComment, COMDAT
; _this$ = ecx

; 1346 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1347 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN3@hasComment
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _placement$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN3@hasComment
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@hasComment
$LN3@hasComment:
	mov	DWORD PTR tv71[ebp], 0
$LN4@hasComment:
	mov	al, BYTE PTR tv71[ebp]

; 1348 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ENDP ; Json::Value::hasComment
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_comment$ = 8						; size = 4
_placement$ = 12					; size = 4
?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z PROC ; Json::Value::setComment, COMDAT
; _this$ = ecx

; 1339 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1340 :    setComment( comment.c_str(), placement );

	mov	eax, DWORD PTR _placement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment

; 1341 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ENDP ; Json::Value::setComment
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv79 = -24						; size = 4
_this$ = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_comment$ = 8						; size = 4
_placement$ = 12					; size = 4
?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z PROC ; Json::Value::setComment, COMDAT
; _this$ = ecx

; 1329 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1330 :    if ( !comments_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN1@setComment

; 1331 :       comments_ = new CommentInfo[numberOfCommentPlacement];

	push	16					; 00000010H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN4@setComment
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx], 3
	push	OFFSET ??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	push	OFFSET ??0CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::CommentInfo
	push	3
	push	4
	mov	edx, DWORD PTR $T3[ebp]
	add	edx, 4
	push	edx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	eax, DWORD PTR $T3[ebp]
	add	eax, 4
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN5@setComment
$LN4@setComment:
	mov	DWORD PTR tv79[ebp], 0
$LN5@setComment:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+12], eax
$LN1@setComment:

; 1332 :    comments_[placement].setComment( comment );

	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _placement$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	call	?setComment@CommentInfo@Value@Json@@QAEXPBD@Z ; Json::Value::CommentInfo::setComment

; 1333 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ENDP ; Json::Value::setComment
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_members$ = -76						; size = 12
_itEnd$ = -64						; size = 4
tv172 = -60						; size = 4
tv72 = -56						; size = 4
_it$ = -52						; size = 4
_this$ = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ PROC ; Json::Value::getMemberNames, COMDAT
; _this$ = ecx

; 1206 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T4[ebp], 0

; 1207 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1208 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	jne	SHORT $LN4@getMemberN

; 1209 :        return Value::Members();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	edx, DWORD PTR $T4[ebp]
	or	edx, 1
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@getMemberN
$LN4@getMemberN:

; 1210 :    Members members;

	lea	ecx, DWORD PTR _members$[ebp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1211 :    members.reserve( value_.map_->size() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	push	eax
	lea	ecx, DWORD PTR _members$[ebp]
	call	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve

; 1212 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1213 :    ObjectValues::const_iterator it = value_.map_->begin();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _it$[ebp], eax

; 1214 :    ObjectValues::const_iterator itEnd = value_.map_->end();

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _itEnd$[ebp], eax

; 1215 :    for ( ; it != itEnd; ++it )

	jmp	SHORT $LN3@getMemberN
$LN2@getMemberN:
	lea	ecx, DWORD PTR _it$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator++
$LN3@getMemberN:
	lea	ecx, DWORD PTR _itEnd$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _it$[ebp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@getMemberN

; 1216 :       members.push_back( std::string( (*it).first.c_str() ) );

	lea	ecx, DWORD PTR _it$[ebp]
	call	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	mov	ecx, eax
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv72[ebp], eax
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR tv172[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv172[ebp]
	push	ecx
	lea	ecx, DWORD PTR _members$[ebp]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN2@getMemberN
$LN1@getMemberN:

; 1217 : #else
; 1218 :    ValueInternalMap::IteratorState it;
; 1219 :    ValueInternalMap::IteratorState itEnd;
; 1220 :    value_.map_->makeBeginIterator( it );
; 1221 :    value_.map_->makeEndIterator( itEnd );
; 1222 :    for ( ; !ValueInternalMap::equals( it, itEnd ); ValueInternalMap::increment(it) )
; 1223 :       members.push_back( std::string( ValueInternalMap::key( it ) ) );
; 1224 : #endif
; 1225 :    return members;

	lea	edx, DWORD PTR _members$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@$$QAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR $T4[ebp]
	or	eax, 1
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _members$[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@getMemberN:

; 1226 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$1:
	lea	ecx, DWORD PTR _members$[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$2:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ENDP ; Json::Value::getMemberNames
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::isMember, COMDAT
; _this$ = ecx

; 1191 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1192 :    return isMember( key.c_str() );

	mov	ecx, DWORD PTR _key$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMember@Value@Json@@QBE_NPBD@Z	; Json::Value::isMember

; 1193 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::isMember
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isMember@Value@Json@@QBE_NPBD@Z
_TEXT	SEGMENT
_value$ = -12						; size = 4
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_key$ = 8						; size = 4
?isMember@Value@Json@@QBE_NPBD@Z PROC			; Json::Value::isMember, COMDAT
; _this$ = ecx

; 1183 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1184 :    const Value *value = &((*this)[key]);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	mov	DWORD PTR _value$[ebp], eax

; 1185 :    return value != &null;

	cmp	DWORD PTR _value$[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	je	SHORT $LN3@isMember
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@isMember
$LN3@isMember:
	mov	DWORD PTR tv68[ebp], 0
$LN4@isMember:
	mov	al, BYTE PTR tv68[ebp]

; 1186 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isMember@Value@Json@@QBE_NPBD@Z ENDP			; Json::Value::isMember
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?removeMember@Value@Json@@QAE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
?removeMember@Value@Json@@QAE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::removeMember, COMDAT
; _this$ = ecx

; 1168 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 1169 :    return removeMember( key.c_str() );

	mov	ecx, DWORD PTR _key$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeMember@Value@Json@@QAE?AV12@PBD@Z ; Json::Value::removeMember
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1170 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?removeMember@Value@Json@@QAE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::removeMember
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?removeMember@Value@Json@@QAE?AV12@PBD@Z
_TEXT	SEGMENT
_old$ = -60						; size = 16
_actualKey$ = -44					; size = 8
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
_it$ = -24						; size = 4
_this$ = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
?removeMember@Value@Json@@QAE?AV12@PBD@Z PROC		; Json::Value::removeMember, COMDAT
; _this$ = ecx

; 1142 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?removeMember@Value@Json@@QAE?AV12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T5[ebp], 0

; 1143 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1144 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	jne	SHORT $LN2@removeMemb

; 1145 :       return null;

	push	OFFSET ?null@Value@Json@@2V12@B		; Json::Value::null
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T5[ebp]
	or	edx, 1
	mov	DWORD PTR $T5[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN3@removeMemb
$LN2@removeMemb:

; 1146 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1147 :    CZString actualKey( key, CZString::noDuplication );

	push	0
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1148 :    ObjectValues::iterator it = value_.map_->find( actualKey );

	lea	ecx, DWORD PTR _actualKey$[ebp]
	push	ecx
	lea	edx, DWORD PTR _it$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find

; 1149 :    if ( it == value_.map_->end() )

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@removeMemb

; 1150 :       return null;

	push	OFFSET ?null@Value@Json@@2V12@B		; Json::Value::null
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T5[ebp]
	or	ecx, 1
	mov	DWORD PTR $T5[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@removeMemb
$LN1@removeMemb:

; 1151 :    Value old(it->second);

	lea	ecx, DWORD PTR _it$[ebp]
	call	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator->
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR _old$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1152 :    value_.map_->erase(it);

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase

; 1153 :    return old;

	lea	eax, DWORD PTR _old$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T5[ebp]
	or	ecx, 1
	mov	DWORD PTR $T5[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _old$[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@removeMemb:

; 1154 : #else
; 1155 :    Value *value = value_.map_->find( key );
; 1156 :    if (value){
; 1157 :       Value old(*value);
; 1158 :       value_.map_.remove( key );
; 1159 :       return old;
; 1160 :    } else {
; 1161 :       return null;
; 1162 :    }
; 1163 : #endif
; 1164 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 1
	je	$LN6@removeMemb
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN6@removeMemb:
	ret	0
__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$1:
	lea	ecx, DWORD PTR _actualKey$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$2:
	lea	ecx, DWORD PTR _old$[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?removeMember@Value@Json@@QAE?AV12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?removeMember@Value@Json@@QAE?AV12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?removeMember@Value@Json@@QAE?AV12@PBD@Z ENDP		; Json::Value::removeMember
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z PROC ; Json::Value::get, COMDAT
; _this$ = ecx

; 1136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 1137 :    return get( key.c_str(), defaultValue );

	mov	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@Value@Json@@QBE?AV12@PBDABV12@@Z	; Json::Value::get
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1138 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ENDP ; Json::Value::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?get@Value@Json@@QBE?AV12@PBDABV12@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
_this$ = -16						; size = 4
$T2 = -12						; size = 4
tv70 = -8						; size = 4
_value$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
?get@Value@Json@@QBE?AV12@PBDABV12@@Z PROC		; Json::Value::get, COMDAT
; _this$ = ecx

; 1127 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 1128 :    const Value *value = &((*this)[key]);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	mov	DWORD PTR _value$[ebp], eax

; 1129 :    return value == &null ? defaultValue : *value;

	cmp	DWORD PTR _value$[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	jne	SHORT $LN3@get
	mov	ecx, DWORD PTR _defaultValue$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN4@get
$LN3@get:
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv70[ebp], edx
$LN4@get:
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1130 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get@Value@Json@@QBE?AV12@PBDABV12@@Z ENDP		; Json::Value::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z PROC	; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1096 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1097 :    return resolveReference( key, true );

	push	1
	mov	ecx, DWORD PTR _key$[ebp]
	call	??BStaticString@Json@@QBEPBDXZ		; Json::StaticString::operator char const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference

; 1098 : }

	mov	esp, ebp
	pop	ebp
	ret	4
??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z ENDP	; Json::Value::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1090 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1091 :    return (*this)[ key.c_str() ];

	mov	ecx, DWORD PTR _key$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]

; 1092 : }

	mov	esp, ebp
	pop	ebp
	ret	4
??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1083 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1084 :    return (*this)[ key.c_str() ];

	mov	ecx, DWORD PTR _key$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QAEAAV01@PBD@Z		; Json::Value::operator[]

; 1085 : }

	mov	esp, ebp
	pop	ebp
	ret	4
??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??AValue@Json@@QBEABV01@PBD@Z
_TEXT	SEGMENT
_actualKey$ = -44					; size = 8
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_it$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_key$ = 8						; size = 4
??AValue@Json@@QBEABV01@PBD@Z PROC			; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1064 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??AValue@Json@@QBEABV01@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1065 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1066 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	jne	SHORT $LN2@operator

; 1067 :       return null;

	mov	eax, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	$LN3@operator
$LN2@operator:

; 1068 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1069 :    CZString actualKey( key, CZString::noDuplication );

	push	0
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1070 :    ObjectValues::const_iterator it = value_.map_->find( actualKey );

	lea	eax, DWORD PTR _actualKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _it$[ebp], eax

; 1071 :    if ( it == value_.map_->end() )

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator

; 1072 :       return null;

	mov	DWORD PTR $T5[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T5[ebp]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 1073 :    return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	add	eax, 8
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T4[ebp]
$LN3@operator:

; 1074 : #else
; 1075 :    const Value *value = value_.map_->find( key );
; 1076 :    return value ? *value : null;
; 1077 : #endif
; 1078 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??AValue@Json@@QBEABV01@PBD@Z$0:
	lea	ecx, DWORD PTR _actualKey$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??AValue@Json@@QBEABV01@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??AValue@Json@@QBEABV01@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??AValue@Json@@QBEABV01@PBD@Z ENDP			; Json::Value::operator[]
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??AValue@Json@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??AValue@Json@@QAEAAV01@PBD@Z PROC			; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1016 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1017 :    return resolveReference( key, false );

	push	0
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference

; 1018 : }

	mov	esp, ebp
	pop	ebp
	ret	4
??AValue@Json@@QAEAAV01@PBD@Z ENDP			; Json::Value::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?append@Value@Json@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?append@Value@Json@@QAEAAV12@ABV12@@Z PROC		; Json::Value::append, COMDAT
; _this$ = ecx

; 1119 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1120 :    return (*this)[size()] = value;

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=

; 1121 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?append@Value@Json@@QAEAAV12@ABV12@@Z ENDP		; Json::Value::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isValidIndex@Value@Json@@QBE_NI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_index$ = 8						; size = 4
?isValidIndex@Value@Json@@QBE_NI@Z PROC			; Json::Value::isValidIndex, COMDAT
; _this$ = ecx

; 1056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1057 :    return index < size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	cmp	DWORD PTR _index$[ebp], eax
	jae	SHORT $LN3@isValidInd
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@isValidInd
$LN3@isValidInd:
	mov	DWORD PTR tv67[ebp], 0
$LN4@isValidInd:
	mov	al, BYTE PTR tv67[ebp]

; 1058 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isValidIndex@Value@Json@@QBE_NI@Z ENDP			; Json::Value::isValidIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?get@Value@Json@@QBE?AV12@IABV12@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
_this$ = -16						; size = 4
$T2 = -12						; size = 4
tv70 = -8						; size = 4
_value$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_index$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
?get@Value@Json@@QBE?AV12@IABV12@@Z PROC		; Json::Value::get, COMDAT
; _this$ = ecx

; 1048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 1049 :    const Value *value = &((*this)[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _value$[ebp], eax

; 1050 :    return value == &null ? defaultValue : *value;

	cmp	DWORD PTR _value$[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	jne	SHORT $LN3@get
	mov	ecx, DWORD PTR _defaultValue$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN4@get
$LN3@get:
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv70[ebp], edx
$LN4@get:
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1051 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get@Value@Json@@QBE?AV12@IABV12@@Z ENDP		; Json::Value::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??AValue@Json@@QBEABV01@I@Z
_TEXT	SEGMENT
_key$ = -44						; size = 8
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_it$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_index$ = 8						; size = 4
??AValue@Json@@QBEABV01@I@Z PROC			; Json::Value::operator[], COMDAT
; _this$ = ecx

; 997  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??AValue@Json@@QBEABV01@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 998  :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue );
; 999  :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	jne	SHORT $LN2@operator

; 1000 :       return null;

	mov	eax, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	$LN3@operator
$LN2@operator:

; 1001 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1002 :    CZString key( index );

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	lea	ecx, DWORD PTR _key$[ebp]
	call	??0CZString@Value@Json@@QAE@H@Z		; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _it$[ebp], eax

; 1004 :    if ( it == value_.map_->end() )

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator

; 1005 :       return null;

	mov	DWORD PTR $T5[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T5[ebp]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 1006 :    return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	add	eax, 8
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T4[ebp]
$LN3@operator:

; 1007 : #else
; 1008 :    Value *value = value_.array_->find( index );
; 1009 :    return value ? *value : null;
; 1010 : #endif
; 1011 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??AValue@Json@@QBEABV01@I@Z$0:
	lea	ecx, DWORD PTR _key$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??AValue@Json@@QBEABV01@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??AValue@Json@@QBEABV01@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??AValue@Json@@QBEABV01@I@Z ENDP			; Json::Value::operator[]
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??AValue@Json@@QAEAAV01@I@Z
_TEXT	SEGMENT
_defaultValue$ = -96					; size = 24
$T2 = -72						; size = 16
_key$ = -56						; size = 8
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
tv178 = -28						; size = 4
tv184 = -24						; size = 4
_this$ = -20						; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_index$ = 8						; size = 4
??AValue@Json@@QAEAAV01@I@Z PROC			; Json::Value::operator[], COMDAT
; _this$ = ecx

; 976  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??AValue@Json@@QAEAAV01@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 977  :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue );
; 978  :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	jne	SHORT $LN2@operator

; 979  :       *this = Value( arrayValue );

	push	6
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv184[ebp], eax
	mov	edx, DWORD PTR tv184[ebp]
	mov	DWORD PTR tv178[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv178[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN2@operator:

; 980  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 981  :    CZString key( index );

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _key$[ebp]
	call	??0CZString@Value@Json@@QAE@H@Z		; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 982  :    ObjectValues::iterator it = value_.map_->lower_bound( key );

	lea	edx, DWORD PTR _key$[ebp]
	push	edx
	lea	eax, DWORD PTR _it$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound

; 983  :    if ( it != value_.map_->end()  &&  (*it).first == key )

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator
	lea	edx, DWORD PTR _key$[ebp]
	push	edx
	lea	ecx, DWORD PTR _it$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	mov	ecx, eax
	call	??8CZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator

; 984  :       return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	add	eax, 8
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T7[ebp]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 985  : 
; 986  :    ObjectValues::value_type defaultValue( key, null );

	push	OFFSET ?null@Value@Json@@2V12@B		; Json::Value::null
	lea	ecx, DWORD PTR _key$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	call	??$?0AAVCZString@Value@Json@@ABV12@X@?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@AAVCZString@Value@Json@@ABV34@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value><Json::Value::CZString &,Json::Value const &,void>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 987  :    it = value_.map_->insert( it, defaultValue );

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T6[ebp], edx
	lea	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T6[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	??$insert@AAU?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@1@AAU?$pair@$$CBVCZString@Value@Json@@V23@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert<std::pair<Json::Value::CZString const ,Json::Value> &>
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$[ebp], ecx

; 988  :    return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	add	eax, 8
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T5[ebp]
$LN3@operator:

; 989  : #else
; 990  :    return value_.array_->resolveReference( index );
; 991  : #endif
; 992  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$1:
	lea	ecx, DWORD PTR _key$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$2:
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	jmp	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
__ehhandler$??AValue@Json@@QAEAAV01@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??AValue@Json@@QAEAAV01@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??AValue@Json@@QAEAAV01@I@Z ENDP			; Json::Value::operator[]
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?resize@Value@Json@@QAEXI@Z
_TEXT	SEGMENT
$T2 = -56						; size = 16
$T3 = -40						; size = 8
tv130 = -32						; size = 4
tv132 = -28						; size = 4
_oldSize$ = -24						; size = 4
_index$4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_newSize$ = 8						; size = 4
?resize@Value@Json@@QAEXI@Z PROC			; Json::Value::resize, COMDAT
; _this$ = ecx

; 952  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?resize@Value@Json@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 953  :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue );
; 954  :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	jne	SHORT $LN8@resize

; 955  :       *this = Value( arrayValue );

	push	6
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv132[ebp], eax
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv130[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv130[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN8@resize:

; 956  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 957  :    UInt oldSize = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	DWORD PTR _oldSize$[ebp], eax

; 958  :    if ( newSize == 0 )

	cmp	DWORD PTR _newSize$[ebp], 0
	jne	SHORT $LN7@resize

; 959  :       clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@Value@Json@@QAEXXZ		; Json::Value::clear
	jmp	SHORT $LN9@resize
$LN7@resize:

; 960  :    else if ( newSize > oldSize )

	mov	ecx, DWORD PTR _newSize$[ebp]
	cmp	ecx, DWORD PTR _oldSize$[ebp]
	jbe	SHORT $LN5@resize

; 961  :       (*this)[ newSize - 1 ];

	mov	edx, DWORD PTR _newSize$[ebp]
	sub	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]

; 962  :    else

	jmp	SHORT $LN9@resize
$LN5@resize:

; 963  :    {
; 964  :       for ( UInt index = newSize; index < oldSize; ++index )

	mov	eax, DWORD PTR _newSize$[ebp]
	mov	DWORD PTR _index$4[ebp], eax
	jmp	SHORT $LN3@resize
$LN2@resize:
	mov	ecx, DWORD PTR _index$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$4[ebp], ecx
$LN3@resize:
	mov	edx, DWORD PTR _index$4[ebp]
	cmp	edx, DWORD PTR _oldSize$[ebp]
	jae	SHORT $LN9@resize

; 965  :          value_.map_->erase( index );

	mov	eax, DWORD PTR _index$4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CZString@Value@Json@@QAE@H@Z		; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	jmp	SHORT $LN2@resize
$LN9@resize:

; 966  :       assert( size() == newSize );
; 967  :    }
; 968  : #else
; 969  :    value_.array_->resize( newSize );
; 970  : #endif
; 971  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resize@Value@Json@@QAEXI@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?resize@Value@Json@@QAEXI@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$?resize@Value@Json@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?resize@Value@Json@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?resize@Value@Json@@QAEXI@Z ENDP			; Json::Value::resize
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?clear@Value@Json@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?clear@Value@Json@@QAEXXZ PROC				; Json::Value::clear, COMDAT
; _this$ = ecx

; 927  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 928  :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue  || type_ == objectValue );
; 929  : 
; 930  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN5@clear
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN2@clear
	jmp	SHORT $LN5@clear
$LN2@clear:

; 931  :    {
; 932  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 933  :    case arrayValue:
; 934  :    case objectValue:
; 935  :       value_.map_->clear();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear
$LN5@clear:

; 936  :       break;
; 937  : #else
; 938  :    case arrayValue:
; 939  :       value_.array_->clear();
; 940  :       break;
; 941  :    case objectValue:
; 942  :       value_.map_->clear();
; 943  :       break;
; 944  : #endif
; 945  :    default:
; 946  :       break;
; 947  :    }
; 948  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@Value@Json@@QAEXXZ ENDP				; Json::Value::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??7Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??7Value@Json@@QBE_NXZ PROC				; Json::Value::operator!, COMDAT
; _this$ = ecx

; 920  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 921  :    return isNull();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNull@Value@Json@@QBE_NXZ		; Json::Value::isNull

; 922  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??7Value@Json@@QBE_NXZ ENDP				; Json::Value::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?empty@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
?empty@Value@Json@@QBE_NXZ PROC				; Json::Value::empty, COMDAT
; _this$ = ecx

; 910  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 911  :    if ( isNull() || isArray() || isObject() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNull@Value@Json@@QBE_NXZ		; Json::Value::isNull
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@empty
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@empty
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@empty
$LN2@empty:

; 912  :       return size() == 0u;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	test	eax, eax
	jne	SHORT $LN6@empty
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN7@empty
$LN6@empty:
	mov	DWORD PTR tv79[ebp], 0
$LN7@empty:
	mov	al, BYTE PTR tv79[ebp]
	jmp	SHORT $LN4@empty

; 913  :    else

	jmp	SHORT $LN4@empty
$LN3@empty:

; 914  :       return false;

	xor	al, al
$LN4@empty:

; 915  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@Value@Json@@QBE_NXZ ENDP				; Json::Value::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?size@Value@Json@@QBEIXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
_itLast$2 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?size@Value@Json@@QBEIXZ PROC				; Json::Value::size, COMDAT
; _this$ = ecx

; 874  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 875  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	SHORT $LN6@size
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN10@size[edx*4]
$LN5@size:

; 876  :    {
; 877  :    case nullValue:
; 878  :    case intValue:
; 879  :    case uintValue:
; 880  :    case realValue:
; 881  :    case booleanValue:
; 882  :    case stringValue:
; 883  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN8@size
$LN4@size:

; 884  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 885  :    case arrayValue:  // size of the array is highest index + 1
; 886  :       if ( !value_.map_->empty() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@size

; 887  :       {
; 888  :          ObjectValues::const_iterator itLast = value_.map_->end();

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _itLast$2[ebp], ecx

; 889  :          --itLast;

	lea	ecx, DWORD PTR _itLast$2[ebp]
	call	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator--

; 890  :          return (*itLast).first.index()+1;

	lea	ecx, DWORD PTR _itLast$2[ebp]
	call	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<Json::Value::CZString const ,Json::Value> > > >::operator*
	mov	ecx, eax
	call	?index@CZString@Value@Json@@QBEHXZ	; Json::Value::CZString::index
	add	eax, 1
	jmp	SHORT $LN8@size
$LN3@size:

; 891  :       }
; 892  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN8@size
$LN2@size:

; 893  :    case objectValue:
; 894  :       return Int( value_.map_->size() );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	jmp	SHORT $LN8@size
$LN6@size:

; 895  : #else
; 896  :    case arrayValue:
; 897  :       return Int( value_.array_->size() );
; 898  :    case objectValue:
; 899  :       return Int( value_.map_->size() );
; 900  : #endif
; 901  :    default:
; 902  :       JSON_ASSERT_UNREACHABLE;
; 903  :    }
; 904  :    return 0; // unreachable;

	xor	eax, eax
$LN8@size:

; 905  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@size:
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN4@size
	DD	$LN2@size
?size@Value@Json@@QBEIXZ ENDP				; Json::Value::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z
_TEXT	SEGMENT
tv200 = -36						; size = 4
tv187 = -32						; size = 4
tv174 = -28						; size = 4
tv161 = -24						; size = 4
tv149 = -20						; size = 4
tv94 = -16						; size = 4
tv80 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z PROC	; Json::Value::isConvertibleTo, COMDAT
; _this$ = ecx

; 822  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 823  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN1@isConverti
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN40@isConverti[edx*4]
$LN9@isConverti:

; 824  :    {
; 825  :    case nullValue:
; 826  :       return true;

	mov	al, 1
	jmp	$LN12@isConverti
$LN8@isConverti:

; 827  :    case intValue:
; 828  :       return ( other == nullValue  &&  value_.int_ == 0 )
; 829  :              || other == intValue
; 830  :              || ( other == uintValue  && value_.int_ >= 0 )
; 831  :              || other == realValue
; 832  :              || other == stringValue
; 833  :              || other == booleanValue;

	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN14@isConverti
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN15@isConverti
$LN14@isConverti:
	cmp	DWORD PTR _other$[ebp], 1
	je	SHORT $LN15@isConverti
	cmp	DWORD PTR _other$[ebp], 2
	jne	SHORT $LN16@isConverti
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	SHORT $LN15@isConverti
$LN16@isConverti:
	cmp	DWORD PTR _other$[ebp], 3
	je	SHORT $LN15@isConverti
	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN15@isConverti
	cmp	DWORD PTR _other$[ebp], 5
	je	SHORT $LN15@isConverti
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN17@isConverti
$LN15@isConverti:
	mov	DWORD PTR tv80[ebp], 1
$LN17@isConverti:
	mov	al, BYTE PTR tv80[ebp]
	jmp	$LN12@isConverti
$LN7@isConverti:

; 834  :    case uintValue:
; 835  :       return ( other == nullValue  &&  value_.uint_ == 0 )
; 836  :              || ( other == intValue  && value_.uint_ <= (unsigned)maxInt )
; 837  :              || other == uintValue
; 838  :              || other == realValue
; 839  :              || other == stringValue
; 840  :              || other == booleanValue;

	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN18@isConverti
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN20@isConverti
$LN18@isConverti:
	cmp	DWORD PTR _other$[ebp], 1
	jne	SHORT $LN19@isConverti
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 2147483647		; 7fffffffH
	jbe	SHORT $LN20@isConverti
$LN19@isConverti:
	cmp	DWORD PTR _other$[ebp], 2
	je	SHORT $LN20@isConverti
	cmp	DWORD PTR _other$[ebp], 3
	je	SHORT $LN20@isConverti
	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN20@isConverti
	cmp	DWORD PTR _other$[ebp], 5
	je	SHORT $LN20@isConverti
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $LN21@isConverti
$LN20@isConverti:
	mov	DWORD PTR tv94[ebp], 1
$LN21@isConverti:
	mov	al, BYTE PTR tv94[ebp]
	jmp	$LN12@isConverti
$LN6@isConverti:

; 841  :    case realValue:
; 842  :       return ( other == nullValue  &&  value_.real_ == 0.0 )
; 843  :              || ( other == intValue  &&  value_.real_ >= minInt  &&  value_.real_ <= maxInt )
; 844  :              || ( other == uintValue  &&  value_.real_ >= 0  &&  value_.real_ <= maxUInt )
; 845  :              || other == realValue
; 846  :              || other == stringValue
; 847  :              || other == booleanValue;

	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN22@isConverti
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@isConverti
$LN22@isConverti:
	cmp	DWORD PTR _other$[ebp], 1
	jne	SHORT $LN23@isConverti
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	comisd	xmm0, QWORD PTR __real@c1e0000000000000
	jb	SHORT $LN23@isConverti
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	comisd	xmm0, QWORD PTR [eax]
	jae	SHORT $LN24@isConverti
$LN23@isConverti:
	cmp	DWORD PTR _other$[ebp], 2
	jne	SHORT $LN25@isConverti
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN25@isConverti
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@41efffffffe00000
	comisd	xmm0, QWORD PTR [edx]
	jae	SHORT $LN24@isConverti
$LN25@isConverti:
	cmp	DWORD PTR _other$[ebp], 3
	je	SHORT $LN24@isConverti
	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN24@isConverti
	cmp	DWORD PTR _other$[ebp], 5
	je	SHORT $LN24@isConverti
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN26@isConverti
$LN24@isConverti:
	mov	DWORD PTR tv149[ebp], 1
$LN26@isConverti:
	mov	al, BYTE PTR tv149[ebp]
	jmp	$LN12@isConverti
$LN5@isConverti:

; 848  :    case booleanValue:
; 849  :       return ( other == nullValue  &&  value_.bool_ == false )
; 850  :              || other == intValue
; 851  :              || other == uintValue
; 852  :              || other == realValue
; 853  :              || other == stringValue
; 854  :              || other == booleanValue;

	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN27@isConverti
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN28@isConverti
$LN27@isConverti:
	cmp	DWORD PTR _other$[ebp], 1
	je	SHORT $LN28@isConverti
	cmp	DWORD PTR _other$[ebp], 2
	je	SHORT $LN28@isConverti
	cmp	DWORD PTR _other$[ebp], 3
	je	SHORT $LN28@isConverti
	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN28@isConverti
	cmp	DWORD PTR _other$[ebp], 5
	je	SHORT $LN28@isConverti
	mov	DWORD PTR tv161[ebp], 0
	jmp	SHORT $LN29@isConverti
$LN28@isConverti:
	mov	DWORD PTR tv161[ebp], 1
$LN29@isConverti:
	mov	al, BYTE PTR tv161[ebp]
	jmp	$LN12@isConverti
$LN4@isConverti:

; 855  :    case stringValue:
; 856  :       return other == stringValue
; 857  :              || ( other == nullValue  &&  (!value_.string_  ||  value_.string_[0] == 0) );

	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN32@isConverti
	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN31@isConverti
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN32@isConverti
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+ecx]
	test	ecx, ecx
	je	SHORT $LN32@isConverti
$LN31@isConverti:
	mov	DWORD PTR tv174[ebp], 0
	jmp	SHORT $LN33@isConverti
$LN32@isConverti:
	mov	DWORD PTR tv174[ebp], 1
$LN33@isConverti:
	mov	al, BYTE PTR tv174[ebp]
	jmp	SHORT $LN12@isConverti
$LN3@isConverti:

; 858  :    case arrayValue:
; 859  :       return other == arrayValue
; 860  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	cmp	DWORD PTR _other$[ebp], 6
	je	SHORT $LN35@isConverti
	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN34@isConverti
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	test	eax, eax
	je	SHORT $LN35@isConverti
$LN34@isConverti:
	mov	DWORD PTR tv187[ebp], 0
	jmp	SHORT $LN36@isConverti
$LN35@isConverti:
	mov	DWORD PTR tv187[ebp], 1
$LN36@isConverti:
	mov	al, BYTE PTR tv187[ebp]
	jmp	SHORT $LN12@isConverti
$LN2@isConverti:

; 861  :    case objectValue:
; 862  :       return other == objectValue
; 863  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	cmp	DWORD PTR _other$[ebp], 7
	je	SHORT $LN38@isConverti
	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN37@isConverti
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	test	eax, eax
	je	SHORT $LN38@isConverti
$LN37@isConverti:
	mov	DWORD PTR tv200[ebp], 0
	jmp	SHORT $LN39@isConverti
$LN38@isConverti:
	mov	DWORD PTR tv200[ebp], 1
$LN39@isConverti:
	mov	al, BYTE PTR tv200[ebp]
	jmp	SHORT $LN12@isConverti
$LN1@isConverti:

; 864  :    default:
; 865  :       JSON_ASSERT_UNREACHABLE;
; 866  :    }
; 867  :    return false; // unreachable;

	xor	al, al
$LN12@isConverti:

; 868  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN40@isConverti:
	DD	$LN9@isConverti
	DD	$LN8@isConverti
	DD	$LN7@isConverti
	DD	$LN6@isConverti
	DD	$LN4@isConverti
	DD	$LN5@isConverti
	DD	$LN3@isConverti
	DD	$LN2@isConverti
?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z ENDP	; Json::Value::isConvertibleTo
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isObject@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?isObject@Value@Json@@QBE_NXZ PROC			; Json::Value::isObject, COMDAT
; _this$ = ecx

; 1321 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1322 :    return type_ == nullValue  ||  type_ == objectValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	je	SHORT $LN3@isObject
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	cmp	eax, 7
	je	SHORT $LN3@isObject
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@isObject
$LN3@isObject:
	mov	DWORD PTR tv72[ebp], 1
$LN4@isObject:
	mov	al, BYTE PTR tv72[ebp]

; 1323 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isObject@Value@Json@@QBE_NXZ ENDP			; Json::Value::isObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isArray@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?isArray@Value@Json@@QBE_NXZ PROC			; Json::Value::isArray, COMDAT
; _this$ = ecx

; 1314 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1315 :    return type_ == nullValue  ||  type_ == arrayValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	je	SHORT $LN3@isArray
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	cmp	eax, 6
	je	SHORT $LN3@isArray
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@isArray
$LN3@isArray:
	mov	DWORD PTR tv72[ebp], 1
$LN4@isArray:
	mov	al, BYTE PTR tv72[ebp]

; 1316 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isArray@Value@Json@@QBE_NXZ ENDP			; Json::Value::isArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isString@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?isString@Value@Json@@QBE_NXZ PROC			; Json::Value::isString, COMDAT
; _this$ = ecx

; 1307 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1308 :    return type_ == stringValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	cmp	ecx, 4
	jne	SHORT $LN3@isString
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@isString
$LN3@isString:
	mov	DWORD PTR tv68[ebp], 0
$LN4@isString:
	mov	al, BYTE PTR tv68[ebp]

; 1309 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isString@Value@Json@@QBE_NXZ ENDP			; Json::Value::isString
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isNumeric@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?isNumeric@Value@Json@@QBE_NXZ PROC			; Json::Value::isNumeric, COMDAT
; _this$ = ecx

; 1300 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1301 :    return isIntegral() || isDouble();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isIntegral@Value@Json@@QBE_NXZ		; Json::Value::isIntegral
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@isNumeric
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isDouble@Value@Json@@QBE_NXZ		; Json::Value::isDouble
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@isNumeric
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@isNumeric
$LN3@isNumeric:
	mov	DWORD PTR tv72[ebp], 1
$LN4@isNumeric:
	mov	al, BYTE PTR tv72[ebp]

; 1302 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isNumeric@Value@Json@@QBE_NXZ ENDP			; Json::Value::isNumeric
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isDouble@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?isDouble@Value@Json@@QBE_NXZ PROC			; Json::Value::isDouble, COMDAT
; _this$ = ecx

; 1293 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1294 :    return type_ == realValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	cmp	ecx, 3
	jne	SHORT $LN3@isDouble
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@isDouble
$LN3@isDouble:
	mov	DWORD PTR tv68[ebp], 0
$LN4@isDouble:
	mov	al, BYTE PTR tv68[ebp]

; 1295 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isDouble@Value@Json@@QBE_NXZ ENDP			; Json::Value::isDouble
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isIntegral@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?isIntegral@Value@Json@@QBE_NXZ PROC			; Json::Value::isIntegral, COMDAT
; _this$ = ecx

; 1284 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1285 :    return type_ == intValue  
; 1286 :           ||  type_ == uintValue  
; 1287 :           ||  type_ == booleanValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	cmp	ecx, 1
	je	SHORT $LN3@isIntegral
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	cmp	eax, 2
	je	SHORT $LN3@isIntegral
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 24					; 00000018H
	sar	edx, 24					; 00000018H
	cmp	edx, 5
	je	SHORT $LN3@isIntegral
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@isIntegral
$LN3@isIntegral:
	mov	DWORD PTR tv76[ebp], 1
$LN4@isIntegral:
	mov	al, BYTE PTR tv76[ebp]

; 1288 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isIntegral@Value@Json@@QBE_NXZ ENDP			; Json::Value::isIntegral
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isUInt@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?isUInt@Value@Json@@QBE_NXZ PROC			; Json::Value::isUInt, COMDAT
; _this$ = ecx

; 1277 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1278 :    return type_ == uintValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	cmp	ecx, 2
	jne	SHORT $LN3@isUInt
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@isUInt
$LN3@isUInt:
	mov	DWORD PTR tv68[ebp], 0
$LN4@isUInt:
	mov	al, BYTE PTR tv68[ebp]

; 1279 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isUInt@Value@Json@@QBE_NXZ ENDP			; Json::Value::isUInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isInt@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?isInt@Value@Json@@QBE_NXZ PROC				; Json::Value::isInt, COMDAT
; _this$ = ecx

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1271 :    return type_ == intValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	cmp	ecx, 1
	jne	SHORT $LN3@isInt
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@isInt
$LN3@isInt:
	mov	DWORD PTR tv68[ebp], 0
$LN4@isInt:
	mov	al, BYTE PTR tv68[ebp]

; 1272 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isInt@Value@Json@@QBE_NXZ ENDP				; Json::Value::isInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isBool@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?isBool@Value@Json@@QBE_NXZ PROC			; Json::Value::isBool, COMDAT
; _this$ = ecx

; 1263 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1264 :    return type_ == booleanValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	cmp	ecx, 5
	jne	SHORT $LN3@isBool
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@isBool
$LN3@isBool:
	mov	DWORD PTR tv68[ebp], 0
$LN4@isBool:
	mov	al, BYTE PTR tv68[ebp]

; 1265 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isBool@Value@Json@@QBE_NXZ ENDP			; Json::Value::isBool
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isNull@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?isNull@Value@Json@@QBE_NXZ PROC			; Json::Value::isNull, COMDAT
; _this$ = ecx

; 1256 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1257 :    return type_ == nullValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	test	ecx, ecx
	jne	SHORT $LN3@isNull
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@isNull
$LN3@isNull:
	mov	DWORD PTR tv68[ebp], 0
$LN4@isNull:
	mov	al, BYTE PTR tv68[ebp]

; 1258 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isNull@Value@Json@@QBE_NXZ ENDP			; Json::Value::isNull
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?asBool@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv132 = -24						; size = 4
tv89 = -20						; size = 4
tv76 = -16						; size = 4
tv71 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?asBool@Value@Json@@QBE_NXZ PROC			; Json::Value::asBool, COMDAT
; _this$ = ecx

; 796  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 797  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN1@asBool
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN20@asBool[edx*4]
$LN7@asBool:

; 798  :    {
; 799  :    case nullValue:
; 800  :       return false;

	xor	al, al
	jmp	$LN10@asBool
$LN6@asBool:

; 801  :    case intValue:
; 802  :    case uintValue:
; 803  :       return value_.int_ != 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN12@asBool
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN13@asBool
$LN12@asBool:
	mov	DWORD PTR tv71[ebp], 0
$LN13@asBool:
	mov	al, BYTE PTR tv71[ebp]
	jmp	$LN10@asBool
$LN5@asBool:

; 804  :    case realValue:
; 805  :       return value_.real_ != 0.0;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@asBool
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN15@asBool
$LN14@asBool:
	mov	DWORD PTR tv76[ebp], 0
$LN15@asBool:
	mov	al, BYTE PTR tv76[ebp]
	jmp	SHORT $LN10@asBool
$LN4@asBool:

; 806  :    case booleanValue:
; 807  :       return value_.bool_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx]
	jmp	SHORT $LN10@asBool
$LN3@asBool:

; 808  :    case stringValue:
; 809  :       return value_.string_  &&  value_.string_[0] != 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@asBool
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+edx]
	test	edx, edx
	je	SHORT $LN16@asBool
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN17@asBool
$LN16@asBool:
	mov	DWORD PTR tv89[ebp], 0
$LN17@asBool:
	mov	al, BYTE PTR tv89[ebp]
	jmp	SHORT $LN10@asBool
$LN2@asBool:

; 810  :    case arrayValue:
; 811  :    case objectValue:
; 812  :       return value_.map_->size() != 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	test	eax, eax
	je	SHORT $LN18@asBool
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $LN19@asBool
$LN18@asBool:
	mov	DWORD PTR tv132[ebp], 0
$LN19@asBool:
	mov	al, BYTE PTR tv132[ebp]
	jmp	SHORT $LN10@asBool
$LN1@asBool:

; 813  :    default:
; 814  :       JSON_ASSERT_UNREACHABLE;
; 815  :    }
; 816  :    return false; // unreachable;

	xor	al, al
$LN10@asBool:

; 817  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@asBool:
	DD	$LN7@asBool
	DD	$LN6@asBool
	DD	$LN6@asBool
	DD	$LN5@asBool
	DD	$LN3@asBool
	DD	$LN4@asBool
	DD	$LN2@asBool
	DD	$LN2@asBool
?asBool@Value@Json@@QBE_NXZ ENDP			; Json::Value::asBool
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?asDouble@Value@Json@@QBENXZ
_TEXT	SEGMENT
$T1 = -48						; size = 12
tv136 = -36						; size = 8
tv94 = -28						; size = 8
tv80 = -20						; size = 8
tv131 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?asDouble@Value@Json@@QBENXZ PROC			; Json::Value::asDouble, COMDAT
; _this$ = ecx

; 771  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 772  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN2@asDouble
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN15@asDouble[edx*4]
$LN8@asDouble:

; 773  :    {
; 774  :    case nullValue:
; 775  :       return 0.0;

	fldz
	jmp	$LN11@asDouble
$LN7@asDouble:

; 776  :    case intValue:
; 777  :       return value_.int_;

	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax]
	fstp	QWORD PTR tv94[ebp]
	fld	QWORD PTR tv94[ebp]
	jmp	SHORT $LN11@asDouble
$LN6@asDouble:

; 778  :    case uintValue:
; 779  :       return value_.uint_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv131[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv131[ebp]
	mov	eax, DWORD PTR tv131[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv136[ebp], xmm0
	fld	QWORD PTR tv136[ebp]
	jmp	SHORT $LN11@asDouble
$LN5@asDouble:

; 780  :    case realValue:
; 781  :       return value_.real_;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	QWORD PTR [ecx]
	jmp	SHORT $LN11@asDouble
$LN4@asDouble:

; 782  :    case booleanValue:
; 783  :       return value_.bool_ ? 1.0 : 0.0;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN13@asDouble
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN14@asDouble
$LN13@asDouble:
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR tv80[ebp], xmm0
$LN14@asDouble:
	fld	QWORD PTR tv80[ebp]
	jmp	SHORT $LN11@asDouble
$LN3@asDouble:

; 784  :    case stringValue:
; 785  :    case arrayValue:
; 786  :    case objectValue:
; 787  :       JSON_ASSERT_MESSAGE( false, "Type is not convertible to double" );

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@asDouble
	push	OFFSET ??_C@_0CC@ICOHKFIF@Type?5is?5not?5convertible?5to?5doubl@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	__CxxThrowException@8
$LN2@asDouble:

; 788  :    default:
; 789  :       JSON_ASSERT_UNREACHABLE;
; 790  :    }
; 791  :    return 0; // unreachable;

	fldz
$LN11@asDouble:

; 792  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN15@asDouble:
	DD	$LN8@asDouble
	DD	$LN7@asDouble
	DD	$LN6@asDouble
	DD	$LN5@asDouble
	DD	$LN3@asDouble
	DD	$LN4@asDouble
	DD	$LN3@asDouble
	DD	$LN3@asDouble
?asDouble@Value@Json@@QBENXZ ENDP			; Json::Value::asDouble
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?asUInt@Value@Json@@QBEIXZ
_TEXT	SEGMENT
$T1 = -48						; size = 12
$T2 = -36						; size = 12
$T3 = -24						; size = 12
tv128 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?asUInt@Value@Json@@QBEIXZ PROC				; Json::Value::asUInt, COMDAT
; _this$ = ecx

; 744  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 745  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN2@asUInt
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN18@asUInt[edx*4]
$LN11@asUInt:

; 746  :    {
; 747  :    case nullValue:
; 748  :       return 0;

	xor	eax, eax
	jmp	$LN14@asUInt
$LN10@asUInt:

; 749  :    case intValue:
; 750  :       JSON_ASSERT_MESSAGE( value_.int_ >= 0, "Negative integer can not be converted to unsigned integer" );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN9@asUInt
	push	OFFSET ??_C@_0DK@NAHIGMFE@Negative?5integer?5can?5not?5be?5conv@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN9@asUInt:

; 751  :       return value_.int_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	$LN14@asUInt
$LN8@asUInt:

; 752  :    case uintValue:
; 753  :       return value_.uint_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	$LN14@asUInt
$LN7@asUInt:

; 754  :    case realValue:
; 755  :       JSON_ASSERT_MESSAGE( value_.real_ >= 0  &&  value_.real_ <= maxUInt,  "Real out of unsigned integer range" );

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN5@asUInt
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@41efffffffe00000
	comisd	xmm0, QWORD PTR [edx]
	jae	SHORT $LN6@asUInt
$LN5@asUInt:
	push	OFFSET ??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN6@asUInt:

; 756  :       return UInt( value_.real_ );

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	call	__dtoui3
	jmp	SHORT $LN14@asUInt
$LN4@asUInt:

; 757  :    case booleanValue:
; 758  :       return value_.bool_ ? 1 : 0;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN16@asUInt
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN17@asUInt
$LN16@asUInt:
	mov	DWORD PTR tv128[ebp], 0
$LN17@asUInt:
	mov	eax, DWORD PTR tv128[ebp]
	jmp	SHORT $LN14@asUInt
$LN3@asUInt:

; 759  :    case stringValue:
; 760  :    case arrayValue:
; 761  :    case objectValue:
; 762  :       JSON_ASSERT_MESSAGE( false, "Type is not convertible to uint" );

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@asUInt
	push	OFFSET ??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	__CxxThrowException@8
$LN2@asUInt:

; 763  :    default:
; 764  :       JSON_ASSERT_UNREACHABLE;
; 765  :    }
; 766  :    return 0; // unreachable;

	xor	eax, eax
$LN14@asUInt:

; 767  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN18@asUInt:
	DD	$LN11@asUInt
	DD	$LN10@asUInt
	DD	$LN8@asUInt
	DD	$LN7@asUInt
	DD	$LN3@asUInt
	DD	$LN4@asUInt
	DD	$LN3@asUInt
	DD	$LN3@asUInt
?asUInt@Value@Json@@QBEIXZ ENDP				; Json::Value::asUInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?asInt@Value@Json@@QBEHXZ
_TEXT	SEGMENT
$T1 = -48						; size = 12
$T2 = -36						; size = 12
$T3 = -24						; size = 12
tv128 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?asInt@Value@Json@@QBEHXZ PROC				; Json::Value::asInt, COMDAT
; _this$ = ecx

; 717  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 718  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN2@asInt
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN18@asInt[edx*4]
$LN11@asInt:

; 719  :    {
; 720  :    case nullValue:
; 721  :       return 0;

	xor	eax, eax
	jmp	$LN14@asInt
$LN10@asInt:

; 722  :    case intValue:
; 723  :       return value_.int_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	$LN14@asInt
$LN9@asInt:

; 724  :    case uintValue:
; 725  :       JSON_ASSERT_MESSAGE( value_.uint_ < (unsigned)maxInt, "integer out of signed integer range" );

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 2147483647		; 7fffffffH
	jb	SHORT $LN8@asInt
	push	OFFSET ??_C@_0CE@MKMAPPKF@integer?5out?5of?5signed?5integer?5ra@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	__CxxThrowException@8
$LN8@asInt:

; 726  :       return value_.uint_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	$LN14@asInt
$LN7@asInt:

; 727  :    case realValue:
; 728  :       JSON_ASSERT_MESSAGE( value_.real_ >= minInt  &&  value_.real_ <= maxInt, "Real out of signed integer range" );

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	comisd	xmm0, QWORD PTR __real@c1e0000000000000
	jb	SHORT $LN5@asInt
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	comisd	xmm0, QWORD PTR [edx]
	jae	SHORT $LN6@asInt
$LN5@asInt:
	push	OFFSET ??_C@_0CB@PBEICPFN@Real?5out?5of?5signed?5integer?5range@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN6@asInt:

; 729  :       return Int( value_.real_ );

	mov	ecx, DWORD PTR _this$[ebp]
	cvttsd2si eax, QWORD PTR [ecx]
	jmp	SHORT $LN14@asInt
$LN4@asInt:

; 730  :    case booleanValue:
; 731  :       return value_.bool_ ? 1 : 0;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN16@asInt
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN17@asInt
$LN16@asInt:
	mov	DWORD PTR tv128[ebp], 0
$LN17@asInt:
	mov	eax, DWORD PTR tv128[ebp]
	jmp	SHORT $LN14@asInt
$LN3@asInt:

; 732  :    case stringValue:
; 733  :    case arrayValue:
; 734  :    case objectValue:
; 735  :       JSON_ASSERT_MESSAGE( false, "Type is not convertible to int" );

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@asInt
	push	OFFSET ??_C@_0BP@KDDCHLKA@Type?5is?5not?5convertible?5to?5int?$AA@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	__CxxThrowException@8
$LN2@asInt:

; 736  :    default:
; 737  :       JSON_ASSERT_UNREACHABLE;
; 738  :    }
; 739  :    return 0; // unreachable;

	xor	eax, eax
$LN14@asInt:

; 740  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@asInt:
	DD	$LN11@asInt
	DD	$LN10@asInt
	DD	$LN9@asInt
	DD	$LN7@asInt
	DD	$LN3@asInt
	DD	$LN4@asInt
	DD	$LN3@asInt
	DD	$LN3@asInt
?asInt@Value@Json@@QBEHXZ ENDP				; Json::Value::asInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 12
tv88 = -20						; size = 4
tv79 = -16						; size = 4
tv67 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Value::asString, COMDAT
; _this$ = ecx

; 686  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 687  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN7@asString
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN17@asString[edx*4]
$LN6@asString:

; 688  :    {
; 689  :    case nullValue:
; 690  :       return "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@asString
$LN5@asString:

; 691  :    case stringValue:
; 692  :       return value_.string_ ? value_.string_ : "";

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN11@asString
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN12@asString
$LN11@asString:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN12@asString:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN10@asString
$LN4@asString:

; 693  :    case booleanValue:
; 694  :       return value_.bool_ ? "true" : "false";

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@asString
	mov	DWORD PTR tv88[ebp], OFFSET ??_C@_04LOAJBDKD@true?$AA@
	jmp	SHORT $LN14@asString
$LN13@asString:
	mov	DWORD PTR tv88[ebp], OFFSET ??_C@_05LAPONLG@false?$AA@
$LN14@asString:
	mov	edx, DWORD PTR tv88[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN10@asString
$LN3@asString:

; 695  :    case intValue:
; 696  :    case uintValue:
; 697  :    case realValue:
; 698  :    case arrayValue:
; 699  :    case objectValue:
; 700  :       JSON_ASSERT_MESSAGE( false, "Type is not convertible to string" );

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@asString
	push	OFFSET ??_C@_0CC@BNBMBIGA@Type?5is?5not?5convertible?5to?5strin@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	__CxxThrowException@8
$LN7@asString:

; 701  :    default:
; 702  :       JSON_ASSERT_UNREACHABLE;
; 703  :    }
; 704  :    return ""; // unreachable

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN10@asString:

; 705  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN17@asString:
	DD	$LN6@asString
	DD	$LN3@asString
	DD	$LN3@asString
	DD	$LN3@asString
	DD	$LN5@asString
	DD	$LN4@asString
	DD	$LN3@asString
	DD	$LN3@asString
?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Value::asString
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?asCString@Value@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?asCString@Value@Json@@QBEPBDXZ PROC			; Json::Value::asCString, COMDAT
; _this$ = ecx

; 678  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 679  :    JSON_ASSERT( type_ == stringValue );
; 680  :    return value_.string_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 681  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?asCString@Value@Json@@QBEPBDXZ ENDP			; Json::Value::asCString
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?compare@Value@Json@@QAEHABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?compare@Value@Json@@QAEHABV12@@Z PROC			; Json::Value::compare, COMDAT
; _this$ = ecx

; 536  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 537  :    /*
; 538  :    int typeDelta = other.type_ - type_;
; 539  :    switch ( type_ )
; 540  :    {
; 541  :    case nullValue:
; 542  : 
; 543  :       return other.type_ == type_;
; 544  :    case intValue:
; 545  :       if ( other.type_.isNumeric()
; 546  :    case uintValue:
; 547  :    case realValue:
; 548  :    case booleanValue:
; 549  :       break;
; 550  :    case stringValue,
; 551  :       break;
; 552  :    case arrayValue:
; 553  :       delete value_.array_;
; 554  :       break;
; 555  :    case objectValue:
; 556  :       delete value_.map_;
; 557  :    default:
; 558  :       JSON_ASSERT_UNREACHABLE;
; 559  :    }
; 560  :    */
; 561  :    return 0;  // unreachable

	xor	eax, eax

; 562  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?compare@Value@Json@@QAEHABV12@@Z ENDP			; Json::Value::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??9Value@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_other$ = 8						; size = 4
??9Value@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator!=, COMDAT
; _this$ = ecx

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 673  :    return !( *this == other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Value@Json@@QBE_NABV01@@Z		; Json::Value::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??9Value@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??8Value@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv155 = -56						; size = 4
_temp$ = -52						; size = 4
tv193 = -48						; size = 4
tv157 = -44						; size = 4
tv247 = -40						; size = 4
tv135 = -36						; size = 4
tv94 = -32						; size = 4
tv87 = -28						; size = 4
tv80 = -24						; size = 4
tv74 = -20						; size = 4
tv231 = -16						; size = 4
tv229 = -12						; size = 4
_this$ = -8						; size = 4
tv242 = -2						; size = 1
tv235 = -1						; size = 1
_other$ = 8						; size = 4
??8Value@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator==, COMDAT
; _this$ = ecx

; 628  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 629  :    //if ( type_ != other.type_ )
; 630  :    // GCC 2.95.3 says:
; 631  :    // attempt to take address of bit-field structure member `Json::Value::type_'
; 632  :    // Beats me, but a temp solves the problem.
; 633  :    int temp = other.type_;

	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR _temp$[ebp], ecx

; 634  :    if ( type_ != temp )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	cmp	eax, DWORD PTR _temp$[ebp]
	je	SHORT $LN11@operator

; 635  :       return false;

	xor	al, al
	jmp	$LN12@operator
$LN11@operator:

; 636  :    switch ( type_ )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 24					; 00000018H
	sar	edx, 24					; 00000018H
	mov	DWORD PTR tv74[ebp], edx
	cmp	DWORD PTR tv74[ebp], 7
	ja	$LN1@operator
	mov	eax, DWORD PTR tv74[ebp]
	jmp	DWORD PTR $LN31@operator[eax*4]
$LN8@operator:

; 637  :    {
; 638  :    case nullValue:
; 639  :       return true;

	mov	al, 1
	jmp	$LN12@operator
$LN7@operator:

; 640  :    case intValue:
; 641  :       return value_.int_ == other.value_.int_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN14@operator
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN15@operator
$LN14@operator:
	mov	DWORD PTR tv80[ebp], 0
$LN15@operator:
	mov	al, BYTE PTR tv80[ebp]
	jmp	$LN12@operator
$LN6@operator:

; 642  :    case uintValue:
; 643  :       return value_.uint_ == other.value_.uint_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN16@operator
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN17@operator
$LN16@operator:
	mov	DWORD PTR tv87[ebp], 0
$LN17@operator:
	mov	al, BYTE PTR tv87[ebp]
	jmp	$LN12@operator
$LN5@operator:

; 644  :    case realValue:
; 645  :       return value_.real_ == other.value_.real_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	ucomisd	xmm0, QWORD PTR [edx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@operator
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN19@operator
$LN18@operator:
	mov	DWORD PTR tv94[ebp], 0
$LN19@operator:
	mov	al, BYTE PTR tv94[ebp]
	jmp	$LN12@operator
$LN4@operator:

; 646  :    case booleanValue:
; 647  :       return value_.bool_ == other.value_.bool_;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _other$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN20@operator
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN21@operator
$LN20@operator:
	mov	DWORD PTR tv135[ebp], 0
$LN21@operator:
	mov	al, BYTE PTR tv135[ebp]
	jmp	$LN12@operator
$LN3@operator:

; 648  :    case stringValue:
; 649  :       return ( value_.string_ == other.value_.string_ )
; 650  :              || ( other.value_.string_  
; 651  :                   &&  value_.string_  
; 652  :                   && strcmp( value_.string_, other.value_.string_ ) == 0 );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN23@operator
	mov	ecx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN22@operator
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN22@operator
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv231[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv229[ebp], eax
$LL27@operator:
	mov	ecx, DWORD PTR tv229[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv235[ebp], dl
	mov	eax, DWORD PTR tv231[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN28@operator
	cmp	BYTE PTR tv235[ebp], 0
	je	SHORT $LN29@operator
	mov	ecx, DWORD PTR tv229[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv242[ebp], dl
	mov	eax, DWORD PTR tv231[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN28@operator
	add	DWORD PTR tv229[ebp], 2
	add	DWORD PTR tv231[ebp], 2
	cmp	BYTE PTR tv242[ebp], 0
	jne	SHORT $LL27@operator
$LN29@operator:
	mov	DWORD PTR tv247[ebp], 0
	jmp	SHORT $LN30@operator
$LN28@operator:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv247[ebp], ecx
$LN30@operator:
	mov	edx, DWORD PTR tv247[ebp]
	mov	DWORD PTR tv155[ebp], edx
	cmp	DWORD PTR tv155[ebp], 0
	je	SHORT $LN23@operator
$LN22@operator:
	mov	DWORD PTR tv157[ebp], 0
	jmp	SHORT $LN24@operator
$LN23@operator:
	mov	DWORD PTR tv157[ebp], 1
$LN24@operator:
	mov	al, BYTE PTR tv157[ebp]
	jmp	SHORT $LN12@operator
$LN2@operator:

; 653  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 654  :    case arrayValue:
; 655  :    case objectValue:
; 656  :       return value_.map_->size() == other.value_.map_->size()
; 657  :              && (*value_.map_) == (*other.value_.map_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	cmp	esi, eax
	jne	SHORT $LN25@operator
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@operator
	mov	DWORD PTR tv193[ebp], 1
	jmp	SHORT $LN26@operator
$LN25@operator:
	mov	DWORD PTR tv193[ebp], 0
$LN26@operator:
	mov	al, BYTE PTR tv193[ebp]
	jmp	SHORT $LN12@operator
$LN1@operator:

; 658  : #else
; 659  :    case arrayValue:
; 660  :       return value_.array_->compare( *(other.value_.array_) ) == 0;
; 661  :    case objectValue:
; 662  :       return value_.map_->compare( *(other.value_.map_) ) == 0;
; 663  : #endif
; 664  :    default:
; 665  :       JSON_ASSERT_UNREACHABLE;
; 666  :    }
; 667  :    return 0;  // unreachable

	xor	al, al
$LN12@operator:

; 668  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN31@operator:
	DD	$LN8@operator
	DD	$LN7@operator
	DD	$LN6@operator
	DD	$LN5@operator
	DD	$LN3@operator
	DD	$LN4@operator
	DD	$LN2@operator
	DD	$LN2@operator
??8Value@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??OValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??OValue@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator>, COMDAT
; _this$ = ecx

; 622  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 623  :    return other < *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _other$[ebp]
	call	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<

; 624  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??OValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??PValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_other$ = 8						; size = 4
??PValue@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator>=, COMDAT
; _this$ = ecx

; 616  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 617  :    return !(*this < other);

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??PValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??NValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_other$ = 8						; size = 4
??NValue@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator<=, COMDAT
; _this$ = ecx

; 610  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 611  :    return !(other > *this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _other$[ebp]
	call	??OValue@Json@@QBE_NABV01@@Z		; Json::Value::operator>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 612  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??NValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??MValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv159 = -60						; size = 4
tv182 = -56						; size = 4
_delta$1 = -52						; size = 4
tv161 = -48						; size = 4
tv248 = -44						; size = 4
tv138 = -40						; size = 4
tv129 = -36						; size = 4
tv90 = -32						; size = 4
tv83 = -28						; size = 4
tv77 = -24						; size = 4
_typeDelta$ = -20					; size = 4
tv232 = -16						; size = 4
tv230 = -12						; size = 4
_this$ = -8						; size = 4
tv243 = -3						; size = 1
tv236 = -2						; size = 1
tv73 = -1						; size = 1
_other$ = 8						; size = 4
??MValue@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator<, COMDAT
; _this$ = ecx

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 567  :    int typeDelta = type_ - other.type_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	sub	ecx, eax
	mov	DWORD PTR _typeDelta$[ebp], ecx

; 568  :    if ( typeDelta )

	je	SHORT $LN12@operator

; 569  :       return typeDelta < 0 ? true : false;

	cmp	DWORD PTR _typeDelta$[ebp], 0
	jge	SHORT $LN15@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN16@operator
$LN15@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN16@operator:
	mov	al, BYTE PTR tv73[ebp]
	jmp	$LN13@operator
$LN12@operator:

; 570  :    switch ( type_ )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 24					; 00000018H
	sar	edx, 24					; 00000018H
	mov	DWORD PTR tv77[ebp], edx
	cmp	DWORD PTR tv77[ebp], 7
	ja	$LN1@operator
	mov	eax, DWORD PTR tv77[ebp]
	jmp	DWORD PTR $LN35@operator[eax*4]
$LN9@operator:

; 571  :    {
; 572  :    case nullValue:
; 573  :       return false;

	xor	al, al
	jmp	$LN13@operator
$LN8@operator:

; 574  :    case intValue:
; 575  :       return value_.int_ < other.value_.int_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN17@operator
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN18@operator
$LN17@operator:
	mov	DWORD PTR tv83[ebp], 0
$LN18@operator:
	mov	al, BYTE PTR tv83[ebp]
	jmp	$LN13@operator
$LN7@operator:

; 576  :    case uintValue:
; 577  :       return value_.uint_ < other.value_.uint_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $LN19@operator
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN20@operator
$LN19@operator:
	mov	DWORD PTR tv90[ebp], 0
$LN20@operator:
	mov	al, BYTE PTR tv90[ebp]
	jmp	$LN13@operator
$LN6@operator:

; 578  :    case realValue:
; 579  :       return value_.real_ < other.value_.real_;

	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	comisd	xmm0, QWORD PTR [edx]
	jbe	SHORT $LN21@operator
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN22@operator
$LN21@operator:
	mov	DWORD PTR tv129[ebp], 0
$LN22@operator:
	mov	al, BYTE PTR tv129[ebp]
	jmp	$LN13@operator
$LN5@operator:

; 580  :    case booleanValue:
; 581  :       return value_.bool_ < other.value_.bool_;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _other$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jge	SHORT $LN23@operator
	mov	DWORD PTR tv138[ebp], 1
	jmp	SHORT $LN24@operator
$LN23@operator:
	mov	DWORD PTR tv138[ebp], 0
$LN24@operator:
	mov	al, BYTE PTR tv138[ebp]
	jmp	$LN13@operator
$LN4@operator:

; 582  :    case stringValue:
; 583  :       return ( value_.string_ == 0  &&  other.value_.string_ )
; 584  :              || ( other.value_.string_  
; 585  :                   &&  value_.string_  
; 586  :                   && strcmp( value_.string_, other.value_.string_ ) < 0 );

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN25@operator
	mov	edx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN27@operator
$LN25@operator:
	mov	eax, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN26@operator
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN26@operator
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv232[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv230[ebp], edx
$LL31@operator:
	mov	eax, DWORD PTR tv230[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv236[ebp], cl
	mov	edx, DWORD PTR tv232[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN32@operator
	cmp	BYTE PTR tv236[ebp], 0
	je	SHORT $LN33@operator
	mov	eax, DWORD PTR tv230[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv243[ebp], cl
	mov	edx, DWORD PTR tv232[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN32@operator
	add	DWORD PTR tv230[ebp], 2
	add	DWORD PTR tv232[ebp], 2
	cmp	BYTE PTR tv243[ebp], 0
	jne	SHORT $LL31@operator
$LN33@operator:
	mov	DWORD PTR tv248[ebp], 0
	jmp	SHORT $LN34@operator
$LN32@operator:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv248[ebp], eax
$LN34@operator:
	mov	ecx, DWORD PTR tv248[ebp]
	mov	DWORD PTR tv159[ebp], ecx
	cmp	DWORD PTR tv159[ebp], 0
	jl	SHORT $LN27@operator
$LN26@operator:
	mov	DWORD PTR tv161[ebp], 0
	jmp	SHORT $LN28@operator
$LN27@operator:
	mov	DWORD PTR tv161[ebp], 1
$LN28@operator:
	mov	al, BYTE PTR tv161[ebp]
	jmp	SHORT $LN13@operator
$LN3@operator:

; 587  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 588  :    case arrayValue:
; 589  :    case objectValue:
; 590  :       {
; 591  :          int delta = int( value_.map_->size() - other.value_.map_->size() );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	mov	esi, eax
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	sub	esi, eax
	mov	DWORD PTR _delta$1[ebp], esi

; 592  :          if ( delta )

	je	SHORT $LN2@operator

; 593  :             return delta < 0;

	cmp	DWORD PTR _delta$1[ebp], 0
	jge	SHORT $LN29@operator
	mov	DWORD PTR tv182[ebp], 1
	jmp	SHORT $LN30@operator
$LN29@operator:
	mov	DWORD PTR tv182[ebp], 0
$LN30@operator:
	mov	al, BYTE PTR tv182[ebp]
	jmp	SHORT $LN13@operator
$LN2@operator:

; 594  :          return (*value_.map_) < (*other.value_.map_);

	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	add	esp, 8
	jmp	SHORT $LN13@operator
$LN1@operator:

; 595  :       }
; 596  : #else
; 597  :    case arrayValue:
; 598  :       return value_.array_->compare( *(other.value_.array_) ) < 0;
; 599  :    case objectValue:
; 600  :       return value_.map_->compare( *(other.value_.map_) ) < 0;
; 601  : #endif
; 602  :    default:
; 603  :       JSON_ASSERT_UNREACHABLE;
; 604  :    }
; 605  :    return 0;  // unreachable

	xor	al, al
$LN13@operator:

; 606  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN35@operator:
	DD	$LN9@operator
	DD	$LN8@operator
	DD	$LN7@operator
	DD	$LN6@operator
	DD	$LN4@operator
	DD	$LN5@operator
	DD	$LN3@operator
	DD	$LN3@operator
??MValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?type@Value@Json@@QBE?AW4ValueType@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?type@Value@Json@@QBE?AW4ValueType@2@XZ PROC		; Json::Value::type, COMDAT
; _this$ = ecx

; 529  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 530  :    return type_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H

; 531  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?type@Value@Json@@QBE?AW4ValueType@2@XZ ENDP		; Json::Value::type
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?swap@Value@Json@@QAEXAAV12@@Z
_TEXT	SEGMENT
_temp2$ = -12						; size = 4
_temp$ = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?swap@Value@Json@@QAEXAAV12@@Z PROC			; Json::Value::swap, COMDAT
; _this$ = ecx

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 518  :    ValueType temp = type_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR _temp$[ebp], ecx

; 519  :    type_ = other.type_;

	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -256				; ffffff00H
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 520  :    other.type_ = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -256				; ffffff00H
	or	eax, ecx
	mov	ecx, DWORD PTR _other$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 521  :    std::swap( value_, other.value_ );

	mov	edx, DWORD PTR _other$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z ; std::swap<Json::Value::ValueHolder>
	add	esp, 8

; 522  :    int temp2 = allocated_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 23					; 00000017H
	sar	edx, 31					; 0000001fH
	mov	DWORD PTR _temp2$[ebp], edx

; 523  :    allocated_ = other.allocated_;

	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 23					; 00000017H
	sar	ecx, 31					; 0000001fH
	and	ecx, 1
	shl	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -257				; fffffeffH
	or	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 524  :    other.allocated_ = temp2;

	mov	edx, DWORD PTR _temp2$[ebp]
	and	edx, 1
	shl	edx, 8
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -257				; fffffeffH
	or	ecx, edx
	mov	edx, DWORD PTR _other$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 525  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?swap@Value@Json@@QAEXAAV12@@Z ENDP			; Json::Value::swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??4Value@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_temp$ = -36						; size = 16
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??4Value@Json@@QAEAAV01@ABV01@@Z PROC			; Json::Value::operator=, COMDAT
; _this$ = ecx

; 509  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4Value@Json@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 510  :    Value temp( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 511  :    swap( temp );

	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?swap@Value@Json@@QAEXAAV12@@Z		; Json::Value::swap

; 512  :    return *this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	eax, DWORD PTR $T2[ebp]

; 513  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4Value@Json@@QAEAAV01@ABV01@@Z$0:
	lea	ecx, DWORD PTR _temp$[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$??4Value@Json@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4Value@Json@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4Value@Json@@QAEAAV01@ABV01@@Z ENDP			; Json::Value::operator=
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??1Value@Json@@QAE@XZ
_TEXT	SEGMENT
tv130 = -36						; size = 4
$T1 = -32						; size = 4
tv87 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
tv75 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
??1Value@Json@@QAE@XZ PROC				; Json::Value::~Value, COMDAT
; _this$ = ecx

; 473  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 474  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 4
	je	SHORT $LN5@Value
	cmp	DWORD PTR tv67[ebp], 5
	jle	SHORT $LN7@Value
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@Value
	jmp	SHORT $LN7@Value

; 475  :    {
; 476  :    case nullValue:
; 477  :    case intValue:
; 478  :    case uintValue:
; 479  :    case realValue:
; 480  :    case booleanValue:
; 481  :       break;

	jmp	SHORT $LN7@Value
$LN5@Value:

; 482  :    case stringValue:
; 483  :       if ( allocated_ )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 23					; 00000017H
	sar	eax, 31					; 0000001fH
	test	eax, eax
	je	SHORT $LN4@Value

; 484  :          valueAllocator()->releaseStringValue( value_.string_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv75[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN4@Value:

; 485  :       break;

	jmp	SHORT $LN7@Value
$LN3@Value:

; 486  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 487  :    case arrayValue:
; 488  :    case objectValue:
; 489  :       delete value_.map_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN11@Value
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN7@Value
$LN11@Value:
	mov	DWORD PTR tv87[ebp], 0
$LN7@Value:

; 490  :       break;
; 491  : #else
; 492  :    case arrayValue:
; 493  :       arrayAllocator()->destructArray( value_.array_ );
; 494  :       break;
; 495  :    case objectValue:
; 496  :       mapAllocator()->destructMap( value_.map_ );
; 497  :       break;
; 498  : #endif
; 499  :    default:
; 500  :       JSON_ASSERT_UNREACHABLE;
; 501  :    }
; 502  : 
; 503  :    if ( comments_ )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN9@Value

; 504  :       delete[] comments_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN13@Value
	push	3
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_ECommentInfo@Value@Json@@QAEPAXI@Z
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN9@Value
$LN13@Value:
	mov	DWORD PTR tv130[ebp], 0
$LN9@Value:

; 505  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1Value@Json@@QAE@XZ ENDP				; Json::Value::~Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -56						; size = 4
$T3 = -52						; size = 4
_otherComment$4 = -48					; size = 4
tv161 = -44						; size = 4
tv145 = -40						; size = 4
$T5 = -36						; size = 4
tv88 = -32						; size = 4
tv76 = -28						; size = 4
$T6 = -24						; size = 4
_comment$7 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??0Value@Json@@QAE@ABV01@@Z PROC			; Json::Value::Value, COMDAT
; _this$ = ecx

; 424  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Value@Json@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -256				; ffffff00H
	or	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 425  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 7
	ja	$LN12@Value
	mov	edx, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN23@Value[edx*4]
$LN11@Value:

; 426  :    {
; 427  :    case nullValue:
; 428  :    case intValue:
; 429  :    case uintValue:
; 430  :    case realValue:
; 431  :    case booleanValue:
; 432  :       value_ = other.value_;

	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 433  :       break;

	jmp	$LN12@Value
$LN10@Value:

; 434  :    case stringValue:
; 435  :       if ( other.value_.string_ )

	mov	ecx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN9@Value

; 436  :       {
; 437  :          value_.string_ = valueAllocator()->duplicateStringValue( other.value_.string_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv88[ebp], edx
	push	-1
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR tv88[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 438  :          allocated_ = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 439  :       }
; 440  :       else

	jmp	SHORT $LN8@Value
$LN9@Value:

; 441  :          value_.string_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
$LN8@Value:

; 442  :       break;

	jmp	SHORT $LN12@Value
$LN7@Value:

; 443  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 444  :    case arrayValue:
; 445  :    case objectValue:
; 446  :       value_.map_ = new ObjectValues( *other.value_.map_ );

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN16@Value
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN17@Value
$LN16@Value:
	mov	DWORD PTR tv145[ebp], 0
$LN17@Value:
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax], ecx
$LN12@Value:

; 447  :       break;
; 448  : #else
; 449  :    case arrayValue:
; 450  :       value_.array_ = arrayAllocator()->newArrayCopy( *other.value_.array_ );
; 451  :       break;
; 452  :    case objectValue:
; 453  :       value_.map_ = mapAllocator()->newMapCopy( *other.value_.map_ );
; 454  :       break;
; 455  : #endif
; 456  :    default:
; 457  :       JSON_ASSERT_UNREACHABLE;
; 458  :    }
; 459  :    if ( other.comments_ )

	mov	edx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN14@Value

; 460  :    {
; 461  :       comments_ = new CommentInfo[numberOfCommentPlacement];

	push	16					; 00000010H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN18@Value
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR [eax], 3
	push	OFFSET ??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	push	OFFSET ??0CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::CommentInfo
	push	3
	push	4
	mov	ecx, DWORD PTR $T6[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T6[ebp]
	add	edx, 4
	mov	DWORD PTR tv161[ebp], edx
	jmp	SHORT $LN19@Value
$LN18@Value:
	mov	DWORD PTR tv161[ebp], 0
$LN19@Value:
	mov	eax, DWORD PTR tv161[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+12], edx

; 462  :       for ( int comment =0; comment < numberOfCommentPlacement; ++comment )

	mov	DWORD PTR _comment$7[ebp], 0
	jmp	SHORT $LN4@Value
$LN3@Value:
	mov	eax, DWORD PTR _comment$7[ebp]
	add	eax, 1
	mov	DWORD PTR _comment$7[ebp], eax
$LN4@Value:
	cmp	DWORD PTR _comment$7[ebp], 3
	jge	SHORT $LN14@Value

; 463  :       {
; 464  :          const CommentInfo &otherComment = other.comments_[comment];

	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _comment$7[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _otherComment$4[ebp], ecx

; 465  :          if ( otherComment.comment_ )

	mov	edx, DWORD PTR _otherComment$4[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN1@Value

; 466  :             comments_[comment].setComment( otherComment.comment_ );

	mov	eax, DWORD PTR _otherComment$4[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _comment$7[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	call	?setComment@CommentInfo@Value@Json@@QAEXPBD@Z ; Json::Value::CommentInfo::setComment
$LN1@Value:

; 467  :       }

	jmp	SHORT $LN3@Value
$LN14@Value:

; 468  :    }
; 469  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN23@Value:
	DD	$LN11@Value
	DD	$LN11@Value
	DD	$LN11@Value
	DD	$LN11@Value
	DD	$LN10@Value
	DD	$LN11@Value
	DD	$LN7@Value
	DD	$LN7@Value
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Value@Json@@QAE@ABV01@@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0Value@Json@@QAE@ABV01@@Z$1:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$??0Value@Json@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Value@Json@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Value@Json@@QAE@ABV01@@Z ENDP			; Json::Value::Value
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 1
??0Value@Json@@QAE@_N@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 413  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 414  :    value_.bool_ = value;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _value$[ebp]
	mov	BYTE PTR [ecx], dl

; 415  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@_N@Z ENDP				; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::Value, COMDAT
; _this$ = ecx

; 376  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 377  :    value_.string_ = valueAllocator()->duplicateStringValue( value.c_str(), 
; 378  :                                                             (unsigned int)value.length() );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv77[ebp], ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	edx, DWORD PTR tv77[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv77[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 379  : 
; 380  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@ABVStaticString@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@ABVStaticString@1@@Z PROC		; Json::Value::Value, COMDAT
; _this$ = ecx

; 389  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 390  :    value_.string_ = const_cast<char *>( value.c_str() );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?c_str@StaticString@Json@@QBEPBDXZ	; Json::StaticString::c_str
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 391  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@ABVStaticString@1@@Z ENDP		; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@PBD0@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
_beginValue$ = 8					; size = 4
_endValue$ = 12						; size = 4
??0Value@Json@@QAE@PBD0@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 364  :    value_.string_ = valueAllocator()->duplicateStringValue( beginValue, 
; 365  :                                                             UInt(endValue - beginValue) );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv77[ebp], ecx
	mov	edx, DWORD PTR _endValue$[ebp]
	sub	edx, DWORD PTR _beginValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _beginValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv77[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv77[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 366  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Value@Json@@QAE@PBD0@Z ENDP				; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@PBD@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@PBD@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 350  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 351  :    value_.string_ = valueAllocator()->duplicateStringValue( value );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv77[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR tv77[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv77[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 352  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@PBD@Z ENDP				; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 8
??0Value@Json@@QAE@N@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 339  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 340  :    value_.real_ = value;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _value$[ebp]
	movsd	QWORD PTR [ecx], xmm0

; 341  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Value@Json@@QAE@N@Z ENDP				; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@I@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 329  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 330  :    value_.uint_ = value;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], edx

; 331  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@I@Z ENDP				; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@H@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 318  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 319  :    value_.int_ = value;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], edx

; 320  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@H@Z ENDP				; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@W4ValueType@1@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
tv89 = -28						; size = 4
$T3 = -24						; size = 4
tv73 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
??0Value@Json@@QAE@W4ValueType@1@@Z PROC		; Json::Value::Value, COMDAT
; _this$ = ecx

; 275  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Value@Json@@QAE@W4ValueType@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _type$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -256				; ffffff00H
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -257				; fffffeffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 276  :    switch ( type )

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv73[ebp], edx
	mov	eax, DWORD PTR tv73[ebp]
	sub	eax, 1
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 6
	ja	SHORT $LN1@Value
	mov	ecx, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN16@Value[ecx*4]

; 277  :    {
; 278  :    case nullValue:
; 279  :       break;

	jmp	SHORT $LN8@Value
$LN6@Value:

; 280  :    case intValue:
; 281  :    case uintValue:
; 282  :       value_.int_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 283  :       break;

	jmp	SHORT $LN8@Value
$LN5@Value:

; 284  :    case realValue:
; 285  :       value_.real_ = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [eax], xmm0

; 286  :       break;

	jmp	SHORT $LN8@Value
$LN4@Value:

; 287  :    case stringValue:
; 288  :       value_.string_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 289  :       break;

	jmp	SHORT $LN8@Value
$LN3@Value:

; 290  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 291  :    case arrayValue:
; 292  :    case objectValue:
; 293  :       value_.map_ = new ObjectValues();

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN12@Value
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN13@Value
$LN12@Value:
	mov	DWORD PTR tv89[ebp], 0
$LN13@Value:
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax], ecx

; 294  :       break;

	jmp	SHORT $LN8@Value
$LN2@Value:

; 295  : #else
; 296  :    case arrayValue:
; 297  :       value_.array_ = arrayAllocator()->newArray();
; 298  :       break;
; 299  :    case objectValue:
; 300  :       value_.map_ = mapAllocator()->newMap();
; 301  :       break;
; 302  : #endif
; 303  :    case booleanValue:
; 304  :       value_.bool_ = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx], 0
$LN1@Value:
$LN8@Value:

; 305  :       break;
; 306  :    default:
; 307  :       JSON_ASSERT_UNREACHABLE;
; 308  :    }
; 309  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN16@Value:
	DD	$LN6@Value
	DD	$LN6@Value
	DD	$LN5@Value
	DD	$LN4@Value
	DD	$LN2@Value
	DD	$LN3@Value
	DD	$LN3@Value
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Value@Json@@QAE@W4ValueType@1@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0Value@Json@@QAE@W4ValueType@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Value@Json@@QAE@W4ValueType@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Value@Json@@QAE@W4ValueType@1@@Z ENDP		; Json::Value::Value
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?swap@CZString@Value@Json@@AAEXAAV123@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?swap@CZString@Value@Json@@AAEXAAV123@@Z PROC		; Json::Value::CZString::swap, COMDAT
; _this$ = ecx

; 204  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 205  :    std::swap( cstr_, other.cstr_ );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$swap@PBD@std@@YAXAAPBD0@Z		; std::swap<char const *>
	add	esp, 8

; 206  :    std::swap( index_, other.index_ );

	mov	edx, DWORD PTR _other$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	??$swap@H@std@@YAXAAH0@Z		; std::swap<int>
	add	esp, 8

; 207  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?swap@CZString@Value@Json@@AAEXAAV123@@Z ENDP		; Json::Value::CZString::swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?isStaticString@CZString@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?isStaticString@CZString@Value@Json@@QBE_NXZ PROC	; Json::Value::CZString::isStaticString, COMDAT
; _this$ = ecx

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 250  :    return index_ == noDuplication;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@isStaticSt
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@isStaticSt
$LN3@isStaticSt:
	mov	DWORD PTR tv66[ebp], 0
$LN4@isStaticSt:
	mov	al, BYTE PTR tv66[ebp]

; 251  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isStaticString@CZString@Value@Json@@QBE_NXZ ENDP	; Json::Value::CZString::isStaticString
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?c_str@CZString@Value@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@CZString@Value@Json@@QBEPBDXZ PROC		; Json::Value::CZString::c_str, COMDAT
; _this$ = ecx

; 243  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  :    return cstr_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 245  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@CZString@Value@Json@@QBEPBDXZ ENDP		; Json::Value::CZString::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?index@CZString@Value@Json@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?index@CZString@Value@Json@@QBEHXZ PROC			; Json::Value::CZString::index, COMDAT
; _this$ = ecx

; 236  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  :    return index_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 238  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?index@CZString@Value@Json@@QBEHXZ ENDP			; Json::Value::CZString::index
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??8CZString@Value@Json@@QBE_NABV012@@Z
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv78 = -28						; size = 4
tv73 = -24						; size = 4
tv133 = -20						; size = 4
_this$ = -16						; size = 4
tv85 = -12						; size = 4
tv83 = -8						; size = 4
tv128 = -2						; size = 1
tv89 = -1						; size = 1
_other$ = 8						; size = 4
??8CZString@Value@Json@@QBE_NABV012@@Z PROC		; Json::Value::CZString::operator==, COMDAT
; _this$ = ecx

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 228  :    if ( cstr_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator

; 229  :       return strcmp( cstr_, other.cstr_ ) == 0;

	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv85[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv83[ebp], ecx
$LL8@operator:
	mov	edx, DWORD PTR tv83[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv89[ebp], al
	mov	ecx, DWORD PTR tv85[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN9@operator
	cmp	BYTE PTR tv89[ebp], 0
	je	SHORT $LN10@operator
	mov	edx, DWORD PTR tv83[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv128[ebp], al
	mov	ecx, DWORD PTR tv85[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN9@operator
	add	DWORD PTR tv83[ebp], 2
	add	DWORD PTR tv85[ebp], 2
	cmp	BYTE PTR tv128[ebp], 0
	jne	SHORT $LL8@operator
$LN10@operator:
	mov	DWORD PTR tv133[ebp], 0
	jmp	SHORT $LN11@operator
$LN9@operator:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv133[ebp], edx
$LN11@operator:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv71[ebp], eax
	cmp	DWORD PTR tv71[ebp], 0
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv73[ebp], 0
$LN5@operator:
	mov	al, BYTE PTR tv73[ebp]
	jmp	SHORT $LN2@operator
$LN1@operator:

; 230  :    return index_ == other.index_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN6@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN7@operator
$LN6@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN7@operator:
	mov	al, BYTE PTR tv78[ebp]
$LN2@operator:

; 231  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??8CZString@Value@Json@@QBE_NABV012@@Z ENDP		; Json::Value::CZString::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??MCZString@Value@Json@@QBE_NABV012@@Z
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv78 = -28						; size = 4
tv73 = -24						; size = 4
tv133 = -20						; size = 4
_this$ = -16						; size = 4
tv85 = -12						; size = 4
tv83 = -8						; size = 4
tv128 = -2						; size = 1
tv89 = -1						; size = 1
_other$ = 8						; size = 4
??MCZString@Value@Json@@QBE_NABV012@@Z PROC		; Json::Value::CZString::operator<, COMDAT
; _this$ = ecx

; 219  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 220  :    if ( cstr_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator

; 221  :       return strcmp( cstr_, other.cstr_ ) < 0;

	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv85[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv83[ebp], ecx
$LL8@operator:
	mov	edx, DWORD PTR tv83[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv89[ebp], al
	mov	ecx, DWORD PTR tv85[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN9@operator
	cmp	BYTE PTR tv89[ebp], 0
	je	SHORT $LN10@operator
	mov	edx, DWORD PTR tv83[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv128[ebp], al
	mov	ecx, DWORD PTR tv85[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN9@operator
	add	DWORD PTR tv83[ebp], 2
	add	DWORD PTR tv85[ebp], 2
	cmp	BYTE PTR tv128[ebp], 0
	jne	SHORT $LL8@operator
$LN10@operator:
	mov	DWORD PTR tv133[ebp], 0
	jmp	SHORT $LN11@operator
$LN9@operator:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv133[ebp], edx
$LN11@operator:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv71[ebp], eax
	cmp	DWORD PTR tv71[ebp], 0
	jge	SHORT $LN4@operator
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv73[ebp], 0
$LN5@operator:
	mov	al, BYTE PTR tv73[ebp]
	jmp	SHORT $LN2@operator
$LN1@operator:

; 222  :    return index_ < other.index_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $LN6@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN7@operator
$LN6@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN7@operator:
	mov	al, BYTE PTR tv78[ebp]
$LN2@operator:

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??MCZString@Value@Json@@QBE_NABV012@@Z ENDP		; Json::Value::CZString::operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_temp$ = -28						; size = 8
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??4CZString@Value@Json@@QAEAAV012@ABV012@@Z PROC	; Json::Value::CZString::operator=, COMDAT
; _this$ = ecx

; 211  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 212  :    CZString temp( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 213  :    swap( temp );

	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?swap@CZString@Value@Json@@AAEXAAV123@@Z ; Json::Value::CZString::swap

; 214  :    return *this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T2[ebp]

; 215  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z$0:
	lea	ecx, DWORD PTR _temp$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4CZString@Value@Json@@QAEAAV012@ABV012@@Z ENDP	; Json::Value::CZString::operator=
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??1CZString@Value@Json@@QAE@XZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
??1CZString@Value@Json@@QAE@XZ PROC			; Json::Value::CZString::~CZString, COMDAT
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 198  :    if ( cstr_  &&  index_ == duplicate )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@CZString
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN2@CZString

; 199  :       valueAllocator()->releaseMemberName( const_cast<char *>( cstr_ ) );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv71[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR tv71[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv71[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN2@CZString:

; 200  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CZString@Value@Json@@QAE@XZ ENDP			; Json::Value::CZString::~CZString
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0CZString@Value@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
tv84 = -16						; size = 4
tv79 = -12						; size = 4
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??0CZString@Value@Json@@QAE@ABV012@@Z PROC		; Json::Value::CZString::CZString, COMDAT
; _this$ = ecx

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@CZString
	mov	ecx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@CZString
	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN4@CZString
$LN3@CZString:
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv79[ebp], ecx
$LN4@CZString:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN7@CZString
	mov	edx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN5@CZString
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN6@CZString
$LN5@CZString:
	mov	DWORD PTR tv84[ebp], 1
$LN6@CZString:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN8@CZString
$LN7@CZString:
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv87[ebp], edx
$LN8@CZString:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR [eax+4], ecx

; 194  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CZString@Value@Json@@QAE@ABV012@@Z ENDP		; Json::Value::CZString::CZString
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_cstr$ = 8						; size = 4
_allocate$ = 12						; size = 4
??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z PROC ; Json::Value::CZString::CZString, COMDAT
; _this$ = ecx

; 184  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _allocate$[ebp], 1
	jne	SHORT $LN3@CZString
	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR _cstr$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv69[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv69[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@CZString
$LN3@CZString:
	mov	eax, DWORD PTR _cstr$[ebp]
	mov	DWORD PTR tv74[ebp], eax
$LN4@CZString:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocate$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 185  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ENDP ; Json::Value::CZString::CZString
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0CZString@Value@Json@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??0CZString@Value@Json@@QAE@H@Z PROC			; Json::Value::CZString::CZString, COMDAT
; _this$ = ecx

; 177  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 178  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CZString@Value@Json@@QAE@H@Z ENDP			; Json::Value::CZString::CZString
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\include\json\value.h
;	COMDAT ?c_str@StaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@StaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::c_str, COMDAT
; _this$ = ecx

; 76   :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   :          return str_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 78   :       }

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@StaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\include\json\value.h
;	COMDAT ??BStaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BStaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::operator char const *, COMDAT
; _this$ = ecx

; 71   :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   :          return str_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 73   :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??BStaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::operator char const *
_TEXT	ENDS
; Function compile flags: /Odtp
; File h:\source\hg\client\code_core\jsoncpp-src-0.5.0\include\json\value.h
;	COMDAT ??0StaticString@Json@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_czstring$ = 8						; size = 4
??0StaticString@Json@@QAE@PBD@Z PROC			; Json::StaticString::StaticString, COMDAT
; _this$ = ecx

; 67   :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _czstring$[ebp]
	mov	DWORD PTR [eax], ecx

; 68   :       }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0StaticString@Json@@QAE@PBD@Z ENDP			; Json::StaticString::StaticString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 49   : 	_Ignore()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		{	// construct
; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@H@std@@YAXAAH0@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@H@std@@YAXAAH0@Z PROC				; std::swap<int>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	??$_Move@AAH@std@@YA$$QAHAAH@Z		; std::_Move<int &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 53   : 	_Left = _Move(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	call	??$_Move@AAH@std@@YA$$QAHAAH@Z		; std::_Move<int &>
	add	esp, 4
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 54   : 	_Right = _Move(_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	call	??$_Move@AAH@std@@YA$$QAHAAH@Z		; std::_Move<int &>
	add	esp, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 55   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@H@std@@YAXAAH0@Z ENDP				; std::swap<int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 615  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 616  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 617  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 618  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	DWORD PTR __imp_?_Winerror_map@std@@YAPBDH@Z
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 610  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 602  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 585  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 586  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 587  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 589  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 579  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 580  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 566  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 558  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 355  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 337  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 332  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 333  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 334  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 300  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 246  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 241  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 243  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 178  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 393  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 386  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 379  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 652  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 653  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 642  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 643  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 178  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@

; 179  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2294 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN2@Xran:

; 2296 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2289 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN2@Xlen:

; 2291 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2273 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2279 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2285 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2286 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2260 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2261 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2262 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2243 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2244 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2251 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2253 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2238 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2203 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2210 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2211 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2216 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2218 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2222 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2223 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2224 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2229 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2231 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2232 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2233 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1758 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1761 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1753 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1755 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1748 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1749 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1750 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1738 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1739 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1343 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1344 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1345 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1347 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1352 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1353 : 			}
; 1354 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1355 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1335 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1336 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1337 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1338 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1339 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1170 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1157 : 
; 1158 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1161 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1162 : 			}
; 1163 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1164 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1130 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1131 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1132 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1133 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1134 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1135 : 
; 1136 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1138 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1142 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1143 : 			}
; 1144 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 990  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 992  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 935  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jae	SHORT $LN2@Assign_rv

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 939  : 		else

	jmp	SHORT $LN1@Assign_rv
$LN2@Assign_rv:

; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 942  : 			_Right._Bx._Ptr = pointer();

	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [edx], 0
$LN1@Assign_rv:

; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 945  : 		this->_Myres = _Right._Myres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 946  : 		_Right._Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 947  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 887  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 888  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 890  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 859  : 		{	// construct from [_First, _Last), const pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 862  : 		if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN2@basic_stri

; 863  : 			assign(&*_First, _Last - _First);

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@basic_stri:

; 864  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 781  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 782  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 738  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 739  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 740  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 724  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 725  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 726  : 		assign(_Right, 0, npos);

	mov	edx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	edx
	push	0
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 727  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 684  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 630  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 517  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 521  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 510  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 514  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 492  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 495  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 496  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 806  : 		{	// construct by copying base

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 807  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ PROC ; std::allocator<char>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ENDP ; std::allocator<char>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 58   : 		{	// get owning container

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 		return (0);

	xor	eax, eax

; 60   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 54   : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv75 = -16						; size = 4
tv69 = -12						; size = 4
tv72 = -8						; size = 4
tv78 = -1						; size = 1
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR tv72[ebp]
	add	eax, 1
	mov	DWORD PTR tv75[ebp], eax
$LL5@length:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv78[ebp], dl
	add	DWORD PTR tv72[ebp], 1
	cmp	BYTE PTR tv78[ebp], 0
	jne	SHORT $LL5@length
	mov	eax, DWORD PTR tv72[ebp]
	sub	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv69[ebp], ecx
$LN4@length:
	mov	eax, DWORD PTR tv69[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp

; 557  :     return _hypot(_X, _Y);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Y$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp___hypot
	add	esp, 16					; 00000010H

; 558  : }

	pop	ebp
	ret	0
_hypot	ENDP
_TEXT	ENDS
END
