// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: up.proto

#ifndef PROTOBUF_up_2eproto__INCLUDED
#define PROTOBUF_up_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace up {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_up_2eproto();
void protobuf_AssignDesc_up_2eproto();
void protobuf_ShutdownFile_up_2eproto();

class up_msg;
class request_upgrade_arousal_level;
class continue_pay;
class recharge_rebate;
class every_day_happy;
class system_setting;
class system_setting_change;
class system_setting_request;
class push_notify;
class login;
class sdk_login;
class request_userinfo;
class enter_stage;
class exit_stage;
class gm_cmd;
class activity_info;
class activity_lotto_info;
class activity_bigpackage_info;
class activity_bigpackage_reward_info;
class activity_bigpackage_reset;
class activity_lotto_reward;
class open_all_guild_stage;
class set_money;
class hero_upgrade;
class equip_synthesis;
class wear_equip;
class sync_vitality;
class buy_vitality;
class consume_item;
class shop_refresh;
class shop_consume;
class skill_levelup;
class sell_item;
class fragment_compose;
class hero_equip_upgrade;
class hero_equip;
class hero;
class hero_arousal;
class tutorial;
class trigger_task;
class require_rewards;
class change_task_status;
class trigger_job;
class job_rewards;
class suspend_report;
class reset_elite;
class sweep_stage;
class buy_skill_stren_point;
class ask_magicsoul;
class tavern_draw;
class hero_evolve;
class enter_act_stage;
class ladder;
class open_panel;
class apply_opponent;
class start_battle;
class end_battle;
class set_lineup;
class query_records;
class query_replay;
class sync_skill_stren;
class query_rankboard;
class query_oppo_info;
class clear_battle_cd;
class draw_rank_reward;
class buy_battle_chance;
class set_name;
class set_avatar;
class query_data;
class midas;
class open_shop;
class charge;
class ask_daily_login;
class tbc;
class tbc_open_panel;
class tbc_query_oppo;
class tbc_start_battle;
class tbc_hero;
class tbc_end_battle;
class tbc_reset;
class tbc_draw_reward;
class get_maillist;
class read_mail;
class get_svr_time;
class get_vip_gift;
class chat;
class chat_broad_say;
class chat_fetch_bl;
class chat_say;
class chat_acc;
class chat_fresh;
class chat_fetch;
class chat_add_bl;
class chat_del_bl;
class guild;
class guild_set_jump;
class guild_stage_rank;
class guild_query_member;
class guild_prepare_instance;
class guild_app_queue;
class guild_jump;
class guild_items_history;
class guild_drop_give;
class guild_instance_damage;
class guild_drop_info;
class guild_instance_apply;
class guild_instance_start;
class guild_instance_end;
class guild_instance_drop;
class guild_instance_open;
class guild_instance_query;
class guild_instance_detail;
class guild_create;
class guild_dismiss;
class guild_list;
class guild_search;
class guild_join;
class guild_join_confirm;
class guild_leave;
class guild_kick;
class guild_set;
class guild_query;
class guild_open_pannel;
class guild_set_job;
class guild_add_hire;
class guild_del_hire;
class guild_query_hires;
class guild_hire_hero;
class guild_worship_req;
class guild_worship_withdraw;
class guild_qurey_hh_detail;
class ask_activity_info;
class cdkey_gift;
class excavate;
class search_excavate;
class query_excavate_data;
class query_excavate_history;
class query_excavate_battle;
class set_excavate_team;
class excavate_start_battle;
class excavate_end_battle;
class query_excavate_def;
class clear_excavate_battle;
class withdraw_excavate_hero;
class draw_excavate_def_rwd;
class drop_excavate;
class excavate_hero;
class query_split_data;
class query_split_return;
class split_hero;
class worldcup;
class worldcup_query;
class worldcup_submit;
class report_battle;
class query_ranklist;
class dot_info;
class require_arousal;
class change_server;
class request_guild_log;
class query_act_stage;
class fb_attention;

enum system_setting_change_setting_status {
  system_setting_change_setting_status_on = 1,
  system_setting_change_setting_status_off = 2
};
bool system_setting_change_setting_status_IsValid(int value);
const system_setting_change_setting_status system_setting_change_setting_status_setting_status_MIN = system_setting_change_setting_status_on;
const system_setting_change_setting_status system_setting_change_setting_status_setting_status_MAX = system_setting_change_setting_status_off;
const int system_setting_change_setting_status_setting_status_ARRAYSIZE = system_setting_change_setting_status_setting_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* system_setting_change_setting_status_descriptor();
inline const ::std::string& system_setting_change_setting_status_Name(system_setting_change_setting_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    system_setting_change_setting_status_descriptor(), value);
}
inline bool system_setting_change_setting_status_Parse(
    const ::std::string& name, system_setting_change_setting_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<system_setting_change_setting_status>(
    system_setting_change_setting_status_descriptor(), name, value);
}
enum set_money_price_type {
  set_money_price_type_gold = 0,
  set_money_price_type_diamond = 1,
  set_money_price_type_crusadepoint = 2,
  set_money_price_type_arenapoint = 3,
  set_money_price_type_guildpoint = 4
};
bool set_money_price_type_IsValid(int value);
const set_money_price_type set_money_price_type_price_type_MIN = set_money_price_type_gold;
const set_money_price_type set_money_price_type_price_type_MAX = set_money_price_type_guildpoint;
const int set_money_price_type_price_type_ARRAYSIZE = set_money_price_type_price_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* set_money_price_type_descriptor();
inline const ::std::string& set_money_price_type_Name(set_money_price_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    set_money_price_type_descriptor(), value);
}
inline bool set_money_price_type_Parse(
    const ::std::string& name, set_money_price_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<set_money_price_type>(
    set_money_price_type_descriptor(), name, value);
}
enum shop_refresh_rtype {
  shop_refresh_rtype_sync = 0,
  shop_refresh_rtype_auto_refresh = 1,
  shop_refresh_rtype_manual_refresh = 2
};
bool shop_refresh_rtype_IsValid(int value);
const shop_refresh_rtype shop_refresh_rtype_rtype_MIN = shop_refresh_rtype_sync;
const shop_refresh_rtype shop_refresh_rtype_rtype_MAX = shop_refresh_rtype_manual_refresh;
const int shop_refresh_rtype_rtype_ARRAYSIZE = shop_refresh_rtype_rtype_MAX + 1;

const ::google::protobuf::EnumDescriptor* shop_refresh_rtype_descriptor();
inline const ::std::string& shop_refresh_rtype_Name(shop_refresh_rtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    shop_refresh_rtype_descriptor(), value);
}
inline bool shop_refresh_rtype_Parse(
    const ::std::string& name, shop_refresh_rtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<shop_refresh_rtype>(
    shop_refresh_rtype_descriptor(), name, value);
}
enum hero_equip_upgrade_OP_TYPE {
  hero_equip_upgrade_OP_TYPE_normal = 1,
  hero_equip_upgrade_OP_TYPE_boss = 2
};
bool hero_equip_upgrade_OP_TYPE_IsValid(int value);
const hero_equip_upgrade_OP_TYPE hero_equip_upgrade_OP_TYPE_OP_TYPE_MIN = hero_equip_upgrade_OP_TYPE_normal;
const hero_equip_upgrade_OP_TYPE hero_equip_upgrade_OP_TYPE_OP_TYPE_MAX = hero_equip_upgrade_OP_TYPE_boss;
const int hero_equip_upgrade_OP_TYPE_OP_TYPE_ARRAYSIZE = hero_equip_upgrade_OP_TYPE_OP_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* hero_equip_upgrade_OP_TYPE_descriptor();
inline const ::std::string& hero_equip_upgrade_OP_TYPE_Name(hero_equip_upgrade_OP_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    hero_equip_upgrade_OP_TYPE_descriptor(), value);
}
inline bool hero_equip_upgrade_OP_TYPE_Parse(
    const ::std::string& name, hero_equip_upgrade_OP_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<hero_equip_upgrade_OP_TYPE>(
    hero_equip_upgrade_OP_TYPE_descriptor(), name, value);
}
enum reset_elite_rtype {
  reset_elite_rtype_daily_free = 0,
  reset_elite_rtype_vip_reset = 1
};
bool reset_elite_rtype_IsValid(int value);
const reset_elite_rtype reset_elite_rtype_rtype_MIN = reset_elite_rtype_daily_free;
const reset_elite_rtype reset_elite_rtype_rtype_MAX = reset_elite_rtype_vip_reset;
const int reset_elite_rtype_rtype_ARRAYSIZE = reset_elite_rtype_rtype_MAX + 1;

const ::google::protobuf::EnumDescriptor* reset_elite_rtype_descriptor();
inline const ::std::string& reset_elite_rtype_Name(reset_elite_rtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    reset_elite_rtype_descriptor(), value);
}
inline bool reset_elite_rtype_Parse(
    const ::std::string& name, reset_elite_rtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reset_elite_rtype>(
    reset_elite_rtype_descriptor(), name, value);
}
enum sweep_stage_rtype {
  sweep_stage_rtype_sweep_with_ticket = 0,
  sweep_stage_rtype_sweep_with_rmb = 1
};
bool sweep_stage_rtype_IsValid(int value);
const sweep_stage_rtype sweep_stage_rtype_rtype_MIN = sweep_stage_rtype_sweep_with_ticket;
const sweep_stage_rtype sweep_stage_rtype_rtype_MAX = sweep_stage_rtype_sweep_with_rmb;
const int sweep_stage_rtype_rtype_ARRAYSIZE = sweep_stage_rtype_rtype_MAX + 1;

const ::google::protobuf::EnumDescriptor* sweep_stage_rtype_descriptor();
inline const ::std::string& sweep_stage_rtype_Name(sweep_stage_rtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    sweep_stage_rtype_descriptor(), value);
}
inline bool sweep_stage_rtype_Parse(
    const ::std::string& name, sweep_stage_rtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<sweep_stage_rtype>(
    sweep_stage_rtype_descriptor(), name, value);
}
enum tavern_draw_draw_type {
  tavern_draw_draw_type_single = 0,
  tavern_draw_draw_type_combo = 1,
  tavern_draw_draw_type_stone = 3,
  tavern_draw_draw_type_free = 4
};
bool tavern_draw_draw_type_IsValid(int value);
const tavern_draw_draw_type tavern_draw_draw_type_draw_type_MIN = tavern_draw_draw_type_single;
const tavern_draw_draw_type tavern_draw_draw_type_draw_type_MAX = tavern_draw_draw_type_free;
const int tavern_draw_draw_type_draw_type_ARRAYSIZE = tavern_draw_draw_type_draw_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* tavern_draw_draw_type_descriptor();
inline const ::std::string& tavern_draw_draw_type_Name(tavern_draw_draw_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    tavern_draw_draw_type_descriptor(), value);
}
inline bool tavern_draw_draw_type_Parse(
    const ::std::string& name, tavern_draw_draw_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<tavern_draw_draw_type>(
    tavern_draw_draw_type_descriptor(), name, value);
}
enum tavern_draw_box_type {
  tavern_draw_box_type_green = 1,
  tavern_draw_box_type_blue = 2,
  tavern_draw_box_type_purple = 3,
  tavern_draw_box_type_magicsoul = 4,
  tavern_draw_box_type_stone_green = 5,
  tavern_draw_box_type_stone_blue = 6,
  tavern_draw_box_type_stone_purple = 7
};
bool tavern_draw_box_type_IsValid(int value);
const tavern_draw_box_type tavern_draw_box_type_box_type_MIN = tavern_draw_box_type_green;
const tavern_draw_box_type tavern_draw_box_type_box_type_MAX = tavern_draw_box_type_stone_purple;
const int tavern_draw_box_type_box_type_ARRAYSIZE = tavern_draw_box_type_box_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* tavern_draw_box_type_descriptor();
inline const ::std::string& tavern_draw_box_type_Name(tavern_draw_box_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    tavern_draw_box_type_descriptor(), value);
}
inline bool tavern_draw_box_type_Parse(
    const ::std::string& name, tavern_draw_box_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<tavern_draw_box_type>(
    tavern_draw_box_type_descriptor(), name, value);
}
enum query_rankboard_rankboard_type {
  query_rankboard_rankboard_type_static_c = 0,
  query_rankboard_rankboard_type_dynamic = 1
};
bool query_rankboard_rankboard_type_IsValid(int value);
const query_rankboard_rankboard_type query_rankboard_rankboard_type_rankboard_type_MIN = query_rankboard_rankboard_type_static_c;
const query_rankboard_rankboard_type query_rankboard_rankboard_type_rankboard_type_MAX = query_rankboard_rankboard_type_dynamic;
const int query_rankboard_rankboard_type_rankboard_type_ARRAYSIZE = query_rankboard_rankboard_type_rankboard_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* query_rankboard_rankboard_type_descriptor();
inline const ::std::string& query_rankboard_rankboard_type_Name(query_rankboard_rankboard_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    query_rankboard_rankboard_type_descriptor(), value);
}
inline bool query_rankboard_rankboard_type_Parse(
    const ::std::string& name, query_rankboard_rankboard_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<query_rankboard_rankboard_type>(
    query_rankboard_rankboard_type_descriptor(), name, value);
}
enum set_name_set_type {
  set_name_set_type_free = 0,
  set_name_set_type_rmb = 1
};
bool set_name_set_type_IsValid(int value);
const set_name_set_type set_name_set_type_set_type_MIN = set_name_set_type_free;
const set_name_set_type set_name_set_type_set_type_MAX = set_name_set_type_rmb;
const int set_name_set_type_set_type_ARRAYSIZE = set_name_set_type_set_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* set_name_set_type_descriptor();
inline const ::std::string& set_name_set_type_Name(set_name_set_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    set_name_set_type_descriptor(), value);
}
inline bool set_name_set_type_Parse(
    const ::std::string& name, set_name_set_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<set_name_set_type>(
    set_name_set_type_descriptor(), name, value);
}
enum query_data_query_type {
  query_data_query_type_rmb = 1,
  query_data_query_type_hero = 2,
  query_data_query_type_recharge = 3,
  query_data_query_type_monthcard = 4
};
bool query_data_query_type_IsValid(int value);
const query_data_query_type query_data_query_type_query_type_MIN = query_data_query_type_rmb;
const query_data_query_type query_data_query_type_query_type_MAX = query_data_query_type_monthcard;
const int query_data_query_type_query_type_ARRAYSIZE = query_data_query_type_query_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* query_data_query_type_descriptor();
inline const ::std::string& query_data_query_type_Name(query_data_query_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    query_data_query_type_descriptor(), value);
}
inline bool query_data_query_type_Parse(
    const ::std::string& name, query_data_query_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<query_data_query_type>(
    query_data_query_type_descriptor(), name, value);
}
enum ask_daily_login_status {
  ask_daily_login_status_all = 1,
  ask_daily_login_status_common = 2,
  ask_daily_login_status_vip = 3
};
bool ask_daily_login_status_IsValid(int value);
const ask_daily_login_status ask_daily_login_status_status_MIN = ask_daily_login_status_all;
const ask_daily_login_status ask_daily_login_status_status_MAX = ask_daily_login_status_vip;
const int ask_daily_login_status_status_ARRAYSIZE = ask_daily_login_status_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* ask_daily_login_status_descriptor();
inline const ::std::string& ask_daily_login_status_Name(ask_daily_login_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    ask_daily_login_status_descriptor(), value);
}
inline bool ask_daily_login_status_Parse(
    const ::std::string& name, ask_daily_login_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ask_daily_login_status>(
    ask_daily_login_status_descriptor(), name, value);
}
enum chat_acc_chat_acc_t {
  chat_acc_chat_acc_t_binary = 1,
  chat_acc_chat_acc_t_pvp_replay = 2
};
bool chat_acc_chat_acc_t_IsValid(int value);
const chat_acc_chat_acc_t chat_acc_chat_acc_t_chat_acc_t_MIN = chat_acc_chat_acc_t_binary;
const chat_acc_chat_acc_t chat_acc_chat_acc_t_chat_acc_t_MAX = chat_acc_chat_acc_t_pvp_replay;
const int chat_acc_chat_acc_t_chat_acc_t_ARRAYSIZE = chat_acc_chat_acc_t_chat_acc_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* chat_acc_chat_acc_t_descriptor();
inline const ::std::string& chat_acc_chat_acc_t_Name(chat_acc_chat_acc_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    chat_acc_chat_acc_t_descriptor(), value);
}
inline bool chat_acc_chat_acc_t_Parse(
    const ::std::string& name, chat_acc_chat_acc_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<chat_acc_chat_acc_t>(
    chat_acc_chat_acc_t_descriptor(), name, value);
}
enum guild_set_jump_is_can_jump {
  guild_set_jump_is_can_jump__true = 1,
  guild_set_jump_is_can_jump__false = 2
};
bool guild_set_jump_is_can_jump_IsValid(int value);
const guild_set_jump_is_can_jump guild_set_jump_is_can_jump_is_can_jump_MIN = guild_set_jump_is_can_jump__true;
const guild_set_jump_is_can_jump guild_set_jump_is_can_jump_is_can_jump_MAX = guild_set_jump_is_can_jump__false;
const int guild_set_jump_is_can_jump_is_can_jump_ARRAYSIZE = guild_set_jump_is_can_jump_is_can_jump_MAX + 1;

const ::google::protobuf::EnumDescriptor* guild_set_jump_is_can_jump_descriptor();
inline const ::std::string& guild_set_jump_is_can_jump_Name(guild_set_jump_is_can_jump value) {
  return ::google::protobuf::internal::NameOfEnum(
    guild_set_jump_is_can_jump_descriptor(), value);
}
inline bool guild_set_jump_is_can_jump_Parse(
    const ::std::string& name, guild_set_jump_is_can_jump* value) {
  return ::google::protobuf::internal::ParseNamedEnum<guild_set_jump_is_can_jump>(
    guild_set_jump_is_can_jump_descriptor(), name, value);
}
enum guild_join_confirm_confirm_type {
  guild_join_confirm_confirm_type_accept = 1,
  guild_join_confirm_confirm_type_reject = 2
};
bool guild_join_confirm_confirm_type_IsValid(int value);
const guild_join_confirm_confirm_type guild_join_confirm_confirm_type_confirm_type_MIN = guild_join_confirm_confirm_type_accept;
const guild_join_confirm_confirm_type guild_join_confirm_confirm_type_confirm_type_MAX = guild_join_confirm_confirm_type_reject;
const int guild_join_confirm_confirm_type_confirm_type_ARRAYSIZE = guild_join_confirm_confirm_type_confirm_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* guild_join_confirm_confirm_type_descriptor();
inline const ::std::string& guild_join_confirm_confirm_type_Name(guild_join_confirm_confirm_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    guild_join_confirm_confirm_type_descriptor(), value);
}
inline bool guild_join_confirm_confirm_type_Parse(
    const ::std::string& name, guild_join_confirm_confirm_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<guild_join_confirm_confirm_type>(
    guild_join_confirm_confirm_type_descriptor(), name, value);
}
enum guild_set_guild_join_t {
  guild_set_guild_join_t_no_verify = 1,
  guild_set_guild_join_t_verify = 2,
  guild_set_guild_join_t_closed = 3
};
bool guild_set_guild_join_t_IsValid(int value);
const guild_set_guild_join_t guild_set_guild_join_t_guild_join_t_MIN = guild_set_guild_join_t_no_verify;
const guild_set_guild_join_t guild_set_guild_join_t_guild_join_t_MAX = guild_set_guild_join_t_closed;
const int guild_set_guild_join_t_guild_join_t_ARRAYSIZE = guild_set_guild_join_t_guild_join_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* guild_set_guild_join_t_descriptor();
inline const ::std::string& guild_set_guild_join_t_Name(guild_set_guild_join_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    guild_set_guild_join_t_descriptor(), value);
}
inline bool guild_set_guild_join_t_Parse(
    const ::std::string& name, guild_set_guild_join_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<guild_set_guild_join_t>(
    guild_set_guild_join_t_descriptor(), name, value);
}
enum query_ranklist_rank_type {
  query_ranklist_rank_type_guildliveness = 1,
  query_ranklist_rank_type_excavate_rob = 2,
  query_ranklist_rank_type_excavate_gold = 3,
  query_ranklist_rank_type_excavate_exp = 4,
  query_ranklist_rank_type_top_gs = 5,
  query_ranklist_rank_type_full_hero_gs = 6,
  query_ranklist_rank_type_hero_team_gs = 7,
  query_ranklist_rank_type_hero_evo_star = 8,
  query_ranklist_rank_type_hero_arousal = 9,
  query_ranklist_rank_type_top_arena = 10
};
bool query_ranklist_rank_type_IsValid(int value);
const query_ranklist_rank_type query_ranklist_rank_type_rank_type_MIN = query_ranklist_rank_type_guildliveness;
const query_ranklist_rank_type query_ranklist_rank_type_rank_type_MAX = query_ranklist_rank_type_top_arena;
const int query_ranklist_rank_type_rank_type_ARRAYSIZE = query_ranklist_rank_type_rank_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* query_ranklist_rank_type_descriptor();
inline const ::std::string& query_ranklist_rank_type_Name(query_ranklist_rank_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    query_ranklist_rank_type_descriptor(), value);
}
inline bool query_ranklist_rank_type_Parse(
    const ::std::string& name, query_ranklist_rank_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<query_ranklist_rank_type>(
    query_ranklist_rank_type_descriptor(), name, value);
}
enum require_arousal_arousal_type {
  require_arousal_arousal_type__require_arousal = 0,
  require_arousal_arousal_type_apply_arousal = 1
};
bool require_arousal_arousal_type_IsValid(int value);
const require_arousal_arousal_type require_arousal_arousal_type_arousal_type_MIN = require_arousal_arousal_type__require_arousal;
const require_arousal_arousal_type require_arousal_arousal_type_arousal_type_MAX = require_arousal_arousal_type_apply_arousal;
const int require_arousal_arousal_type_arousal_type_ARRAYSIZE = require_arousal_arousal_type_arousal_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* require_arousal_arousal_type_descriptor();
inline const ::std::string& require_arousal_arousal_type_Name(require_arousal_arousal_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    require_arousal_arousal_type_descriptor(), value);
}
inline bool require_arousal_arousal_type_Parse(
    const ::std::string& name, require_arousal_arousal_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<require_arousal_arousal_type>(
    require_arousal_arousal_type_descriptor(), name, value);
}
enum hero_status {
  idle = 0,
  hire = 1,
  mining = 2
};
bool hero_status_IsValid(int value);
const hero_status hero_status_MIN = idle;
const hero_status hero_status_MAX = mining;
const int hero_status_ARRAYSIZE = hero_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* hero_status_descriptor();
inline const ::std::string& hero_status_Name(hero_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    hero_status_descriptor(), value);
}
inline bool hero_status_Parse(
    const ::std::string& name, hero_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<hero_status>(
    hero_status_descriptor(), name, value);
}
enum guild_job_t {
  chairman = 1,
  member = 2,
  elder = 3
};
bool guild_job_t_IsValid(int value);
const guild_job_t guild_job_t_MIN = chairman;
const guild_job_t guild_job_t_MAX = elder;
const int guild_job_t_ARRAYSIZE = guild_job_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* guild_job_t_descriptor();
inline const ::std::string& guild_job_t_Name(guild_job_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    guild_job_t_descriptor(), value);
}
inline bool guild_job_t_Parse(
    const ::std::string& name, guild_job_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<guild_job_t>(
    guild_job_t_descriptor(), name, value);
}
enum hire_from {
  hire_from_guild = 0,
  hire_from_tbc = 1,
  stage = 2,
  excav = 3
};
bool hire_from_IsValid(int value);
const hire_from hire_from_MIN = hire_from_guild;
const hire_from hire_from_MAX = excav;
const int hire_from_ARRAYSIZE = hire_from_MAX + 1;

const ::google::protobuf::EnumDescriptor* hire_from_descriptor();
inline const ::std::string& hire_from_Name(hire_from value) {
  return ::google::protobuf::internal::NameOfEnum(
    hire_from_descriptor(), value);
}
inline bool hire_from_Parse(
    const ::std::string& name, hire_from* value) {
  return ::google::protobuf::internal::ParseNamedEnum<hire_from>(
    hire_from_descriptor(), name, value);
}
enum chat_channel {
  world_channel = 1,
  guild_channel = 2,
  personal_channel = 3
};
bool chat_channel_IsValid(int value);
const chat_channel chat_channel_MIN = world_channel;
const chat_channel chat_channel_MAX = personal_channel;
const int chat_channel_ARRAYSIZE = chat_channel_MAX + 1;

const ::google::protobuf::EnumDescriptor* chat_channel_descriptor();
inline const ::std::string& chat_channel_Name(chat_channel value) {
  return ::google::protobuf::internal::NameOfEnum(
    chat_channel_descriptor(), value);
}
inline bool chat_channel_Parse(
    const ::std::string& name, chat_channel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<chat_channel>(
    chat_channel_descriptor(), name, value);
}
enum server_opt_type {
  get = 0,
  change = 1
};
bool server_opt_type_IsValid(int value);
const server_opt_type server_opt_type_MIN = get;
const server_opt_type server_opt_type_MAX = change;
const int server_opt_type_ARRAYSIZE = server_opt_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* server_opt_type_descriptor();
inline const ::std::string& server_opt_type_Name(server_opt_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    server_opt_type_descriptor(), value);
}
inline bool server_opt_type_Parse(
    const ::std::string& name, server_opt_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<server_opt_type>(
    server_opt_type_descriptor(), name, value);
}
enum platform_type {
  self = 0,
  s91 = 1,
  tbt = 2,
  pp = 3,
  lemon = 4,
  itools = 5,
  kuaiyong = 6,
  tuyoo = 7,
  lemonyueyu = 8,
  ky_android = 101,
  xm_android = 102,
  lemon_android = 103,
  s360_android = 104,
  uc_android = 105,
  duoku_android = 106,
  s91_android = 107,
  wandoujia_android = 108,
  pps_android = 109,
  dangle_android = 110,
  oppo_android = 111,
  anzhi_android = 112,
  s37wan_android = 113,
  huawei_android = 114,
  lianxiang_android = 115,
  pptv_android = 116,
  vivo_android = 117
};
bool platform_type_IsValid(int value);
const platform_type platform_type_MIN = self;
const platform_type platform_type_MAX = vivo_android;
const int platform_type_ARRAYSIZE = platform_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* platform_type_descriptor();
inline const ::std::string& platform_type_Name(platform_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    platform_type_descriptor(), value);
}
inline bool platform_type_Parse(
    const ::std::string& name, platform_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<platform_type>(
    platform_type_descriptor(), name, value);
}
enum battle_result {
  victory = 0,
  defeat = 1,
  canceled = 2,
  timeout = 3
};
bool battle_result_IsValid(int value);
const battle_result battle_result_MIN = victory;
const battle_result battle_result_MAX = timeout;
const int battle_result_ARRAYSIZE = battle_result_MAX + 1;

const ::google::protobuf::EnumDescriptor* battle_result_descriptor();
inline const ::std::string& battle_result_Name(battle_result value) {
  return ::google::protobuf::internal::NameOfEnum(
    battle_result_descriptor(), value);
}
inline bool battle_result_Parse(
    const ::std::string& name, battle_result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<battle_result>(
    battle_result_descriptor(), name, value);
}
// ===================================================================

class up_msg : public ::google::protobuf::Message {
 public:
  up_msg();
  virtual ~up_msg();

  up_msg(const up_msg& from);

  inline up_msg& operator=(const up_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const up_msg& default_instance();

  void Swap(up_msg* other);

  // implements Message ----------------------------------------------

  up_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const up_msg& from);
  void MergeFrom(const up_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _repeat = 1;
  inline bool has__repeat() const;
  inline void clear__repeat();
  static const int kRepeatFieldNumber = 1;
  inline ::google::protobuf::uint32 _repeat() const;
  inline void set__repeat(::google::protobuf::uint32 value);

  // optional uint32 _user_id = 2;
  inline bool has__user_id() const;
  inline void clear__user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _user_id() const;
  inline void set__user_id(::google::protobuf::uint32 value);

  // optional .up.login _login = 3;
  inline bool has__login() const;
  inline void clear__login();
  static const int kLoginFieldNumber = 3;
  inline const ::up::login& _login() const;
  inline ::up::login* mutable__login();
  inline ::up::login* release__login();
  inline void set_allocated__login(::up::login* _login);

  // optional .up.request_userinfo _request_userinfo = 4;
  inline bool has__request_userinfo() const;
  inline void clear__request_userinfo();
  static const int kRequestUserinfoFieldNumber = 4;
  inline const ::up::request_userinfo& _request_userinfo() const;
  inline ::up::request_userinfo* mutable__request_userinfo();
  inline ::up::request_userinfo* release__request_userinfo();
  inline void set_allocated__request_userinfo(::up::request_userinfo* _request_userinfo);

  // optional .up.enter_stage _enter_stage = 5;
  inline bool has__enter_stage() const;
  inline void clear__enter_stage();
  static const int kEnterStageFieldNumber = 5;
  inline const ::up::enter_stage& _enter_stage() const;
  inline ::up::enter_stage* mutable__enter_stage();
  inline ::up::enter_stage* release__enter_stage();
  inline void set_allocated__enter_stage(::up::enter_stage* _enter_stage);

  // optional .up.exit_stage _exit_stage = 6;
  inline bool has__exit_stage() const;
  inline void clear__exit_stage();
  static const int kExitStageFieldNumber = 6;
  inline const ::up::exit_stage& _exit_stage() const;
  inline ::up::exit_stage* mutable__exit_stage();
  inline ::up::exit_stage* release__exit_stage();
  inline void set_allocated__exit_stage(::up::exit_stage* _exit_stage);

  // optional .up.gm_cmd _gm_cmd = 7;
  inline bool has__gm_cmd() const;
  inline void clear__gm_cmd();
  static const int kGmCmdFieldNumber = 7;
  inline const ::up::gm_cmd& _gm_cmd() const;
  inline ::up::gm_cmd* mutable__gm_cmd();
  inline ::up::gm_cmd* release__gm_cmd();
  inline void set_allocated__gm_cmd(::up::gm_cmd* _gm_cmd);

  // optional .up.hero_upgrade _hero_upgrade = 8;
  inline bool has__hero_upgrade() const;
  inline void clear__hero_upgrade();
  static const int kHeroUpgradeFieldNumber = 8;
  inline const ::up::hero_upgrade& _hero_upgrade() const;
  inline ::up::hero_upgrade* mutable__hero_upgrade();
  inline ::up::hero_upgrade* release__hero_upgrade();
  inline void set_allocated__hero_upgrade(::up::hero_upgrade* _hero_upgrade);

  // optional .up.equip_synthesis _equip_synthesis = 9;
  inline bool has__equip_synthesis() const;
  inline void clear__equip_synthesis();
  static const int kEquipSynthesisFieldNumber = 9;
  inline const ::up::equip_synthesis& _equip_synthesis() const;
  inline ::up::equip_synthesis* mutable__equip_synthesis();
  inline ::up::equip_synthesis* release__equip_synthesis();
  inline void set_allocated__equip_synthesis(::up::equip_synthesis* _equip_synthesis);

  // optional .up.wear_equip _wear_equip = 10;
  inline bool has__wear_equip() const;
  inline void clear__wear_equip();
  static const int kWearEquipFieldNumber = 10;
  inline const ::up::wear_equip& _wear_equip() const;
  inline ::up::wear_equip* mutable__wear_equip();
  inline ::up::wear_equip* release__wear_equip();
  inline void set_allocated__wear_equip(::up::wear_equip* _wear_equip);

  // optional .up.consume_item _consume_item = 11;
  inline bool has__consume_item() const;
  inline void clear__consume_item();
  static const int kConsumeItemFieldNumber = 11;
  inline const ::up::consume_item& _consume_item() const;
  inline ::up::consume_item* mutable__consume_item();
  inline ::up::consume_item* release__consume_item();
  inline void set_allocated__consume_item(::up::consume_item* _consume_item);

  // optional .up.shop_refresh _shop_refresh = 12;
  inline bool has__shop_refresh() const;
  inline void clear__shop_refresh();
  static const int kShopRefreshFieldNumber = 12;
  inline const ::up::shop_refresh& _shop_refresh() const;
  inline ::up::shop_refresh* mutable__shop_refresh();
  inline ::up::shop_refresh* release__shop_refresh();
  inline void set_allocated__shop_refresh(::up::shop_refresh* _shop_refresh);

  // optional .up.shop_consume _shop_consume = 13;
  inline bool has__shop_consume() const;
  inline void clear__shop_consume();
  static const int kShopConsumeFieldNumber = 13;
  inline const ::up::shop_consume& _shop_consume() const;
  inline ::up::shop_consume* mutable__shop_consume();
  inline ::up::shop_consume* release__shop_consume();
  inline void set_allocated__shop_consume(::up::shop_consume* _shop_consume);

  // optional .up.skill_levelup _skill_levelup = 14;
  inline bool has__skill_levelup() const;
  inline void clear__skill_levelup();
  static const int kSkillLevelupFieldNumber = 14;
  inline const ::up::skill_levelup& _skill_levelup() const;
  inline ::up::skill_levelup* mutable__skill_levelup();
  inline ::up::skill_levelup* release__skill_levelup();
  inline void set_allocated__skill_levelup(::up::skill_levelup* _skill_levelup);

  // optional .up.sell_item _sell_item = 15;
  inline bool has__sell_item() const;
  inline void clear__sell_item();
  static const int kSellItemFieldNumber = 15;
  inline const ::up::sell_item& _sell_item() const;
  inline ::up::sell_item* mutable__sell_item();
  inline ::up::sell_item* release__sell_item();
  inline void set_allocated__sell_item(::up::sell_item* _sell_item);

  // optional .up.fragment_compose _fragment_compose = 16;
  inline bool has__fragment_compose() const;
  inline void clear__fragment_compose();
  static const int kFragmentComposeFieldNumber = 16;
  inline const ::up::fragment_compose& _fragment_compose() const;
  inline ::up::fragment_compose* mutable__fragment_compose();
  inline ::up::fragment_compose* release__fragment_compose();
  inline void set_allocated__fragment_compose(::up::fragment_compose* _fragment_compose);

  // optional .up.hero_equip_upgrade _hero_equip_upgrade = 17;
  inline bool has__hero_equip_upgrade() const;
  inline void clear__hero_equip_upgrade();
  static const int kHeroEquipUpgradeFieldNumber = 17;
  inline const ::up::hero_equip_upgrade& _hero_equip_upgrade() const;
  inline ::up::hero_equip_upgrade* mutable__hero_equip_upgrade();
  inline ::up::hero_equip_upgrade* release__hero_equip_upgrade();
  inline void set_allocated__hero_equip_upgrade(::up::hero_equip_upgrade* _hero_equip_upgrade);

  // optional .up.trigger_task _trigger_task = 18;
  inline bool has__trigger_task() const;
  inline void clear__trigger_task();
  static const int kTriggerTaskFieldNumber = 18;
  inline const ::up::trigger_task& _trigger_task() const;
  inline ::up::trigger_task* mutable__trigger_task();
  inline ::up::trigger_task* release__trigger_task();
  inline void set_allocated__trigger_task(::up::trigger_task* _trigger_task);

  // optional .up.require_rewards _require_rewards = 19;
  inline bool has__require_rewards() const;
  inline void clear__require_rewards();
  static const int kRequireRewardsFieldNumber = 19;
  inline const ::up::require_rewards& _require_rewards() const;
  inline ::up::require_rewards* mutable__require_rewards();
  inline ::up::require_rewards* release__require_rewards();
  inline void set_allocated__require_rewards(::up::require_rewards* _require_rewards);

  // optional .up.trigger_job _trigger_job = 20;
  inline bool has__trigger_job() const;
  inline void clear__trigger_job();
  static const int kTriggerJobFieldNumber = 20;
  inline const ::up::trigger_job& _trigger_job() const;
  inline ::up::trigger_job* mutable__trigger_job();
  inline ::up::trigger_job* release__trigger_job();
  inline void set_allocated__trigger_job(::up::trigger_job* _trigger_job);

  // optional .up.job_rewards _job_rewards = 21;
  inline bool has__job_rewards() const;
  inline void clear__job_rewards();
  static const int kJobRewardsFieldNumber = 21;
  inline const ::up::job_rewards& _job_rewards() const;
  inline ::up::job_rewards* mutable__job_rewards();
  inline ::up::job_rewards* release__job_rewards();
  inline void set_allocated__job_rewards(::up::job_rewards* _job_rewards);

  // optional .up.reset_elite _reset_elite = 22;
  inline bool has__reset_elite() const;
  inline void clear__reset_elite();
  static const int kResetEliteFieldNumber = 22;
  inline const ::up::reset_elite& _reset_elite() const;
  inline ::up::reset_elite* mutable__reset_elite();
  inline ::up::reset_elite* release__reset_elite();
  inline void set_allocated__reset_elite(::up::reset_elite* _reset_elite);

  // optional .up.sweep_stage _sweep_stage = 23;
  inline bool has__sweep_stage() const;
  inline void clear__sweep_stage();
  static const int kSweepStageFieldNumber = 23;
  inline const ::up::sweep_stage& _sweep_stage() const;
  inline ::up::sweep_stage* mutable__sweep_stage();
  inline ::up::sweep_stage* release__sweep_stage();
  inline void set_allocated__sweep_stage(::up::sweep_stage* _sweep_stage);

  // optional .up.buy_vitality _buy_vitality = 24;
  inline bool has__buy_vitality() const;
  inline void clear__buy_vitality();
  static const int kBuyVitalityFieldNumber = 24;
  inline const ::up::buy_vitality& _buy_vitality() const;
  inline ::up::buy_vitality* mutable__buy_vitality();
  inline ::up::buy_vitality* release__buy_vitality();
  inline void set_allocated__buy_vitality(::up::buy_vitality* _buy_vitality);

  // optional .up.buy_skill_stren_point _buy_skill_stren_point = 25;
  inline bool has__buy_skill_stren_point() const;
  inline void clear__buy_skill_stren_point();
  static const int kBuySkillStrenPointFieldNumber = 25;
  inline const ::up::buy_skill_stren_point& _buy_skill_stren_point() const;
  inline ::up::buy_skill_stren_point* mutable__buy_skill_stren_point();
  inline ::up::buy_skill_stren_point* release__buy_skill_stren_point();
  inline void set_allocated__buy_skill_stren_point(::up::buy_skill_stren_point* _buy_skill_stren_point);

  // optional .up.tavern_draw _tavern_draw = 26;
  inline bool has__tavern_draw() const;
  inline void clear__tavern_draw();
  static const int kTavernDrawFieldNumber = 26;
  inline const ::up::tavern_draw& _tavern_draw() const;
  inline ::up::tavern_draw* mutable__tavern_draw();
  inline ::up::tavern_draw* release__tavern_draw();
  inline void set_allocated__tavern_draw(::up::tavern_draw* _tavern_draw);

  // optional .up.query_data _query_data = 27;
  inline bool has__query_data() const;
  inline void clear__query_data();
  static const int kQueryDataFieldNumber = 27;
  inline const ::up::query_data& _query_data() const;
  inline ::up::query_data* mutable__query_data();
  inline ::up::query_data* release__query_data();
  inline void set_allocated__query_data(::up::query_data* _query_data);

  // optional .up.hero_evolve _hero_evolve = 28;
  inline bool has__hero_evolve() const;
  inline void clear__hero_evolve();
  static const int kHeroEvolveFieldNumber = 28;
  inline const ::up::hero_evolve& _hero_evolve() const;
  inline ::up::hero_evolve* mutable__hero_evolve();
  inline ::up::hero_evolve* release__hero_evolve();
  inline void set_allocated__hero_evolve(::up::hero_evolve* _hero_evolve);

  // optional .up.enter_act_stage _enter_act_stage = 29;
  inline bool has__enter_act_stage() const;
  inline void clear__enter_act_stage();
  static const int kEnterActStageFieldNumber = 29;
  inline const ::up::enter_act_stage& _enter_act_stage() const;
  inline ::up::enter_act_stage* mutable__enter_act_stage();
  inline ::up::enter_act_stage* release__enter_act_stage();
  inline void set_allocated__enter_act_stage(::up::enter_act_stage* _enter_act_stage);

  // optional .up.sync_vitality _sync_vitality = 30;
  inline bool has__sync_vitality() const;
  inline void clear__sync_vitality();
  static const int kSyncVitalityFieldNumber = 30;
  inline const ::up::sync_vitality& _sync_vitality() const;
  inline ::up::sync_vitality* mutable__sync_vitality();
  inline ::up::sync_vitality* release__sync_vitality();
  inline void set_allocated__sync_vitality(::up::sync_vitality* _sync_vitality);

  // optional .up.suspend_report _suspend_report = 31;
  inline bool has__suspend_report() const;
  inline void clear__suspend_report();
  static const int kSuspendReportFieldNumber = 31;
  inline const ::up::suspend_report& _suspend_report() const;
  inline ::up::suspend_report* mutable__suspend_report();
  inline ::up::suspend_report* release__suspend_report();
  inline void set_allocated__suspend_report(::up::suspend_report* _suspend_report);

  // optional .up.tutorial _tutorial = 32;
  inline bool has__tutorial() const;
  inline void clear__tutorial();
  static const int kTutorialFieldNumber = 32;
  inline const ::up::tutorial& _tutorial() const;
  inline ::up::tutorial* mutable__tutorial();
  inline ::up::tutorial* release__tutorial();
  inline void set_allocated__tutorial(::up::tutorial* _tutorial);

  // optional .up.ladder _ladder = 33;
  inline bool has__ladder() const;
  inline void clear__ladder();
  static const int kLadderFieldNumber = 33;
  inline const ::up::ladder& _ladder() const;
  inline ::up::ladder* mutable__ladder();
  inline ::up::ladder* release__ladder();
  inline void set_allocated__ladder(::up::ladder* _ladder);

  // optional .up.set_name _set_name = 34;
  inline bool has__set_name() const;
  inline void clear__set_name();
  static const int kSetNameFieldNumber = 34;
  inline const ::up::set_name& _set_name() const;
  inline ::up::set_name* mutable__set_name();
  inline ::up::set_name* release__set_name();
  inline void set_allocated__set_name(::up::set_name* _set_name);

  // optional .up.midas _midas = 35;
  inline bool has__midas() const;
  inline void clear__midas();
  static const int kMidasFieldNumber = 35;
  inline const ::up::midas& _midas() const;
  inline ::up::midas* mutable__midas();
  inline ::up::midas* release__midas();
  inline void set_allocated__midas(::up::midas* _midas);

  // optional .up.open_shop _open_shop = 36;
  inline bool has__open_shop() const;
  inline void clear__open_shop();
  static const int kOpenShopFieldNumber = 36;
  inline const ::up::open_shop& _open_shop() const;
  inline ::up::open_shop* mutable__open_shop();
  inline ::up::open_shop* release__open_shop();
  inline void set_allocated__open_shop(::up::open_shop* _open_shop);

  // optional .up.charge _charge = 37;
  inline bool has__charge() const;
  inline void clear__charge();
  static const int kChargeFieldNumber = 37;
  inline const ::up::charge& _charge() const;
  inline ::up::charge* mutable__charge();
  inline ::up::charge* release__charge();
  inline void set_allocated__charge(::up::charge* _charge);

  // optional .up.sdk_login _sdk_login = 38;
  inline bool has__sdk_login() const;
  inline void clear__sdk_login();
  static const int kSdkLoginFieldNumber = 38;
  inline const ::up::sdk_login& _sdk_login() const;
  inline ::up::sdk_login* mutable__sdk_login();
  inline ::up::sdk_login* release__sdk_login();
  inline void set_allocated__sdk_login(::up::sdk_login* _sdk_login);

  // optional .up.set_avatar _set_avatar = 39;
  inline bool has__set_avatar() const;
  inline void clear__set_avatar();
  static const int kSetAvatarFieldNumber = 39;
  inline const ::up::set_avatar& _set_avatar() const;
  inline ::up::set_avatar* mutable__set_avatar();
  inline ::up::set_avatar* release__set_avatar();
  inline void set_allocated__set_avatar(::up::set_avatar* _set_avatar);

  // optional .up.ask_daily_login _ask_daily_login = 40;
  inline bool has__ask_daily_login() const;
  inline void clear__ask_daily_login();
  static const int kAskDailyLoginFieldNumber = 40;
  inline const ::up::ask_daily_login& _ask_daily_login() const;
  inline ::up::ask_daily_login* mutable__ask_daily_login();
  inline ::up::ask_daily_login* release__ask_daily_login();
  inline void set_allocated__ask_daily_login(::up::ask_daily_login* _ask_daily_login);

  // optional .up.tbc _tbc = 41;
  inline bool has__tbc() const;
  inline void clear__tbc();
  static const int kTbcFieldNumber = 41;
  inline const ::up::tbc& _tbc() const;
  inline ::up::tbc* mutable__tbc();
  inline ::up::tbc* release__tbc();
  inline void set_allocated__tbc(::up::tbc* _tbc);

  // optional .up.get_maillist _get_maillist = 42;
  inline bool has__get_maillist() const;
  inline void clear__get_maillist();
  static const int kGetMaillistFieldNumber = 42;
  inline const ::up::get_maillist& _get_maillist() const;
  inline ::up::get_maillist* mutable__get_maillist();
  inline ::up::get_maillist* release__get_maillist();
  inline void set_allocated__get_maillist(::up::get_maillist* _get_maillist);

  // optional .up.read_mail _read_mail = 43;
  inline bool has__read_mail() const;
  inline void clear__read_mail();
  static const int kReadMailFieldNumber = 43;
  inline const ::up::read_mail& _read_mail() const;
  inline ::up::read_mail* mutable__read_mail();
  inline ::up::read_mail* release__read_mail();
  inline void set_allocated__read_mail(::up::read_mail* _read_mail);

  // optional .up.get_svr_time _get_svr_time = 44;
  inline bool has__get_svr_time() const;
  inline void clear__get_svr_time();
  static const int kGetSvrTimeFieldNumber = 44;
  inline const ::up::get_svr_time& _get_svr_time() const;
  inline ::up::get_svr_time* mutable__get_svr_time();
  inline ::up::get_svr_time* release__get_svr_time();
  inline void set_allocated__get_svr_time(::up::get_svr_time* _get_svr_time);

  // optional .up.get_vip_gift _get_vip_gift = 45;
  inline bool has__get_vip_gift() const;
  inline void clear__get_vip_gift();
  static const int kGetVipGiftFieldNumber = 45;
  inline const ::up::get_vip_gift& _get_vip_gift() const;
  inline ::up::get_vip_gift* mutable__get_vip_gift();
  inline ::up::get_vip_gift* release__get_vip_gift();
  inline void set_allocated__get_vip_gift(::up::get_vip_gift* _get_vip_gift);

  // optional string _important_data_md5 = 46;
  inline bool has__important_data_md5() const;
  inline void clear__important_data_md5();
  static const int kImportantDataMd5FieldNumber = 46;
  inline const ::std::string& _important_data_md5() const;
  inline void set__important_data_md5(const ::std::string& value);
  inline void set__important_data_md5(const char* value);
  inline void set__important_data_md5(const char* value, size_t size);
  inline ::std::string* mutable__important_data_md5();
  inline ::std::string* release__important_data_md5();
  inline void set_allocated__important_data_md5(::std::string* _important_data_md5);

  // optional .up.chat _chat = 47;
  inline bool has__chat() const;
  inline void clear__chat();
  static const int kChatFieldNumber = 47;
  inline const ::up::chat& _chat() const;
  inline ::up::chat* mutable__chat();
  inline ::up::chat* release__chat();
  inline void set_allocated__chat(::up::chat* _chat);

  // optional .up.cdkey_gift _cdkey_gift = 48;
  inline bool has__cdkey_gift() const;
  inline void clear__cdkey_gift();
  static const int kCdkeyGiftFieldNumber = 48;
  inline const ::up::cdkey_gift& _cdkey_gift() const;
  inline ::up::cdkey_gift* mutable__cdkey_gift();
  inline ::up::cdkey_gift* release__cdkey_gift();
  inline void set_allocated__cdkey_gift(::up::cdkey_gift* _cdkey_gift);

  // optional .up.guild _guild = 49;
  inline bool has__guild() const;
  inline void clear__guild();
  static const int kGuildFieldNumber = 49;
  inline const ::up::guild& _guild() const;
  inline ::up::guild* mutable__guild();
  inline ::up::guild* release__guild();
  inline void set_allocated__guild(::up::guild* _guild);

  // optional .up.ask_magicsoul _ask_magicsoul = 50;
  inline bool has__ask_magicsoul() const;
  inline void clear__ask_magicsoul();
  static const int kAskMagicsoulFieldNumber = 50;
  inline const ::up::ask_magicsoul& _ask_magicsoul() const;
  inline ::up::ask_magicsoul* mutable__ask_magicsoul();
  inline ::up::ask_magicsoul* release__ask_magicsoul();
  inline void set_allocated__ask_magicsoul(::up::ask_magicsoul* _ask_magicsoul);

  // optional .up.ask_activity_info _ask_activity_info = 51;
  inline bool has__ask_activity_info() const;
  inline void clear__ask_activity_info();
  static const int kAskActivityInfoFieldNumber = 51;
  inline const ::up::ask_activity_info& _ask_activity_info() const;
  inline ::up::ask_activity_info* mutable__ask_activity_info();
  inline ::up::ask_activity_info* release__ask_activity_info();
  inline void set_allocated__ask_activity_info(::up::ask_activity_info* _ask_activity_info);

  // optional .up.excavate _excavate = 52;
  inline bool has__excavate() const;
  inline void clear__excavate();
  static const int kExcavateFieldNumber = 52;
  inline const ::up::excavate& _excavate() const;
  inline ::up::excavate* mutable__excavate();
  inline ::up::excavate* release__excavate();
  inline void set_allocated__excavate(::up::excavate* _excavate);

  // optional .up.push_notify _push_notify = 53;
  inline bool has__push_notify() const;
  inline void clear__push_notify();
  static const int kPushNotifyFieldNumber = 53;
  inline const ::up::push_notify& _push_notify() const;
  inline ::up::push_notify* mutable__push_notify();
  inline ::up::push_notify* release__push_notify();
  inline void set_allocated__push_notify(::up::push_notify* _push_notify);

  // optional .up.system_setting _system_setting = 54;
  inline bool has__system_setting() const;
  inline void clear__system_setting();
  static const int kSystemSettingFieldNumber = 54;
  inline const ::up::system_setting& _system_setting() const;
  inline ::up::system_setting* mutable__system_setting();
  inline ::up::system_setting* release__system_setting();
  inline void set_allocated__system_setting(::up::system_setting* _system_setting);

  // optional .up.query_split_data _query_split_data = 55;
  inline bool has__query_split_data() const;
  inline void clear__query_split_data();
  static const int kQuerySplitDataFieldNumber = 55;
  inline const ::up::query_split_data& _query_split_data() const;
  inline ::up::query_split_data* mutable__query_split_data();
  inline ::up::query_split_data* release__query_split_data();
  inline void set_allocated__query_split_data(::up::query_split_data* _query_split_data);

  // optional .up.query_split_return _query_split_return = 56;
  inline bool has__query_split_return() const;
  inline void clear__query_split_return();
  static const int kQuerySplitReturnFieldNumber = 56;
  inline const ::up::query_split_return& _query_split_return() const;
  inline ::up::query_split_return* mutable__query_split_return();
  inline ::up::query_split_return* release__query_split_return();
  inline void set_allocated__query_split_return(::up::query_split_return* _query_split_return);

  // optional .up.split_hero _split_hero = 57;
  inline bool has__split_hero() const;
  inline void clear__split_hero();
  static const int kSplitHeroFieldNumber = 57;
  inline const ::up::split_hero& _split_hero() const;
  inline ::up::split_hero* mutable__split_hero();
  inline ::up::split_hero* release__split_hero();
  inline void set_allocated__split_hero(::up::split_hero* _split_hero);

  // optional .up.worldcup _worldcup = 58;
  inline bool has__worldcup() const;
  inline void clear__worldcup();
  static const int kWorldcupFieldNumber = 58;
  inline const ::up::worldcup& _worldcup() const;
  inline ::up::worldcup* mutable__worldcup();
  inline ::up::worldcup* release__worldcup();
  inline void set_allocated__worldcup(::up::worldcup* _worldcup);

  // optional .up.report_battle _report_battle = 59;
  inline bool has__report_battle() const;
  inline void clear__report_battle();
  static const int kReportBattleFieldNumber = 59;
  inline const ::up::report_battle& _report_battle() const;
  inline ::up::report_battle* mutable__report_battle();
  inline ::up::report_battle* release__report_battle();
  inline void set_allocated__report_battle(::up::report_battle* _report_battle);

  // optional .up.query_replay _query_replay = 60;
  inline bool has__query_replay() const;
  inline void clear__query_replay();
  static const int kQueryReplayFieldNumber = 60;
  inline const ::up::query_replay& _query_replay() const;
  inline ::up::query_replay* mutable__query_replay();
  inline ::up::query_replay* release__query_replay();
  inline void set_allocated__query_replay(::up::query_replay* _query_replay);

  // optional .up.sync_skill_stren _sync_skill_stren = 61;
  inline bool has__sync_skill_stren() const;
  inline void clear__sync_skill_stren();
  static const int kSyncSkillStrenFieldNumber = 61;
  inline const ::up::sync_skill_stren& _sync_skill_stren() const;
  inline ::up::sync_skill_stren* mutable__sync_skill_stren();
  inline ::up::sync_skill_stren* release__sync_skill_stren();
  inline void set_allocated__sync_skill_stren(::up::sync_skill_stren* _sync_skill_stren);

  // optional .up.query_ranklist _query_ranklist = 62;
  inline bool has__query_ranklist() const;
  inline void clear__query_ranklist();
  static const int kQueryRanklistFieldNumber = 62;
  inline const ::up::query_ranklist& _query_ranklist() const;
  inline ::up::query_ranklist* mutable__query_ranklist();
  inline ::up::query_ranklist* release__query_ranklist();
  inline void set_allocated__query_ranklist(::up::query_ranklist* _query_ranklist);

  // optional .up.change_server _change_server = 63;
  inline bool has__change_server() const;
  inline void clear__change_server();
  static const int kChangeServerFieldNumber = 63;
  inline const ::up::change_server& _change_server() const;
  inline ::up::change_server* mutable__change_server();
  inline ::up::change_server* release__change_server();
  inline void set_allocated__change_server(::up::change_server* _change_server);

  // optional .up.require_arousal _require_arousal = 64;
  inline bool has__require_arousal() const;
  inline void clear__require_arousal();
  static const int kRequireArousalFieldNumber = 64;
  inline const ::up::require_arousal& _require_arousal() const;
  inline ::up::require_arousal* mutable__require_arousal();
  inline ::up::require_arousal* release__require_arousal();
  inline void set_allocated__require_arousal(::up::require_arousal* _require_arousal);

  // optional .up.change_task_status _change_task_status = 65;
  inline bool has__change_task_status() const;
  inline void clear__change_task_status();
  static const int kChangeTaskStatusFieldNumber = 65;
  inline const ::up::change_task_status& _change_task_status() const;
  inline ::up::change_task_status* mutable__change_task_status();
  inline ::up::change_task_status* release__change_task_status();
  inline void set_allocated__change_task_status(::up::change_task_status* _change_task_status);

  // optional .up.request_guild_log _request_guild_log = 66;
  inline bool has__request_guild_log() const;
  inline void clear__request_guild_log();
  static const int kRequestGuildLogFieldNumber = 66;
  inline const ::up::request_guild_log& _request_guild_log() const;
  inline ::up::request_guild_log* mutable__request_guild_log();
  inline ::up::request_guild_log* release__request_guild_log();
  inline void set_allocated__request_guild_log(::up::request_guild_log* _request_guild_log);

  // optional .up.query_act_stage _query_act_stage = 67;
  inline bool has__query_act_stage() const;
  inline void clear__query_act_stage();
  static const int kQueryActStageFieldNumber = 67;
  inline const ::up::query_act_stage& _query_act_stage() const;
  inline ::up::query_act_stage* mutable__query_act_stage();
  inline ::up::query_act_stage* release__query_act_stage();
  inline void set_allocated__query_act_stage(::up::query_act_stage* _query_act_stage);

  // optional .up.request_upgrade_arousal_level _request_upgrade_arousal_level = 68;
  inline bool has__request_upgrade_arousal_level() const;
  inline void clear__request_upgrade_arousal_level();
  static const int kRequestUpgradeArousalLevelFieldNumber = 68;
  inline const ::up::request_upgrade_arousal_level& _request_upgrade_arousal_level() const;
  inline ::up::request_upgrade_arousal_level* mutable__request_upgrade_arousal_level();
  inline ::up::request_upgrade_arousal_level* release__request_upgrade_arousal_level();
  inline void set_allocated__request_upgrade_arousal_level(::up::request_upgrade_arousal_level* _request_upgrade_arousal_level);

  // optional .up.fb_attention _fb_attention = 300;
  inline bool has__fb_attention() const;
  inline void clear__fb_attention();
  static const int kFbAttentionFieldNumber = 300;
  inline const ::up::fb_attention& _fb_attention() const;
  inline ::up::fb_attention* mutable__fb_attention();
  inline ::up::fb_attention* release__fb_attention();
  inline void set_allocated__fb_attention(::up::fb_attention* _fb_attention);

  // optional .up.dot_info _dot_info = 301;
  inline bool has__dot_info() const;
  inline void clear__dot_info();
  static const int kDotInfoFieldNumber = 301;
  inline const ::up::dot_info& _dot_info() const;
  inline ::up::dot_info* mutable__dot_info();
  inline ::up::dot_info* release__dot_info();
  inline void set_allocated__dot_info(::up::dot_info* _dot_info);

  // optional .up.activity_info _activity_info = 69;
  inline bool has__activity_info() const;
  inline void clear__activity_info();
  static const int kActivityInfoFieldNumber = 69;
  inline const ::up::activity_info& _activity_info() const;
  inline ::up::activity_info* mutable__activity_info();
  inline ::up::activity_info* release__activity_info();
  inline void set_allocated__activity_info(::up::activity_info* _activity_info);

  // optional .up.activity_lotto_info _activity_lotto_info = 70;
  inline bool has__activity_lotto_info() const;
  inline void clear__activity_lotto_info();
  static const int kActivityLottoInfoFieldNumber = 70;
  inline const ::up::activity_lotto_info& _activity_lotto_info() const;
  inline ::up::activity_lotto_info* mutable__activity_lotto_info();
  inline ::up::activity_lotto_info* release__activity_lotto_info();
  inline void set_allocated__activity_lotto_info(::up::activity_lotto_info* _activity_lotto_info);

  // optional .up.activity_lotto_reward _activity_lotto_reward = 71;
  inline bool has__activity_lotto_reward() const;
  inline void clear__activity_lotto_reward();
  static const int kActivityLottoRewardFieldNumber = 71;
  inline const ::up::activity_lotto_reward& _activity_lotto_reward() const;
  inline ::up::activity_lotto_reward* mutable__activity_lotto_reward();
  inline ::up::activity_lotto_reward* release__activity_lotto_reward();
  inline void set_allocated__activity_lotto_reward(::up::activity_lotto_reward* _activity_lotto_reward);

  // optional .up.activity_bigpackage_info _activity_bigpackage_info = 72;
  inline bool has__activity_bigpackage_info() const;
  inline void clear__activity_bigpackage_info();
  static const int kActivityBigpackageInfoFieldNumber = 72;
  inline const ::up::activity_bigpackage_info& _activity_bigpackage_info() const;
  inline ::up::activity_bigpackage_info* mutable__activity_bigpackage_info();
  inline ::up::activity_bigpackage_info* release__activity_bigpackage_info();
  inline void set_allocated__activity_bigpackage_info(::up::activity_bigpackage_info* _activity_bigpackage_info);

  // optional .up.activity_bigpackage_reward_info _activity_bigpackage_reward_info = 73;
  inline bool has__activity_bigpackage_reward_info() const;
  inline void clear__activity_bigpackage_reward_info();
  static const int kActivityBigpackageRewardInfoFieldNumber = 73;
  inline const ::up::activity_bigpackage_reward_info& _activity_bigpackage_reward_info() const;
  inline ::up::activity_bigpackage_reward_info* mutable__activity_bigpackage_reward_info();
  inline ::up::activity_bigpackage_reward_info* release__activity_bigpackage_reward_info();
  inline void set_allocated__activity_bigpackage_reward_info(::up::activity_bigpackage_reward_info* _activity_bigpackage_reward_info);

  // optional .up.activity_bigpackage_reset _activity_bigpackage_reset = 74;
  inline bool has__activity_bigpackage_reset() const;
  inline void clear__activity_bigpackage_reset();
  static const int kActivityBigpackageResetFieldNumber = 74;
  inline const ::up::activity_bigpackage_reset& _activity_bigpackage_reset() const;
  inline ::up::activity_bigpackage_reset* mutable__activity_bigpackage_reset();
  inline ::up::activity_bigpackage_reset* release__activity_bigpackage_reset();
  inline void set_allocated__activity_bigpackage_reset(::up::activity_bigpackage_reset* _activity_bigpackage_reset);

  // optional .up.continue_pay _continue_pay = 302;
  inline bool has__continue_pay() const;
  inline void clear__continue_pay();
  static const int kContinuePayFieldNumber = 302;
  inline const ::up::continue_pay& _continue_pay() const;
  inline ::up::continue_pay* mutable__continue_pay();
  inline ::up::continue_pay* release__continue_pay();
  inline void set_allocated__continue_pay(::up::continue_pay* _continue_pay);

  // optional .up.recharge_rebate _recharge_rebate = 303;
  inline bool has__recharge_rebate() const;
  inline void clear__recharge_rebate();
  static const int kRechargeRebateFieldNumber = 303;
  inline const ::up::recharge_rebate& _recharge_rebate() const;
  inline ::up::recharge_rebate* mutable__recharge_rebate();
  inline ::up::recharge_rebate* release__recharge_rebate();
  inline void set_allocated__recharge_rebate(::up::recharge_rebate* _recharge_rebate);

  // optional .up.every_day_happy _every_day_happy = 304;
  inline bool has__every_day_happy() const;
  inline void clear__every_day_happy();
  static const int kEveryDayHappyFieldNumber = 304;
  inline const ::up::every_day_happy& _every_day_happy() const;
  inline ::up::every_day_happy* mutable__every_day_happy();
  inline ::up::every_day_happy* release__every_day_happy();
  inline void set_allocated__every_day_happy(::up::every_day_happy* _every_day_happy);

  // @@protoc_insertion_point(class_scope:up.up_msg)
 private:
  inline void set_has__repeat();
  inline void clear_has__repeat();
  inline void set_has__user_id();
  inline void clear_has__user_id();
  inline void set_has__login();
  inline void clear_has__login();
  inline void set_has__request_userinfo();
  inline void clear_has__request_userinfo();
  inline void set_has__enter_stage();
  inline void clear_has__enter_stage();
  inline void set_has__exit_stage();
  inline void clear_has__exit_stage();
  inline void set_has__gm_cmd();
  inline void clear_has__gm_cmd();
  inline void set_has__hero_upgrade();
  inline void clear_has__hero_upgrade();
  inline void set_has__equip_synthesis();
  inline void clear_has__equip_synthesis();
  inline void set_has__wear_equip();
  inline void clear_has__wear_equip();
  inline void set_has__consume_item();
  inline void clear_has__consume_item();
  inline void set_has__shop_refresh();
  inline void clear_has__shop_refresh();
  inline void set_has__shop_consume();
  inline void clear_has__shop_consume();
  inline void set_has__skill_levelup();
  inline void clear_has__skill_levelup();
  inline void set_has__sell_item();
  inline void clear_has__sell_item();
  inline void set_has__fragment_compose();
  inline void clear_has__fragment_compose();
  inline void set_has__hero_equip_upgrade();
  inline void clear_has__hero_equip_upgrade();
  inline void set_has__trigger_task();
  inline void clear_has__trigger_task();
  inline void set_has__require_rewards();
  inline void clear_has__require_rewards();
  inline void set_has__trigger_job();
  inline void clear_has__trigger_job();
  inline void set_has__job_rewards();
  inline void clear_has__job_rewards();
  inline void set_has__reset_elite();
  inline void clear_has__reset_elite();
  inline void set_has__sweep_stage();
  inline void clear_has__sweep_stage();
  inline void set_has__buy_vitality();
  inline void clear_has__buy_vitality();
  inline void set_has__buy_skill_stren_point();
  inline void clear_has__buy_skill_stren_point();
  inline void set_has__tavern_draw();
  inline void clear_has__tavern_draw();
  inline void set_has__query_data();
  inline void clear_has__query_data();
  inline void set_has__hero_evolve();
  inline void clear_has__hero_evolve();
  inline void set_has__enter_act_stage();
  inline void clear_has__enter_act_stage();
  inline void set_has__sync_vitality();
  inline void clear_has__sync_vitality();
  inline void set_has__suspend_report();
  inline void clear_has__suspend_report();
  inline void set_has__tutorial();
  inline void clear_has__tutorial();
  inline void set_has__ladder();
  inline void clear_has__ladder();
  inline void set_has__set_name();
  inline void clear_has__set_name();
  inline void set_has__midas();
  inline void clear_has__midas();
  inline void set_has__open_shop();
  inline void clear_has__open_shop();
  inline void set_has__charge();
  inline void clear_has__charge();
  inline void set_has__sdk_login();
  inline void clear_has__sdk_login();
  inline void set_has__set_avatar();
  inline void clear_has__set_avatar();
  inline void set_has__ask_daily_login();
  inline void clear_has__ask_daily_login();
  inline void set_has__tbc();
  inline void clear_has__tbc();
  inline void set_has__get_maillist();
  inline void clear_has__get_maillist();
  inline void set_has__read_mail();
  inline void clear_has__read_mail();
  inline void set_has__get_svr_time();
  inline void clear_has__get_svr_time();
  inline void set_has__get_vip_gift();
  inline void clear_has__get_vip_gift();
  inline void set_has__important_data_md5();
  inline void clear_has__important_data_md5();
  inline void set_has__chat();
  inline void clear_has__chat();
  inline void set_has__cdkey_gift();
  inline void clear_has__cdkey_gift();
  inline void set_has__guild();
  inline void clear_has__guild();
  inline void set_has__ask_magicsoul();
  inline void clear_has__ask_magicsoul();
  inline void set_has__ask_activity_info();
  inline void clear_has__ask_activity_info();
  inline void set_has__excavate();
  inline void clear_has__excavate();
  inline void set_has__push_notify();
  inline void clear_has__push_notify();
  inline void set_has__system_setting();
  inline void clear_has__system_setting();
  inline void set_has__query_split_data();
  inline void clear_has__query_split_data();
  inline void set_has__query_split_return();
  inline void clear_has__query_split_return();
  inline void set_has__split_hero();
  inline void clear_has__split_hero();
  inline void set_has__worldcup();
  inline void clear_has__worldcup();
  inline void set_has__report_battle();
  inline void clear_has__report_battle();
  inline void set_has__query_replay();
  inline void clear_has__query_replay();
  inline void set_has__sync_skill_stren();
  inline void clear_has__sync_skill_stren();
  inline void set_has__query_ranklist();
  inline void clear_has__query_ranklist();
  inline void set_has__change_server();
  inline void clear_has__change_server();
  inline void set_has__require_arousal();
  inline void clear_has__require_arousal();
  inline void set_has__change_task_status();
  inline void clear_has__change_task_status();
  inline void set_has__request_guild_log();
  inline void clear_has__request_guild_log();
  inline void set_has__query_act_stage();
  inline void clear_has__query_act_stage();
  inline void set_has__request_upgrade_arousal_level();
  inline void clear_has__request_upgrade_arousal_level();
  inline void set_has__fb_attention();
  inline void clear_has__fb_attention();
  inline void set_has__dot_info();
  inline void clear_has__dot_info();
  inline void set_has__activity_info();
  inline void clear_has__activity_info();
  inline void set_has__activity_lotto_info();
  inline void clear_has__activity_lotto_info();
  inline void set_has__activity_lotto_reward();
  inline void clear_has__activity_lotto_reward();
  inline void set_has__activity_bigpackage_info();
  inline void clear_has__activity_bigpackage_info();
  inline void set_has__activity_bigpackage_reward_info();
  inline void clear_has__activity_bigpackage_reward_info();
  inline void set_has__activity_bigpackage_reset();
  inline void clear_has__activity_bigpackage_reset();
  inline void set_has__continue_pay();
  inline void clear_has__continue_pay();
  inline void set_has__recharge_rebate();
  inline void clear_has__recharge_rebate();
  inline void set_has__every_day_happy();
  inline void clear_has__every_day_happy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _repeat_;
  ::google::protobuf::uint32 _user_id_;
  ::up::login* _login_;
  ::up::request_userinfo* _request_userinfo_;
  ::up::enter_stage* _enter_stage_;
  ::up::exit_stage* _exit_stage_;
  ::up::gm_cmd* _gm_cmd_;
  ::up::hero_upgrade* _hero_upgrade_;
  ::up::equip_synthesis* _equip_synthesis_;
  ::up::wear_equip* _wear_equip_;
  ::up::consume_item* _consume_item_;
  ::up::shop_refresh* _shop_refresh_;
  ::up::shop_consume* _shop_consume_;
  ::up::skill_levelup* _skill_levelup_;
  ::up::sell_item* _sell_item_;
  ::up::fragment_compose* _fragment_compose_;
  ::up::hero_equip_upgrade* _hero_equip_upgrade_;
  ::up::trigger_task* _trigger_task_;
  ::up::require_rewards* _require_rewards_;
  ::up::trigger_job* _trigger_job_;
  ::up::job_rewards* _job_rewards_;
  ::up::reset_elite* _reset_elite_;
  ::up::sweep_stage* _sweep_stage_;
  ::up::buy_vitality* _buy_vitality_;
  ::up::buy_skill_stren_point* _buy_skill_stren_point_;
  ::up::tavern_draw* _tavern_draw_;
  ::up::query_data* _query_data_;
  ::up::hero_evolve* _hero_evolve_;
  ::up::enter_act_stage* _enter_act_stage_;
  ::up::sync_vitality* _sync_vitality_;
  ::up::suspend_report* _suspend_report_;
  ::up::tutorial* _tutorial_;
  ::up::ladder* _ladder_;
  ::up::set_name* _set_name_;
  ::up::midas* _midas_;
  ::up::open_shop* _open_shop_;
  ::up::charge* _charge_;
  ::up::sdk_login* _sdk_login_;
  ::up::set_avatar* _set_avatar_;
  ::up::ask_daily_login* _ask_daily_login_;
  ::up::tbc* _tbc_;
  ::up::get_maillist* _get_maillist_;
  ::up::read_mail* _read_mail_;
  ::up::get_svr_time* _get_svr_time_;
  ::up::get_vip_gift* _get_vip_gift_;
  ::std::string* _important_data_md5_;
  ::up::chat* _chat_;
  ::up::cdkey_gift* _cdkey_gift_;
  ::up::guild* _guild_;
  ::up::ask_magicsoul* _ask_magicsoul_;
  ::up::ask_activity_info* _ask_activity_info_;
  ::up::excavate* _excavate_;
  ::up::push_notify* _push_notify_;
  ::up::system_setting* _system_setting_;
  ::up::query_split_data* _query_split_data_;
  ::up::query_split_return* _query_split_return_;
  ::up::split_hero* _split_hero_;
  ::up::worldcup* _worldcup_;
  ::up::report_battle* _report_battle_;
  ::up::query_replay* _query_replay_;
  ::up::sync_skill_stren* _sync_skill_stren_;
  ::up::query_ranklist* _query_ranklist_;
  ::up::change_server* _change_server_;
  ::up::require_arousal* _require_arousal_;
  ::up::change_task_status* _change_task_status_;
  ::up::request_guild_log* _request_guild_log_;
  ::up::query_act_stage* _query_act_stage_;
  ::up::request_upgrade_arousal_level* _request_upgrade_arousal_level_;
  ::up::fb_attention* _fb_attention_;
  ::up::dot_info* _dot_info_;
  ::up::activity_info* _activity_info_;
  ::up::activity_lotto_info* _activity_lotto_info_;
  ::up::activity_lotto_reward* _activity_lotto_reward_;
  ::up::activity_bigpackage_info* _activity_bigpackage_info_;
  ::up::activity_bigpackage_reward_info* _activity_bigpackage_reward_info_;
  ::up::activity_bigpackage_reset* _activity_bigpackage_reset_;
  ::up::continue_pay* _continue_pay_;
  ::up::recharge_rebate* _recharge_rebate_;
  ::up::every_day_happy* _every_day_happy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(79 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static up_msg* default_instance_;
};
// -------------------------------------------------------------------

class request_upgrade_arousal_level : public ::google::protobuf::Message {
 public:
  request_upgrade_arousal_level();
  virtual ~request_upgrade_arousal_level();

  request_upgrade_arousal_level(const request_upgrade_arousal_level& from);

  inline request_upgrade_arousal_level& operator=(const request_upgrade_arousal_level& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const request_upgrade_arousal_level& default_instance();

  void Swap(request_upgrade_arousal_level* other);

  // implements Message ----------------------------------------------

  request_upgrade_arousal_level* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const request_upgrade_arousal_level& from);
  void MergeFrom(const request_upgrade_arousal_level& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.request_upgrade_arousal_level)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static request_upgrade_arousal_level* default_instance_;
};
// -------------------------------------------------------------------

class continue_pay : public ::google::protobuf::Message {
 public:
  continue_pay();
  virtual ~continue_pay();

  continue_pay(const continue_pay& from);

  inline continue_pay& operator=(const continue_pay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const continue_pay& default_instance();

  void Swap(continue_pay* other);

  // implements Message ----------------------------------------------

  continue_pay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const continue_pay& from);
  void MergeFrom(const continue_pay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _continue_pay = 1;
  inline bool has__continue_pay() const;
  inline void clear__continue_pay();
  static const int kContinuePayFieldNumber = 1;
  inline ::google::protobuf::uint32 _continue_pay() const;
  inline void set__continue_pay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.continue_pay)
 private:
  inline void set_has__continue_pay();
  inline void clear_has__continue_pay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _continue_pay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static continue_pay* default_instance_;
};
// -------------------------------------------------------------------

class recharge_rebate : public ::google::protobuf::Message {
 public:
  recharge_rebate();
  virtual ~recharge_rebate();

  recharge_rebate(const recharge_rebate& from);

  inline recharge_rebate& operator=(const recharge_rebate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const recharge_rebate& default_instance();

  void Swap(recharge_rebate* other);

  // implements Message ----------------------------------------------

  recharge_rebate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const recharge_rebate& from);
  void MergeFrom(const recharge_rebate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _recharge_rebate = 1;
  inline bool has__recharge_rebate() const;
  inline void clear__recharge_rebate();
  static const int kRechargeRebateFieldNumber = 1;
  inline ::google::protobuf::uint32 _recharge_rebate() const;
  inline void set__recharge_rebate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.recharge_rebate)
 private:
  inline void set_has__recharge_rebate();
  inline void clear_has__recharge_rebate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _recharge_rebate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static recharge_rebate* default_instance_;
};
// -------------------------------------------------------------------

class every_day_happy : public ::google::protobuf::Message {
 public:
  every_day_happy();
  virtual ~every_day_happy();

  every_day_happy(const every_day_happy& from);

  inline every_day_happy& operator=(const every_day_happy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const every_day_happy& default_instance();

  void Swap(every_day_happy* other);

  // implements Message ----------------------------------------------

  every_day_happy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const every_day_happy& from);
  void MergeFrom(const every_day_happy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _every_day_happy = 1;
  inline bool has__every_day_happy() const;
  inline void clear__every_day_happy();
  static const int kEveryDayHappyFieldNumber = 1;
  inline ::google::protobuf::uint32 _every_day_happy() const;
  inline void set__every_day_happy(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.every_day_happy)
 private:
  inline void set_has__every_day_happy();
  inline void clear_has__every_day_happy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _every_day_happy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static every_day_happy* default_instance_;
};
// -------------------------------------------------------------------

class system_setting : public ::google::protobuf::Message {
 public:
  system_setting();
  virtual ~system_setting();

  system_setting(const system_setting& from);

  inline system_setting& operator=(const system_setting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const system_setting& default_instance();

  void Swap(system_setting* other);

  // implements Message ----------------------------------------------

  system_setting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const system_setting& from);
  void MergeFrom(const system_setting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .up.system_setting_request _request = 1;
  inline bool has__request() const;
  inline void clear__request();
  static const int kRequestFieldNumber = 1;
  inline const ::up::system_setting_request& _request() const;
  inline ::up::system_setting_request* mutable__request();
  inline ::up::system_setting_request* release__request();
  inline void set_allocated__request(::up::system_setting_request* _request);

  // optional .up.system_setting_change _change = 2;
  inline bool has__change() const;
  inline void clear__change();
  static const int kChangeFieldNumber = 2;
  inline const ::up::system_setting_change& _change() const;
  inline ::up::system_setting_change* mutable__change();
  inline ::up::system_setting_change* release__change();
  inline void set_allocated__change(::up::system_setting_change* _change);

  // @@protoc_insertion_point(class_scope:up.system_setting)
 private:
  inline void set_has__request();
  inline void clear_has__request();
  inline void set_has__change();
  inline void clear_has__change();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::up::system_setting_request* _request_;
  ::up::system_setting_change* _change_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static system_setting* default_instance_;
};
// -------------------------------------------------------------------

class system_setting_change : public ::google::protobuf::Message {
 public:
  system_setting_change();
  virtual ~system_setting_change();

  system_setting_change(const system_setting_change& from);

  inline system_setting_change& operator=(const system_setting_change& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const system_setting_change& default_instance();

  void Swap(system_setting_change* other);

  // implements Message ----------------------------------------------

  system_setting_change* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const system_setting_change& from);
  void MergeFrom(const system_setting_change& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef system_setting_change_setting_status setting_status;
  static const setting_status on = system_setting_change_setting_status_on;
  static const setting_status off = system_setting_change_setting_status_off;
  static inline bool setting_status_IsValid(int value) {
    return system_setting_change_setting_status_IsValid(value);
  }
  static const setting_status setting_status_MIN =
    system_setting_change_setting_status_setting_status_MIN;
  static const setting_status setting_status_MAX =
    system_setting_change_setting_status_setting_status_MAX;
  static const int setting_status_ARRAYSIZE =
    system_setting_change_setting_status_setting_status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  setting_status_descriptor() {
    return system_setting_change_setting_status_descriptor();
  }
  static inline const ::std::string& setting_status_Name(setting_status value) {
    return system_setting_change_setting_status_Name(value);
  }
  static inline bool setting_status_Parse(const ::std::string& name,
      setting_status* value) {
    return system_setting_change_setting_status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:up.system_setting_change)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static system_setting_change* default_instance_;
};
// -------------------------------------------------------------------

class system_setting_request : public ::google::protobuf::Message {
 public:
  system_setting_request();
  virtual ~system_setting_request();

  system_setting_request(const system_setting_request& from);

  inline system_setting_request& operator=(const system_setting_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const system_setting_request& default_instance();

  void Swap(system_setting_request* other);

  // implements Message ----------------------------------------------

  system_setting_request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const system_setting_request& from);
  void MergeFrom(const system_setting_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.system_setting_request)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static system_setting_request* default_instance_;
};
// -------------------------------------------------------------------

class push_notify : public ::google::protobuf::Message {
 public:
  push_notify();
  virtual ~push_notify();

  push_notify(const push_notify& from);

  inline push_notify& operator=(const push_notify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const push_notify& default_instance();

  void Swap(push_notify* other);

  // implements Message ----------------------------------------------

  push_notify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const push_notify& from);
  void MergeFrom(const push_notify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _client_id = 1;
  inline bool has__client_id() const;
  inline void clear__client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& _client_id() const;
  inline void set__client_id(const ::std::string& value);
  inline void set__client_id(const char* value);
  inline void set__client_id(const char* value, size_t size);
  inline ::std::string* mutable__client_id();
  inline ::std::string* release__client_id();
  inline void set_allocated__client_id(::std::string* _client_id);

  // @@protoc_insertion_point(class_scope:up.push_notify)
 private:
  inline void set_has__client_id();
  inline void clear_has__client_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _client_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static push_notify* default_instance_;
};
// -------------------------------------------------------------------

class login : public ::google::protobuf::Message {
 public:
  login();
  virtual ~login();

  login(const login& from);

  inline login& operator=(const login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login& default_instance();

  void Swap(login* other);

  // implements Message ----------------------------------------------

  login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login& from);
  void MergeFrom(const login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 _active_code = 1;
  inline bool has__active_code() const;
  inline void clear__active_code();
  static const int kActiveCodeFieldNumber = 1;
  inline ::google::protobuf::uint64 _active_code() const;
  inline void set__active_code(::google::protobuf::uint64 value);

  // optional string _old_deviceid = 2;
  inline bool has__old_deviceid() const;
  inline void clear__old_deviceid();
  static const int kOldDeviceidFieldNumber = 2;
  inline const ::std::string& _old_deviceid() const;
  inline void set__old_deviceid(const ::std::string& value);
  inline void set__old_deviceid(const char* value);
  inline void set__old_deviceid(const char* value, size_t size);
  inline ::std::string* mutable__old_deviceid();
  inline ::std::string* release__old_deviceid();
  inline void set_allocated__old_deviceid(::std::string* _old_deviceid);

  // optional string _version = 3;
  inline bool has__version() const;
  inline void clear__version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& _version() const;
  inline void set__version(const ::std::string& value);
  inline void set__version(const char* value);
  inline void set__version(const char* value, size_t size);
  inline ::std::string* mutable__version();
  inline ::std::string* release__version();
  inline void set_allocated__version(::std::string* _version);

  // optional uint32 _languageid = 4;
  inline bool has__languageid() const;
  inline void clear__languageid();
  static const int kLanguageidFieldNumber = 4;
  inline ::google::protobuf::uint32 _languageid() const;
  inline void set__languageid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.login)
 private:
  inline void set_has__active_code();
  inline void clear_has__active_code();
  inline void set_has__old_deviceid();
  inline void clear_has__old_deviceid();
  inline void set_has__version();
  inline void clear_has__version();
  inline void set_has__languageid();
  inline void clear_has__languageid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 _active_code_;
  ::std::string* _old_deviceid_;
  ::std::string* _version_;
  ::google::protobuf::uint32 _languageid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static login* default_instance_;
};
// -------------------------------------------------------------------

class sdk_login : public ::google::protobuf::Message {
 public:
  sdk_login();
  virtual ~sdk_login();

  sdk_login(const sdk_login& from);

  inline sdk_login& operator=(const sdk_login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sdk_login& default_instance();

  void Swap(sdk_login* other);

  // implements Message ----------------------------------------------

  sdk_login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sdk_login& from);
  void MergeFrom(const sdk_login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _session_key = 1;
  inline bool has__session_key() const;
  inline void clear__session_key();
  static const int kSessionKeyFieldNumber = 1;
  inline const ::std::string& _session_key() const;
  inline void set__session_key(const ::std::string& value);
  inline void set__session_key(const char* value);
  inline void set__session_key(const char* value, size_t size);
  inline ::std::string* mutable__session_key();
  inline ::std::string* release__session_key();
  inline void set_allocated__session_key(::std::string* _session_key);

  // required .up.platform_type _plat_id = 2;
  inline bool has__plat_id() const;
  inline void clear__plat_id();
  static const int kPlatIdFieldNumber = 2;
  inline ::up::platform_type _plat_id() const;
  inline void set__plat_id(::up::platform_type value);

  // @@protoc_insertion_point(class_scope:up.sdk_login)
 private:
  inline void set_has__session_key();
  inline void clear_has__session_key();
  inline void set_has__plat_id();
  inline void clear_has__plat_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _session_key_;
  int _plat_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static sdk_login* default_instance_;
};
// -------------------------------------------------------------------

class request_userinfo : public ::google::protobuf::Message {
 public:
  request_userinfo();
  virtual ~request_userinfo();

  request_userinfo(const request_userinfo& from);

  inline request_userinfo& operator=(const request_userinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const request_userinfo& default_instance();

  void Swap(request_userinfo* other);

  // implements Message ----------------------------------------------

  request_userinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const request_userinfo& from);
  void MergeFrom(const request_userinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.request_userinfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static request_userinfo* default_instance_;
};
// -------------------------------------------------------------------

class enter_stage : public ::google::protobuf::Message {
 public:
  enter_stage();
  virtual ~enter_stage();

  enter_stage(const enter_stage& from);

  inline enter_stage& operator=(const enter_stage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const enter_stage& default_instance();

  void Swap(enter_stage* other);

  // implements Message ----------------------------------------------

  enter_stage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const enter_stage& from);
  void MergeFrom(const enter_stage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _stage_id = 1;
  inline bool has__stage_id() const;
  inline void clear__stage_id();
  static const int kStageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _stage_id() const;
  inline void set__stage_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.enter_stage)
 private:
  inline void set_has__stage_id();
  inline void clear_has__stage_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _stage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static enter_stage* default_instance_;
};
// -------------------------------------------------------------------

class exit_stage : public ::google::protobuf::Message {
 public:
  exit_stage();
  virtual ~exit_stage();

  exit_stage(const exit_stage& from);

  inline exit_stage& operator=(const exit_stage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exit_stage& default_instance();

  void Swap(exit_stage* other);

  // implements Message ----------------------------------------------

  exit_stage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exit_stage& from);
  void MergeFrom(const exit_stage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.battle_result _result = 1 [default = victory];
  inline bool has__result() const;
  inline void clear__result();
  static const int kResultFieldNumber = 1;
  inline ::up::battle_result _result() const;
  inline void set__result(::up::battle_result value);

  // optional uint32 _stars = 2;
  inline bool has__stars() const;
  inline void clear__stars();
  static const int kStarsFieldNumber = 2;
  inline ::google::protobuf::uint32 _stars() const;
  inline void set__stars(::google::protobuf::uint32 value);

  // repeated uint32 _heroes = 3;
  inline int _heroes_size() const;
  inline void clear__heroes();
  static const int kHeroesFieldNumber = 3;
  inline ::google::protobuf::uint32 _heroes(int index) const;
  inline void set__heroes(int index, ::google::protobuf::uint32 value);
  inline void add__heroes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _heroes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__heroes();

  // repeated uint32 _oprations = 4;
  inline int _oprations_size() const;
  inline void clear__oprations();
  static const int kOprationsFieldNumber = 4;
  inline ::google::protobuf::uint32 _oprations(int index) const;
  inline void set__oprations(int index, ::google::protobuf::uint32 value);
  inline void add__oprations(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _oprations() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__oprations();

  // optional string _md5 = 5;
  inline bool has__md5() const;
  inline void clear__md5();
  static const int kMd5FieldNumber = 5;
  inline const ::std::string& _md5() const;
  inline void set__md5(const ::std::string& value);
  inline void set__md5(const char* value);
  inline void set__md5(const char* value, size_t size);
  inline ::std::string* mutable__md5();
  inline ::std::string* release__md5();
  inline void set_allocated__md5(::std::string* _md5);

  // repeated uint32 _self_data = 6;
  inline int _self_data_size() const;
  inline void clear__self_data();
  static const int kSelfDataFieldNumber = 6;
  inline ::google::protobuf::uint32 _self_data(int index) const;
  inline void set__self_data(int index, ::google::protobuf::uint32 value);
  inline void add__self_data(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _self_data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__self_data();

  // @@protoc_insertion_point(class_scope:up.exit_stage)
 private:
  inline void set_has__result();
  inline void clear_has__result();
  inline void set_has__stars();
  inline void clear_has__stars();
  inline void set_has__md5();
  inline void clear_has__md5();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _result_;
  ::google::protobuf::uint32 _stars_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _heroes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _oprations_;
  ::std::string* _md5_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _self_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static exit_stage* default_instance_;
};
// -------------------------------------------------------------------

class gm_cmd : public ::google::protobuf::Message {
 public:
  gm_cmd();
  virtual ~gm_cmd();

  gm_cmd(const gm_cmd& from);

  inline gm_cmd& operator=(const gm_cmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_cmd& default_instance();

  void Swap(gm_cmd* other);

  // implements Message ----------------------------------------------

  gm_cmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_cmd& from);
  void MergeFrom(const gm_cmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 _unlock_all_stages = 1;
  inline bool has__unlock_all_stages() const;
  inline void clear__unlock_all_stages();
  static const int kUnlockAllStagesFieldNumber = 1;
  inline ::google::protobuf::int32 _unlock_all_stages() const;
  inline void set__unlock_all_stages(::google::protobuf::int32 value);

  // optional int32 _get_all_heroes = 2;
  inline bool has__get_all_heroes() const;
  inline void clear__get_all_heroes();
  static const int kGetAllHeroesFieldNumber = 2;
  inline ::google::protobuf::int32 _get_all_heroes() const;
  inline void set__get_all_heroes(::google::protobuf::int32 value);

  // repeated .up.hero _set_hero_info = 3;
  inline int _set_hero_info_size() const;
  inline void clear__set_hero_info();
  static const int kSetHeroInfoFieldNumber = 3;
  inline const ::up::hero& _set_hero_info(int index) const;
  inline ::up::hero* mutable__set_hero_info(int index);
  inline ::up::hero* add__set_hero_info();
  inline const ::google::protobuf::RepeatedPtrField< ::up::hero >&
      _set_hero_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::up::hero >*
      mutable__set_hero_info();

  // optional int32 _set_vitality = 4;
  inline bool has__set_vitality() const;
  inline void clear__set_vitality();
  static const int kSetVitalityFieldNumber = 4;
  inline ::google::protobuf::int32 _set_vitality() const;
  inline void set__set_vitality(::google::protobuf::int32 value);

  // optional .up.set_money _set_money = 5;
  inline bool has__set_money() const;
  inline void clear__set_money();
  static const int kSetMoneyFieldNumber = 5;
  inline const ::up::set_money& _set_money() const;
  inline ::up::set_money* mutable__set_money();
  inline ::up::set_money* release__set_money();
  inline void set_allocated__set_money(::up::set_money* _set_money);

  // optional int32 _set_recharge_sum = 6;
  inline bool has__set_recharge_sum() const;
  inline void clear__set_recharge_sum();
  static const int kSetRechargeSumFieldNumber = 6;
  inline ::google::protobuf::int32 _set_recharge_sum() const;
  inline void set__set_recharge_sum(::google::protobuf::int32 value);

  // optional int32 _set_player_level = 7;
  inline bool has__set_player_level() const;
  inline void clear__set_player_level();
  static const int kSetPlayerLevelFieldNumber = 7;
  inline ::google::protobuf::int32 _set_player_level() const;
  inline void set__set_player_level(::google::protobuf::int32 value);

  // optional int32 _set_player_exp = 8;
  inline bool has__set_player_exp() const;
  inline void clear__set_player_exp();
  static const int kSetPlayerExpFieldNumber = 8;
  inline ::google::protobuf::int32 _set_player_exp() const;
  inline void set__set_player_exp(::google::protobuf::int32 value);

  // repeated uint32 _set_items = 9;
  inline int _set_items_size() const;
  inline void clear__set_items();
  static const int kSetItemsFieldNumber = 9;
  inline ::google::protobuf::uint32 _set_items(int index) const;
  inline void set__set_items(int index, ::google::protobuf::uint32 value);
  inline void add__set_items(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _set_items() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__set_items();

  // optional uint32 _reset_device = 10;
  inline bool has__reset_device() const;
  inline void clear__reset_device();
  static const int kResetDeviceFieldNumber = 10;
  inline ::google::protobuf::uint32 _reset_device() const;
  inline void set__reset_device(::google::protobuf::uint32 value);

  // optional uint32 _open_mystery_shop = 11;
  inline bool has__open_mystery_shop() const;
  inline void clear__open_mystery_shop();
  static const int kOpenMysteryShopFieldNumber = 11;
  inline ::google::protobuf::uint32 _open_mystery_shop() const;
  inline void set__open_mystery_shop(::google::protobuf::uint32 value);

  // optional uint32 _archive_id = 12;
  inline bool has__archive_id() const;
  inline void clear__archive_id();
  static const int kArchiveIdFieldNumber = 12;
  inline ::google::protobuf::uint32 _archive_id() const;
  inline void set__archive_id(::google::protobuf::uint32 value);

  // optional uint32 _restore_id = 13;
  inline bool has__restore_id() const;
  inline void clear__restore_id();
  static const int kRestoreIdFieldNumber = 13;
  inline ::google::protobuf::uint32 _restore_id() const;
  inline void set__restore_id(::google::protobuf::uint32 value);

  // optional int32 _reset_sweep = 14;
  inline bool has__reset_sweep() const;
  inline void clear__reset_sweep();
  static const int kResetSweepFieldNumber = 14;
  inline ::google::protobuf::int32 _reset_sweep() const;
  inline void set__reset_sweep(::google::protobuf::int32 value);

  // optional uint32 _set_dailylogin_days = 15;
  inline bool has__set_dailylogin_days() const;
  inline void clear__set_dailylogin_days();
  static const int kSetDailyloginDaysFieldNumber = 15;
  inline ::google::protobuf::uint32 _set_dailylogin_days() const;
  inline void set__set_dailylogin_days(::google::protobuf::uint32 value);

  // optional .up.open_all_guild_stage _open_guild_stage = 16;
  inline bool has__open_guild_stage() const;
  inline void clear__open_guild_stage();
  static const int kOpenGuildStageFieldNumber = 16;
  inline const ::up::open_all_guild_stage& _open_guild_stage() const;
  inline ::up::open_all_guild_stage* mutable__open_guild_stage();
  inline ::up::open_all_guild_stage* release__open_guild_stage();
  inline void set_allocated__open_guild_stage(::up::open_all_guild_stage* _open_guild_stage);

  // @@protoc_insertion_point(class_scope:up.gm_cmd)
 private:
  inline void set_has__unlock_all_stages();
  inline void clear_has__unlock_all_stages();
  inline void set_has__get_all_heroes();
  inline void clear_has__get_all_heroes();
  inline void set_has__set_vitality();
  inline void clear_has__set_vitality();
  inline void set_has__set_money();
  inline void clear_has__set_money();
  inline void set_has__set_recharge_sum();
  inline void clear_has__set_recharge_sum();
  inline void set_has__set_player_level();
  inline void clear_has__set_player_level();
  inline void set_has__set_player_exp();
  inline void clear_has__set_player_exp();
  inline void set_has__reset_device();
  inline void clear_has__reset_device();
  inline void set_has__open_mystery_shop();
  inline void clear_has__open_mystery_shop();
  inline void set_has__archive_id();
  inline void clear_has__archive_id();
  inline void set_has__restore_id();
  inline void clear_has__restore_id();
  inline void set_has__reset_sweep();
  inline void clear_has__reset_sweep();
  inline void set_has__set_dailylogin_days();
  inline void clear_has__set_dailylogin_days();
  inline void set_has__open_guild_stage();
  inline void clear_has__open_guild_stage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 _unlock_all_stages_;
  ::google::protobuf::int32 _get_all_heroes_;
  ::google::protobuf::RepeatedPtrField< ::up::hero > _set_hero_info_;
  ::up::set_money* _set_money_;
  ::google::protobuf::int32 _set_vitality_;
  ::google::protobuf::int32 _set_recharge_sum_;
  ::google::protobuf::int32 _set_player_level_;
  ::google::protobuf::int32 _set_player_exp_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _set_items_;
  ::google::protobuf::uint32 _reset_device_;
  ::google::protobuf::uint32 _open_mystery_shop_;
  ::google::protobuf::uint32 _archive_id_;
  ::google::protobuf::uint32 _restore_id_;
  ::google::protobuf::int32 _reset_sweep_;
  ::google::protobuf::uint32 _set_dailylogin_days_;
  ::up::open_all_guild_stage* _open_guild_stage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static gm_cmd* default_instance_;
};
// -------------------------------------------------------------------

class activity_info : public ::google::protobuf::Message {
 public:
  activity_info();
  virtual ~activity_info();

  activity_info(const activity_info& from);

  inline activity_info& operator=(const activity_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activity_info& default_instance();

  void Swap(activity_info* other);

  // implements Message ----------------------------------------------

  activity_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activity_info& from);
  void MergeFrom(const activity_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _player_name = 1;
  inline bool has__player_name() const;
  inline void clear__player_name();
  static const int kPlayerNameFieldNumber = 1;
  inline const ::std::string& _player_name() const;
  inline void set__player_name(const ::std::string& value);
  inline void set__player_name(const char* value);
  inline void set__player_name(const char* value, size_t size);
  inline ::std::string* mutable__player_name();
  inline ::std::string* release__player_name();
  inline void set_allocated__player_name(::std::string* _player_name);

  // required uint32 _version = 2;
  inline bool has__version() const;
  inline void clear__version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 _version() const;
  inline void set__version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.activity_info)
 private:
  inline void set_has__player_name();
  inline void clear_has__player_name();
  inline void set_has__version();
  inline void clear_has__version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _player_name_;
  ::google::protobuf::uint32 _version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static activity_info* default_instance_;
};
// -------------------------------------------------------------------

class activity_lotto_info : public ::google::protobuf::Message {
 public:
  activity_lotto_info();
  virtual ~activity_lotto_info();

  activity_lotto_info(const activity_lotto_info& from);

  inline activity_lotto_info& operator=(const activity_lotto_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activity_lotto_info& default_instance();

  void Swap(activity_lotto_info* other);

  // implements Message ----------------------------------------------

  activity_lotto_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activity_lotto_info& from);
  void MergeFrom(const activity_lotto_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _group_id = 1;
  inline bool has__group_id() const;
  inline void clear__group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::std::string& _group_id() const;
  inline void set__group_id(const ::std::string& value);
  inline void set__group_id(const char* value);
  inline void set__group_id(const char* value, size_t size);
  inline ::std::string* mutable__group_id();
  inline ::std::string* release__group_id();
  inline void set_allocated__group_id(::std::string* _group_id);

  // required uint32 _activity_id = 2;
  inline bool has__activity_id() const;
  inline void clear__activity_id();
  static const int kActivityIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _activity_id() const;
  inline void set__activity_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.activity_lotto_info)
 private:
  inline void set_has__group_id();
  inline void clear_has__group_id();
  inline void set_has__activity_id();
  inline void clear_has__activity_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _group_id_;
  ::google::protobuf::uint32 _activity_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static activity_lotto_info* default_instance_;
};
// -------------------------------------------------------------------

class activity_bigpackage_info : public ::google::protobuf::Message {
 public:
  activity_bigpackage_info();
  virtual ~activity_bigpackage_info();

  activity_bigpackage_info(const activity_bigpackage_info& from);

  inline activity_bigpackage_info& operator=(const activity_bigpackage_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activity_bigpackage_info& default_instance();

  void Swap(activity_bigpackage_info* other);

  // implements Message ----------------------------------------------

  activity_bigpackage_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activity_bigpackage_info& from);
  void MergeFrom(const activity_bigpackage_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _group_id = 1;
  inline bool has__group_id() const;
  inline void clear__group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::std::string& _group_id() const;
  inline void set__group_id(const ::std::string& value);
  inline void set__group_id(const char* value);
  inline void set__group_id(const char* value, size_t size);
  inline ::std::string* mutable__group_id();
  inline ::std::string* release__group_id();
  inline void set_allocated__group_id(::std::string* _group_id);

  // required uint32 _activity_id = 2;
  inline bool has__activity_id() const;
  inline void clear__activity_id();
  static const int kActivityIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _activity_id() const;
  inline void set__activity_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.activity_bigpackage_info)
 private:
  inline void set_has__group_id();
  inline void clear_has__group_id();
  inline void set_has__activity_id();
  inline void clear_has__activity_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _group_id_;
  ::google::protobuf::uint32 _activity_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static activity_bigpackage_info* default_instance_;
};
// -------------------------------------------------------------------

class activity_bigpackage_reward_info : public ::google::protobuf::Message {
 public:
  activity_bigpackage_reward_info();
  virtual ~activity_bigpackage_reward_info();

  activity_bigpackage_reward_info(const activity_bigpackage_reward_info& from);

  inline activity_bigpackage_reward_info& operator=(const activity_bigpackage_reward_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activity_bigpackage_reward_info& default_instance();

  void Swap(activity_bigpackage_reward_info* other);

  // implements Message ----------------------------------------------

  activity_bigpackage_reward_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activity_bigpackage_reward_info& from);
  void MergeFrom(const activity_bigpackage_reward_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _group_id = 1;
  inline bool has__group_id() const;
  inline void clear__group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::std::string& _group_id() const;
  inline void set__group_id(const ::std::string& value);
  inline void set__group_id(const char* value);
  inline void set__group_id(const char* value, size_t size);
  inline ::std::string* mutable__group_id();
  inline ::std::string* release__group_id();
  inline void set_allocated__group_id(::std::string* _group_id);

  // required uint32 _activity_id = 2;
  inline bool has__activity_id() const;
  inline void clear__activity_id();
  static const int kActivityIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _activity_id() const;
  inline void set__activity_id(::google::protobuf::uint32 value);

  // required uint32 _box_id = 3;
  inline bool has__box_id() const;
  inline void clear__box_id();
  static const int kBoxIdFieldNumber = 3;
  inline ::google::protobuf::uint32 _box_id() const;
  inline void set__box_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.activity_bigpackage_reward_info)
 private:
  inline void set_has__group_id();
  inline void clear_has__group_id();
  inline void set_has__activity_id();
  inline void clear_has__activity_id();
  inline void set_has__box_id();
  inline void clear_has__box_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _group_id_;
  ::google::protobuf::uint32 _activity_id_;
  ::google::protobuf::uint32 _box_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static activity_bigpackage_reward_info* default_instance_;
};
// -------------------------------------------------------------------

class activity_bigpackage_reset : public ::google::protobuf::Message {
 public:
  activity_bigpackage_reset();
  virtual ~activity_bigpackage_reset();

  activity_bigpackage_reset(const activity_bigpackage_reset& from);

  inline activity_bigpackage_reset& operator=(const activity_bigpackage_reset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activity_bigpackage_reset& default_instance();

  void Swap(activity_bigpackage_reset* other);

  // implements Message ----------------------------------------------

  activity_bigpackage_reset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activity_bigpackage_reset& from);
  void MergeFrom(const activity_bigpackage_reset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _group_id = 1;
  inline bool has__group_id() const;
  inline void clear__group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::std::string& _group_id() const;
  inline void set__group_id(const ::std::string& value);
  inline void set__group_id(const char* value);
  inline void set__group_id(const char* value, size_t size);
  inline ::std::string* mutable__group_id();
  inline ::std::string* release__group_id();
  inline void set_allocated__group_id(::std::string* _group_id);

  // required uint32 _activity_id = 2;
  inline bool has__activity_id() const;
  inline void clear__activity_id();
  static const int kActivityIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _activity_id() const;
  inline void set__activity_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.activity_bigpackage_reset)
 private:
  inline void set_has__group_id();
  inline void clear_has__group_id();
  inline void set_has__activity_id();
  inline void clear_has__activity_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _group_id_;
  ::google::protobuf::uint32 _activity_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static activity_bigpackage_reset* default_instance_;
};
// -------------------------------------------------------------------

class activity_lotto_reward : public ::google::protobuf::Message {
 public:
  activity_lotto_reward();
  virtual ~activity_lotto_reward();

  activity_lotto_reward(const activity_lotto_reward& from);

  inline activity_lotto_reward& operator=(const activity_lotto_reward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activity_lotto_reward& default_instance();

  void Swap(activity_lotto_reward* other);

  // implements Message ----------------------------------------------

  activity_lotto_reward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activity_lotto_reward& from);
  void MergeFrom(const activity_lotto_reward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _group_id = 1;
  inline bool has__group_id() const;
  inline void clear__group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::std::string& _group_id() const;
  inline void set__group_id(const ::std::string& value);
  inline void set__group_id(const char* value);
  inline void set__group_id(const char* value, size_t size);
  inline ::std::string* mutable__group_id();
  inline ::std::string* release__group_id();
  inline void set_allocated__group_id(::std::string* _group_id);

  // required uint32 _activity_id = 2;
  inline bool has__activity_id() const;
  inline void clear__activity_id();
  static const int kActivityIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _activity_id() const;
  inline void set__activity_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.activity_lotto_reward)
 private:
  inline void set_has__group_id();
  inline void clear_has__group_id();
  inline void set_has__activity_id();
  inline void clear_has__activity_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _group_id_;
  ::google::protobuf::uint32 _activity_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static activity_lotto_reward* default_instance_;
};
// -------------------------------------------------------------------

class open_all_guild_stage : public ::google::protobuf::Message {
 public:
  open_all_guild_stage();
  virtual ~open_all_guild_stage();

  open_all_guild_stage(const open_all_guild_stage& from);

  inline open_all_guild_stage& operator=(const open_all_guild_stage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const open_all_guild_stage& default_instance();

  void Swap(open_all_guild_stage* other);

  // implements Message ----------------------------------------------

  open_all_guild_stage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const open_all_guild_stage& from);
  void MergeFrom(const open_all_guild_stage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.open_all_guild_stage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static open_all_guild_stage* default_instance_;
};
// -------------------------------------------------------------------

class set_money : public ::google::protobuf::Message {
 public:
  set_money();
  virtual ~set_money();

  set_money(const set_money& from);

  inline set_money& operator=(const set_money& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const set_money& default_instance();

  void Swap(set_money* other);

  // implements Message ----------------------------------------------

  set_money* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const set_money& from);
  void MergeFrom(const set_money& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef set_money_price_type price_type;
  static const price_type gold = set_money_price_type_gold;
  static const price_type diamond = set_money_price_type_diamond;
  static const price_type crusadepoint = set_money_price_type_crusadepoint;
  static const price_type arenapoint = set_money_price_type_arenapoint;
  static const price_type guildpoint = set_money_price_type_guildpoint;
  static inline bool price_type_IsValid(int value) {
    return set_money_price_type_IsValid(value);
  }
  static const price_type price_type_MIN =
    set_money_price_type_price_type_MIN;
  static const price_type price_type_MAX =
    set_money_price_type_price_type_MAX;
  static const int price_type_ARRAYSIZE =
    set_money_price_type_price_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  price_type_descriptor() {
    return set_money_price_type_descriptor();
  }
  static inline const ::std::string& price_type_Name(price_type value) {
    return set_money_price_type_Name(value);
  }
  static inline bool price_type_Parse(const ::std::string& name,
      price_type* value) {
    return set_money_price_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.set_money.price_type _type = 1;
  inline bool has__type() const;
  inline void clear__type();
  static const int kTypeFieldNumber = 1;
  inline ::up::set_money_price_type _type() const;
  inline void set__type(::up::set_money_price_type value);

  // required uint32 _amount = 2;
  inline bool has__amount() const;
  inline void clear__amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint32 _amount() const;
  inline void set__amount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.set_money)
 private:
  inline void set_has__type();
  inline void clear_has__type();
  inline void set_has__amount();
  inline void clear_has__amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _type_;
  ::google::protobuf::uint32 _amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static set_money* default_instance_;
};
// -------------------------------------------------------------------

class hero_upgrade : public ::google::protobuf::Message {
 public:
  hero_upgrade();
  virtual ~hero_upgrade();

  hero_upgrade(const hero_upgrade& from);

  inline hero_upgrade& operator=(const hero_upgrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_upgrade& default_instance();

  void Swap(hero_upgrade* other);

  // implements Message ----------------------------------------------

  hero_upgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_upgrade& from);
  void MergeFrom(const hero_upgrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _hero_id = 1;
  inline bool has__hero_id() const;
  inline void clear__hero_id();
  static const int kHeroIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _hero_id() const;
  inline void set__hero_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.hero_upgrade)
 private:
  inline void set_has__hero_id();
  inline void clear_has__hero_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _hero_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static hero_upgrade* default_instance_;
};
// -------------------------------------------------------------------

class equip_synthesis : public ::google::protobuf::Message {
 public:
  equip_synthesis();
  virtual ~equip_synthesis();

  equip_synthesis(const equip_synthesis& from);

  inline equip_synthesis& operator=(const equip_synthesis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const equip_synthesis& default_instance();

  void Swap(equip_synthesis* other);

  // implements Message ----------------------------------------------

  equip_synthesis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const equip_synthesis& from);
  void MergeFrom(const equip_synthesis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _equip_id = 1;
  inline bool has__equip_id() const;
  inline void clear__equip_id();
  static const int kEquipIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _equip_id() const;
  inline void set__equip_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.equip_synthesis)
 private:
  inline void set_has__equip_id();
  inline void clear_has__equip_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _equip_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static equip_synthesis* default_instance_;
};
// -------------------------------------------------------------------

class wear_equip : public ::google::protobuf::Message {
 public:
  wear_equip();
  virtual ~wear_equip();

  wear_equip(const wear_equip& from);

  inline wear_equip& operator=(const wear_equip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wear_equip& default_instance();

  void Swap(wear_equip* other);

  // implements Message ----------------------------------------------

  wear_equip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const wear_equip& from);
  void MergeFrom(const wear_equip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _hero_id = 1;
  inline bool has__hero_id() const;
  inline void clear__hero_id();
  static const int kHeroIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _hero_id() const;
  inline void set__hero_id(::google::protobuf::uint32 value);

  // required uint32 _item_pos = 2;
  inline bool has__item_pos() const;
  inline void clear__item_pos();
  static const int kItemPosFieldNumber = 2;
  inline ::google::protobuf::uint32 _item_pos() const;
  inline void set__item_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.wear_equip)
 private:
  inline void set_has__hero_id();
  inline void clear_has__hero_id();
  inline void set_has__item_pos();
  inline void clear_has__item_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _hero_id_;
  ::google::protobuf::uint32 _item_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static wear_equip* default_instance_;
};
// -------------------------------------------------------------------

class sync_vitality : public ::google::protobuf::Message {
 public:
  sync_vitality();
  virtual ~sync_vitality();

  sync_vitality(const sync_vitality& from);

  inline sync_vitality& operator=(const sync_vitality& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sync_vitality& default_instance();

  void Swap(sync_vitality* other);

  // implements Message ----------------------------------------------

  sync_vitality* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sync_vitality& from);
  void MergeFrom(const sync_vitality& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.sync_vitality)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static sync_vitality* default_instance_;
};
// -------------------------------------------------------------------

class buy_vitality : public ::google::protobuf::Message {
 public:
  buy_vitality();
  virtual ~buy_vitality();

  buy_vitality(const buy_vitality& from);

  inline buy_vitality& operator=(const buy_vitality& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buy_vitality& default_instance();

  void Swap(buy_vitality* other);

  // implements Message ----------------------------------------------

  buy_vitality* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buy_vitality& from);
  void MergeFrom(const buy_vitality& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.buy_vitality)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static buy_vitality* default_instance_;
};
// -------------------------------------------------------------------

class consume_item : public ::google::protobuf::Message {
 public:
  consume_item();
  virtual ~consume_item();

  consume_item(const consume_item& from);

  inline consume_item& operator=(const consume_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const consume_item& default_instance();

  void Swap(consume_item* other);

  // implements Message ----------------------------------------------

  consume_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const consume_item& from);
  void MergeFrom(const consume_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _hero_id = 1;
  inline bool has__hero_id() const;
  inline void clear__hero_id();
  static const int kHeroIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _hero_id() const;
  inline void set__hero_id(::google::protobuf::uint32 value);

  // required uint32 _item_id = 2;
  inline bool has__item_id() const;
  inline void clear__item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _item_id() const;
  inline void set__item_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.consume_item)
 private:
  inline void set_has__hero_id();
  inline void clear_has__hero_id();
  inline void set_has__item_id();
  inline void clear_has__item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _hero_id_;
  ::google::protobuf::uint32 _item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static consume_item* default_instance_;
};
// -------------------------------------------------------------------

class shop_refresh : public ::google::protobuf::Message {
 public:
  shop_refresh();
  virtual ~shop_refresh();

  shop_refresh(const shop_refresh& from);

  inline shop_refresh& operator=(const shop_refresh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const shop_refresh& default_instance();

  void Swap(shop_refresh* other);

  // implements Message ----------------------------------------------

  shop_refresh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const shop_refresh& from);
  void MergeFrom(const shop_refresh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef shop_refresh_rtype rtype;
  static const rtype sync = shop_refresh_rtype_sync;
  static const rtype auto_refresh = shop_refresh_rtype_auto_refresh;
  static const rtype manual_refresh = shop_refresh_rtype_manual_refresh;
  static inline bool rtype_IsValid(int value) {
    return shop_refresh_rtype_IsValid(value);
  }
  static const rtype rtype_MIN =
    shop_refresh_rtype_rtype_MIN;
  static const rtype rtype_MAX =
    shop_refresh_rtype_rtype_MAX;
  static const int rtype_ARRAYSIZE =
    shop_refresh_rtype_rtype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  rtype_descriptor() {
    return shop_refresh_rtype_descriptor();
  }
  static inline const ::std::string& rtype_Name(rtype value) {
    return shop_refresh_rtype_Name(value);
  }
  static inline bool rtype_Parse(const ::std::string& name,
      rtype* value) {
    return shop_refresh_rtype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.shop_refresh.rtype _type = 1 [default = sync];
  inline bool has__type() const;
  inline void clear__type();
  static const int kTypeFieldNumber = 1;
  inline ::up::shop_refresh_rtype _type() const;
  inline void set__type(::up::shop_refresh_rtype value);

  // required uint32 _shop_id = 2;
  inline bool has__shop_id() const;
  inline void clear__shop_id();
  static const int kShopIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _shop_id() const;
  inline void set__shop_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.shop_refresh)
 private:
  inline void set_has__type();
  inline void clear_has__type();
  inline void set_has__shop_id();
  inline void clear_has__shop_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _type_;
  ::google::protobuf::uint32 _shop_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static shop_refresh* default_instance_;
};
// -------------------------------------------------------------------

class shop_consume : public ::google::protobuf::Message {
 public:
  shop_consume();
  virtual ~shop_consume();

  shop_consume(const shop_consume& from);

  inline shop_consume& operator=(const shop_consume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const shop_consume& default_instance();

  void Swap(shop_consume* other);

  // implements Message ----------------------------------------------

  shop_consume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const shop_consume& from);
  void MergeFrom(const shop_consume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _sid = 1;
  inline bool has__sid() const;
  inline void clear__sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::uint32 _sid() const;
  inline void set__sid(::google::protobuf::uint32 value);

  // required uint32 _slotid = 2;
  inline bool has__slotid() const;
  inline void clear__slotid();
  static const int kSlotidFieldNumber = 2;
  inline ::google::protobuf::uint32 _slotid() const;
  inline void set__slotid(::google::protobuf::uint32 value);

  // required uint32 _amount = 3;
  inline bool has__amount() const;
  inline void clear__amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint32 _amount() const;
  inline void set__amount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.shop_consume)
 private:
  inline void set_has__sid();
  inline void clear_has__sid();
  inline void set_has__slotid();
  inline void clear_has__slotid();
  inline void set_has__amount();
  inline void clear_has__amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _sid_;
  ::google::protobuf::uint32 _slotid_;
  ::google::protobuf::uint32 _amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static shop_consume* default_instance_;
};
// -------------------------------------------------------------------

class skill_levelup : public ::google::protobuf::Message {
 public:
  skill_levelup();
  virtual ~skill_levelup();

  skill_levelup(const skill_levelup& from);

  inline skill_levelup& operator=(const skill_levelup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const skill_levelup& default_instance();

  void Swap(skill_levelup* other);

  // implements Message ----------------------------------------------

  skill_levelup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const skill_levelup& from);
  void MergeFrom(const skill_levelup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _heroid = 1;
  inline bool has__heroid() const;
  inline void clear__heroid();
  static const int kHeroidFieldNumber = 1;
  inline ::google::protobuf::uint32 _heroid() const;
  inline void set__heroid(::google::protobuf::uint32 value);

  // repeated uint32 _order = 2;
  inline int _order_size() const;
  inline void clear__order();
  static const int kOrderFieldNumber = 2;
  inline ::google::protobuf::uint32 _order(int index) const;
  inline void set__order(int index, ::google::protobuf::uint32 value);
  inline void add__order(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _order() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__order();

  // @@protoc_insertion_point(class_scope:up.skill_levelup)
 private:
  inline void set_has__heroid();
  inline void clear_has__heroid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _order_;
  ::google::protobuf::uint32 _heroid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static skill_levelup* default_instance_;
};
// -------------------------------------------------------------------

class sell_item : public ::google::protobuf::Message {
 public:
  sell_item();
  virtual ~sell_item();

  sell_item(const sell_item& from);

  inline sell_item& operator=(const sell_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sell_item& default_instance();

  void Swap(sell_item* other);

  // implements Message ----------------------------------------------

  sell_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sell_item& from);
  void MergeFrom(const sell_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 _item = 1;
  inline int _item_size() const;
  inline void clear__item();
  static const int kItemFieldNumber = 1;
  inline ::google::protobuf::uint32 _item(int index) const;
  inline void set__item(int index, ::google::protobuf::uint32 value);
  inline void add__item(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _item() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__item();

  // @@protoc_insertion_point(class_scope:up.sell_item)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static sell_item* default_instance_;
};
// -------------------------------------------------------------------

class fragment_compose : public ::google::protobuf::Message {
 public:
  fragment_compose();
  virtual ~fragment_compose();

  fragment_compose(const fragment_compose& from);

  inline fragment_compose& operator=(const fragment_compose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fragment_compose& default_instance();

  void Swap(fragment_compose* other);

  // implements Message ----------------------------------------------

  fragment_compose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fragment_compose& from);
  void MergeFrom(const fragment_compose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _fragment = 1;
  inline bool has__fragment() const;
  inline void clear__fragment();
  static const int kFragmentFieldNumber = 1;
  inline ::google::protobuf::uint32 _fragment() const;
  inline void set__fragment(::google::protobuf::uint32 value);

  // required uint32 _frag_amount = 2;
  inline bool has__frag_amount() const;
  inline void clear__frag_amount();
  static const int kFragAmountFieldNumber = 2;
  inline ::google::protobuf::uint32 _frag_amount() const;
  inline void set__frag_amount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.fragment_compose)
 private:
  inline void set_has__fragment();
  inline void clear_has__fragment();
  inline void set_has__frag_amount();
  inline void clear_has__frag_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _fragment_;
  ::google::protobuf::uint32 _frag_amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static fragment_compose* default_instance_;
};
// -------------------------------------------------------------------

class hero_equip_upgrade : public ::google::protobuf::Message {
 public:
  hero_equip_upgrade();
  virtual ~hero_equip_upgrade();

  hero_equip_upgrade(const hero_equip_upgrade& from);

  inline hero_equip_upgrade& operator=(const hero_equip_upgrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_equip_upgrade& default_instance();

  void Swap(hero_equip_upgrade* other);

  // implements Message ----------------------------------------------

  hero_equip_upgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_equip_upgrade& from);
  void MergeFrom(const hero_equip_upgrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef hero_equip_upgrade_OP_TYPE OP_TYPE;
  static const OP_TYPE normal = hero_equip_upgrade_OP_TYPE_normal;
  static const OP_TYPE boss = hero_equip_upgrade_OP_TYPE_boss;
  static inline bool OP_TYPE_IsValid(int value) {
    return hero_equip_upgrade_OP_TYPE_IsValid(value);
  }
  static const OP_TYPE OP_TYPE_MIN =
    hero_equip_upgrade_OP_TYPE_OP_TYPE_MIN;
  static const OP_TYPE OP_TYPE_MAX =
    hero_equip_upgrade_OP_TYPE_OP_TYPE_MAX;
  static const int OP_TYPE_ARRAYSIZE =
    hero_equip_upgrade_OP_TYPE_OP_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OP_TYPE_descriptor() {
    return hero_equip_upgrade_OP_TYPE_descriptor();
  }
  static inline const ::std::string& OP_TYPE_Name(OP_TYPE value) {
    return hero_equip_upgrade_OP_TYPE_Name(value);
  }
  static inline bool OP_TYPE_Parse(const ::std::string& name,
      OP_TYPE* value) {
    return hero_equip_upgrade_OP_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.hero_equip_upgrade.OP_TYPE _op_type = 1 [default = normal];
  inline bool has__op_type() const;
  inline void clear__op_type();
  static const int kOpTypeFieldNumber = 1;
  inline ::up::hero_equip_upgrade_OP_TYPE _op_type() const;
  inline void set__op_type(::up::hero_equip_upgrade_OP_TYPE value);

  // required uint32 _heroid = 2;
  inline bool has__heroid() const;
  inline void clear__heroid();
  static const int kHeroidFieldNumber = 2;
  inline ::google::protobuf::uint32 _heroid() const;
  inline void set__heroid(::google::protobuf::uint32 value);

  // required uint32 _slot = 3;
  inline bool has__slot() const;
  inline void clear__slot();
  static const int kSlotFieldNumber = 3;
  inline ::google::protobuf::uint32 _slot() const;
  inline void set__slot(::google::protobuf::uint32 value);

  // repeated uint32 _materials = 4;
  inline int _materials_size() const;
  inline void clear__materials();
  static const int kMaterialsFieldNumber = 4;
  inline ::google::protobuf::uint32 _materials(int index) const;
  inline void set__materials(int index, ::google::protobuf::uint32 value);
  inline void add__materials(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _materials() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__materials();

  // @@protoc_insertion_point(class_scope:up.hero_equip_upgrade)
 private:
  inline void set_has__op_type();
  inline void clear_has__op_type();
  inline void set_has__heroid();
  inline void clear_has__heroid();
  inline void set_has__slot();
  inline void clear_has__slot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _op_type_;
  ::google::protobuf::uint32 _heroid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _materials_;
  ::google::protobuf::uint32 _slot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static hero_equip_upgrade* default_instance_;
};
// -------------------------------------------------------------------

class hero_equip : public ::google::protobuf::Message {
 public:
  hero_equip();
  virtual ~hero_equip();

  hero_equip(const hero_equip& from);

  inline hero_equip& operator=(const hero_equip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_equip& default_instance();

  void Swap(hero_equip* other);

  // implements Message ----------------------------------------------

  hero_equip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_equip& from);
  void MergeFrom(const hero_equip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _index = 1;
  inline bool has__index() const;
  inline void clear__index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 _index() const;
  inline void set__index(::google::protobuf::uint32 value);

  // required uint32 _item_id = 2;
  inline bool has__item_id() const;
  inline void clear__item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _item_id() const;
  inline void set__item_id(::google::protobuf::uint32 value);

  // required uint32 _exp = 3;
  inline bool has__exp() const;
  inline void clear__exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::uint32 _exp() const;
  inline void set__exp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.hero_equip)
 private:
  inline void set_has__index();
  inline void clear_has__index();
  inline void set_has__item_id();
  inline void clear_has__item_id();
  inline void set_has__exp();
  inline void clear_has__exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _index_;
  ::google::protobuf::uint32 _item_id_;
  ::google::protobuf::uint32 _exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static hero_equip* default_instance_;
};
// -------------------------------------------------------------------

class hero : public ::google::protobuf::Message {
 public:
  hero();
  virtual ~hero();

  hero(const hero& from);

  inline hero& operator=(const hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero& default_instance();

  void Swap(hero* other);

  // implements Message ----------------------------------------------

  hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero& from);
  void MergeFrom(const hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _tid = 1;
  inline bool has__tid() const;
  inline void clear__tid();
  static const int kTidFieldNumber = 1;
  inline ::google::protobuf::uint32 _tid() const;
  inline void set__tid(::google::protobuf::uint32 value);

  // optional uint32 _rank = 2;
  inline bool has__rank() const;
  inline void clear__rank();
  static const int kRankFieldNumber = 2;
  inline ::google::protobuf::uint32 _rank() const;
  inline void set__rank(::google::protobuf::uint32 value);

  // required uint32 _level = 3;
  inline bool has__level() const;
  inline void clear__level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 _level() const;
  inline void set__level(::google::protobuf::uint32 value);

  // required uint32 _stars = 4;
  inline bool has__stars() const;
  inline void clear__stars();
  static const int kStarsFieldNumber = 4;
  inline ::google::protobuf::uint32 _stars() const;
  inline void set__stars(::google::protobuf::uint32 value);

  // required uint32 _exp = 5;
  inline bool has__exp() const;
  inline void clear__exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::uint32 _exp() const;
  inline void set__exp(::google::protobuf::uint32 value);

  // required uint32 _gs = 6;
  inline bool has__gs() const;
  inline void clear__gs();
  static const int kGsFieldNumber = 6;
  inline ::google::protobuf::uint32 _gs() const;
  inline void set__gs(::google::protobuf::uint32 value);

  // required .up.hero_status _state = 7;
  inline bool has__state() const;
  inline void clear__state();
  static const int kStateFieldNumber = 7;
  inline ::up::hero_status _state() const;
  inline void set__state(::up::hero_status value);

  // repeated uint32 _skill_levels = 8;
  inline int _skill_levels_size() const;
  inline void clear__skill_levels();
  static const int kSkillLevelsFieldNumber = 8;
  inline ::google::protobuf::uint32 _skill_levels(int index) const;
  inline void set__skill_levels(int index, ::google::protobuf::uint32 value);
  inline void add__skill_levels(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _skill_levels() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__skill_levels();

  // repeated .up.hero_equip _items = 9;
  inline int _items_size() const;
  inline void clear__items();
  static const int kItemsFieldNumber = 9;
  inline const ::up::hero_equip& _items(int index) const;
  inline ::up::hero_equip* mutable__items(int index);
  inline ::up::hero_equip* add__items();
  inline const ::google::protobuf::RepeatedPtrField< ::up::hero_equip >&
      _items() const;
  inline ::google::protobuf::RepeatedPtrField< ::up::hero_equip >*
      mutable__items();

  // optional .up.hero_arousal _arousal = 10;
  inline bool has__arousal() const;
  inline void clear__arousal();
  static const int kArousalFieldNumber = 10;
  inline const ::up::hero_arousal& _arousal() const;
  inline ::up::hero_arousal* mutable__arousal();
  inline ::up::hero_arousal* release__arousal();
  inline void set_allocated__arousal(::up::hero_arousal* _arousal);

  // @@protoc_insertion_point(class_scope:up.hero)
 private:
  inline void set_has__tid();
  inline void clear_has__tid();
  inline void set_has__rank();
  inline void clear_has__rank();
  inline void set_has__level();
  inline void clear_has__level();
  inline void set_has__stars();
  inline void clear_has__stars();
  inline void set_has__exp();
  inline void clear_has__exp();
  inline void set_has__gs();
  inline void clear_has__gs();
  inline void set_has__state();
  inline void clear_has__state();
  inline void set_has__arousal();
  inline void clear_has__arousal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _tid_;
  ::google::protobuf::uint32 _rank_;
  ::google::protobuf::uint32 _level_;
  ::google::protobuf::uint32 _stars_;
  ::google::protobuf::uint32 _exp_;
  ::google::protobuf::uint32 _gs_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _skill_levels_;
  ::google::protobuf::RepeatedPtrField< ::up::hero_equip > _items_;
  ::up::hero_arousal* _arousal_;
  int _state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static hero* default_instance_;
};
// -------------------------------------------------------------------

class hero_arousal : public ::google::protobuf::Message {
 public:
  hero_arousal();
  virtual ~hero_arousal();

  hero_arousal(const hero_arousal& from);

  inline hero_arousal& operator=(const hero_arousal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_arousal& default_instance();

  void Swap(hero_arousal* other);

  // implements Message ----------------------------------------------

  hero_arousal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_arousal& from);
  void MergeFrom(const hero_arousal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _status = 1;
  inline bool has__status() const;
  inline void clear__status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::uint32 _status() const;
  inline void set__status(::google::protobuf::uint32 value);

  // required uint32 _str = 2;
  inline bool has__str() const;
  inline void clear__str();
  static const int kStrFieldNumber = 2;
  inline ::google::protobuf::uint32 _str() const;
  inline void set__str(::google::protobuf::uint32 value);

  // required uint32 _agi = 3;
  inline bool has__agi() const;
  inline void clear__agi();
  static const int kAgiFieldNumber = 3;
  inline ::google::protobuf::uint32 _agi() const;
  inline void set__agi(::google::protobuf::uint32 value);

  // required uint32 _int = 4;
  inline bool has__int() const;
  inline void clear__int();
  static const int kIntFieldNumber = 4;
  inline ::google::protobuf::uint32 _int() const;
  inline void set__int(::google::protobuf::uint32 value);

  // required int32 _str_var = 5;
  inline bool has__str_var() const;
  inline void clear__str_var();
  static const int kStrVarFieldNumber = 5;
  inline ::google::protobuf::int32 _str_var() const;
  inline void set__str_var(::google::protobuf::int32 value);

  // required int32 _agi_var = 6;
  inline bool has__agi_var() const;
  inline void clear__agi_var();
  static const int kAgiVarFieldNumber = 6;
  inline ::google::protobuf::int32 _agi_var() const;
  inline void set__agi_var(::google::protobuf::int32 value);

  // required int32 _int_var = 7;
  inline bool has__int_var() const;
  inline void clear__int_var();
  static const int kIntVarFieldNumber = 7;
  inline ::google::protobuf::int32 _int_var() const;
  inline void set__int_var(::google::protobuf::int32 value);

  // required uint32 _cost_gold = 8;
  inline bool has__cost_gold() const;
  inline void clear__cost_gold();
  static const int kCostGoldFieldNumber = 8;
  inline ::google::protobuf::uint32 _cost_gold() const;
  inline void set__cost_gold(::google::protobuf::uint32 value);

  // required uint32 _cost_diamond = 9;
  inline bool has__cost_diamond() const;
  inline void clear__cost_diamond();
  static const int kCostDiamondFieldNumber = 9;
  inline ::google::protobuf::uint32 _cost_diamond() const;
  inline void set__cost_diamond(::google::protobuf::uint32 value);

  // required uint32 _aro_exp = 10;
  inline bool has__aro_exp() const;
  inline void clear__aro_exp();
  static const int kAroExpFieldNumber = 10;
  inline ::google::protobuf::uint32 _aro_exp() const;
  inline void set__aro_exp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.hero_arousal)
 private:
  inline void set_has__status();
  inline void clear_has__status();
  inline void set_has__str();
  inline void clear_has__str();
  inline void set_has__agi();
  inline void clear_has__agi();
  inline void set_has__int();
  inline void clear_has__int();
  inline void set_has__str_var();
  inline void clear_has__str_var();
  inline void set_has__agi_var();
  inline void clear_has__agi_var();
  inline void set_has__int_var();
  inline void clear_has__int_var();
  inline void set_has__cost_gold();
  inline void clear_has__cost_gold();
  inline void set_has__cost_diamond();
  inline void clear_has__cost_diamond();
  inline void set_has__aro_exp();
  inline void clear_has__aro_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _status_;
  ::google::protobuf::uint32 _str_;
  ::google::protobuf::uint32 _agi_;
  ::google::protobuf::uint32 _int_;
  ::google::protobuf::int32 _str_var_;
  ::google::protobuf::int32 _agi_var_;
  ::google::protobuf::int32 _int_var_;
  ::google::protobuf::uint32 _cost_gold_;
  ::google::protobuf::uint32 _cost_diamond_;
  ::google::protobuf::uint32 _aro_exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static hero_arousal* default_instance_;
};
// -------------------------------------------------------------------

class tutorial : public ::google::protobuf::Message {
 public:
  tutorial();
  virtual ~tutorial();

  tutorial(const tutorial& from);

  inline tutorial& operator=(const tutorial& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tutorial& default_instance();

  void Swap(tutorial* other);

  // implements Message ----------------------------------------------

  tutorial* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tutorial& from);
  void MergeFrom(const tutorial& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 _record = 1;
  inline int _record_size() const;
  inline void clear__record();
  static const int kRecordFieldNumber = 1;
  inline ::google::protobuf::uint32 _record(int index) const;
  inline void set__record(int index, ::google::protobuf::uint32 value);
  inline void add__record(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _record() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__record();

  // @@protoc_insertion_point(class_scope:up.tutorial)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tutorial* default_instance_;
};
// -------------------------------------------------------------------

class trigger_task : public ::google::protobuf::Message {
 public:
  trigger_task();
  virtual ~trigger_task();

  trigger_task(const trigger_task& from);

  inline trigger_task& operator=(const trigger_task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const trigger_task& default_instance();

  void Swap(trigger_task* other);

  // implements Message ----------------------------------------------

  trigger_task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const trigger_task& from);
  void MergeFrom(const trigger_task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 _task = 1;
  inline int _task_size() const;
  inline void clear__task();
  static const int kTaskFieldNumber = 1;
  inline ::google::protobuf::uint32 _task(int index) const;
  inline void set__task(int index, ::google::protobuf::uint32 value);
  inline void add__task(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _task() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__task();

  // @@protoc_insertion_point(class_scope:up.trigger_task)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _task_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static trigger_task* default_instance_;
};
// -------------------------------------------------------------------

class require_rewards : public ::google::protobuf::Message {
 public:
  require_rewards();
  virtual ~require_rewards();

  require_rewards(const require_rewards& from);

  inline require_rewards& operator=(const require_rewards& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const require_rewards& default_instance();

  void Swap(require_rewards* other);

  // implements Message ----------------------------------------------

  require_rewards* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const require_rewards& from);
  void MergeFrom(const require_rewards& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _line = 1;
  inline bool has__line() const;
  inline void clear__line();
  static const int kLineFieldNumber = 1;
  inline ::google::protobuf::uint32 _line() const;
  inline void set__line(::google::protobuf::uint32 value);

  // required uint32 _id = 2;
  inline bool has__id() const;
  inline void clear__id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _id() const;
  inline void set__id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.require_rewards)
 private:
  inline void set_has__line();
  inline void clear_has__line();
  inline void set_has__id();
  inline void clear_has__id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _line_;
  ::google::protobuf::uint32 _id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static require_rewards* default_instance_;
};
// -------------------------------------------------------------------

class change_task_status : public ::google::protobuf::Message {
 public:
  change_task_status();
  virtual ~change_task_status();

  change_task_status(const change_task_status& from);

  inline change_task_status& operator=(const change_task_status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const change_task_status& default_instance();

  void Swap(change_task_status* other);

  // implements Message ----------------------------------------------

  change_task_status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const change_task_status& from);
  void MergeFrom(const change_task_status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _line = 1;
  inline bool has__line() const;
  inline void clear__line();
  static const int kLineFieldNumber = 1;
  inline ::google::protobuf::uint32 _line() const;
  inline void set__line(::google::protobuf::uint32 value);

  // required uint32 _id = 2;
  inline bool has__id() const;
  inline void clear__id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _id() const;
  inline void set__id(::google::protobuf::uint32 value);

  // required uint32 _operation = 3;
  inline bool has__operation() const;
  inline void clear__operation();
  static const int kOperationFieldNumber = 3;
  inline ::google::protobuf::uint32 _operation() const;
  inline void set__operation(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.change_task_status)
 private:
  inline void set_has__line();
  inline void clear_has__line();
  inline void set_has__id();
  inline void clear_has__id();
  inline void set_has__operation();
  inline void clear_has__operation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _line_;
  ::google::protobuf::uint32 _id_;
  ::google::protobuf::uint32 _operation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static change_task_status* default_instance_;
};
// -------------------------------------------------------------------

class trigger_job : public ::google::protobuf::Message {
 public:
  trigger_job();
  virtual ~trigger_job();

  trigger_job(const trigger_job& from);

  inline trigger_job& operator=(const trigger_job& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const trigger_job& default_instance();

  void Swap(trigger_job* other);

  // implements Message ----------------------------------------------

  trigger_job* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const trigger_job& from);
  void MergeFrom(const trigger_job& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 _jobs = 1;
  inline int _jobs_size() const;
  inline void clear__jobs();
  static const int kJobsFieldNumber = 1;
  inline ::google::protobuf::uint32 _jobs(int index) const;
  inline void set__jobs(int index, ::google::protobuf::uint32 value);
  inline void add__jobs(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _jobs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__jobs();

  // @@protoc_insertion_point(class_scope:up.trigger_job)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _jobs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static trigger_job* default_instance_;
};
// -------------------------------------------------------------------

class job_rewards : public ::google::protobuf::Message {
 public:
  job_rewards();
  virtual ~job_rewards();

  job_rewards(const job_rewards& from);

  inline job_rewards& operator=(const job_rewards& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const job_rewards& default_instance();

  void Swap(job_rewards* other);

  // implements Message ----------------------------------------------

  job_rewards* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const job_rewards& from);
  void MergeFrom(const job_rewards& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _job = 1;
  inline bool has__job() const;
  inline void clear__job();
  static const int kJobFieldNumber = 1;
  inline ::google::protobuf::uint32 _job() const;
  inline void set__job(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.job_rewards)
 private:
  inline void set_has__job();
  inline void clear_has__job();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _job_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static job_rewards* default_instance_;
};
// -------------------------------------------------------------------

class suspend_report : public ::google::protobuf::Message {
 public:
  suspend_report();
  virtual ~suspend_report();

  suspend_report(const suspend_report& from);

  inline suspend_report& operator=(const suspend_report& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const suspend_report& default_instance();

  void Swap(suspend_report* other);

  // implements Message ----------------------------------------------

  suspend_report* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const suspend_report& from);
  void MergeFrom(const suspend_report& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _gametime = 1;
  inline bool has__gametime() const;
  inline void clear__gametime();
  static const int kGametimeFieldNumber = 1;
  inline ::google::protobuf::uint32 _gametime() const;
  inline void set__gametime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.suspend_report)
 private:
  inline void set_has__gametime();
  inline void clear_has__gametime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _gametime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static suspend_report* default_instance_;
};
// -------------------------------------------------------------------

class reset_elite : public ::google::protobuf::Message {
 public:
  reset_elite();
  virtual ~reset_elite();

  reset_elite(const reset_elite& from);

  inline reset_elite& operator=(const reset_elite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reset_elite& default_instance();

  void Swap(reset_elite* other);

  // implements Message ----------------------------------------------

  reset_elite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reset_elite& from);
  void MergeFrom(const reset_elite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef reset_elite_rtype rtype;
  static const rtype daily_free = reset_elite_rtype_daily_free;
  static const rtype vip_reset = reset_elite_rtype_vip_reset;
  static inline bool rtype_IsValid(int value) {
    return reset_elite_rtype_IsValid(value);
  }
  static const rtype rtype_MIN =
    reset_elite_rtype_rtype_MIN;
  static const rtype rtype_MAX =
    reset_elite_rtype_rtype_MAX;
  static const int rtype_ARRAYSIZE =
    reset_elite_rtype_rtype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  rtype_descriptor() {
    return reset_elite_rtype_descriptor();
  }
  static inline const ::std::string& rtype_Name(rtype value) {
    return reset_elite_rtype_Name(value);
  }
  static inline bool rtype_Parse(const ::std::string& name,
      rtype* value) {
    return reset_elite_rtype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.reset_elite.rtype _type = 1 [default = daily_free];
  inline bool has__type() const;
  inline void clear__type();
  static const int kTypeFieldNumber = 1;
  inline ::up::reset_elite_rtype _type() const;
  inline void set__type(::up::reset_elite_rtype value);

  // optional uint32 _stageid = 2;
  inline bool has__stageid() const;
  inline void clear__stageid();
  static const int kStageidFieldNumber = 2;
  inline ::google::protobuf::uint32 _stageid() const;
  inline void set__stageid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.reset_elite)
 private:
  inline void set_has__type();
  inline void clear_has__type();
  inline void set_has__stageid();
  inline void clear_has__stageid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _type_;
  ::google::protobuf::uint32 _stageid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static reset_elite* default_instance_;
};
// -------------------------------------------------------------------

class sweep_stage : public ::google::protobuf::Message {
 public:
  sweep_stage();
  virtual ~sweep_stage();

  sweep_stage(const sweep_stage& from);

  inline sweep_stage& operator=(const sweep_stage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sweep_stage& default_instance();

  void Swap(sweep_stage* other);

  // implements Message ----------------------------------------------

  sweep_stage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sweep_stage& from);
  void MergeFrom(const sweep_stage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef sweep_stage_rtype rtype;
  static const rtype sweep_with_ticket = sweep_stage_rtype_sweep_with_ticket;
  static const rtype sweep_with_rmb = sweep_stage_rtype_sweep_with_rmb;
  static inline bool rtype_IsValid(int value) {
    return sweep_stage_rtype_IsValid(value);
  }
  static const rtype rtype_MIN =
    sweep_stage_rtype_rtype_MIN;
  static const rtype rtype_MAX =
    sweep_stage_rtype_rtype_MAX;
  static const int rtype_ARRAYSIZE =
    sweep_stage_rtype_rtype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  rtype_descriptor() {
    return sweep_stage_rtype_descriptor();
  }
  static inline const ::std::string& rtype_Name(rtype value) {
    return sweep_stage_rtype_Name(value);
  }
  static inline bool rtype_Parse(const ::std::string& name,
      rtype* value) {
    return sweep_stage_rtype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.sweep_stage.rtype _type = 1;
  inline bool has__type() const;
  inline void clear__type();
  static const int kTypeFieldNumber = 1;
  inline ::up::sweep_stage_rtype _type() const;
  inline void set__type(::up::sweep_stage_rtype value);

  // required uint32 _stageid = 2;
  inline bool has__stageid() const;
  inline void clear__stageid();
  static const int kStageidFieldNumber = 2;
  inline ::google::protobuf::uint32 _stageid() const;
  inline void set__stageid(::google::protobuf::uint32 value);

  // optional uint32 _times = 3;
  inline bool has__times() const;
  inline void clear__times();
  static const int kTimesFieldNumber = 3;
  inline ::google::protobuf::uint32 _times() const;
  inline void set__times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.sweep_stage)
 private:
  inline void set_has__type();
  inline void clear_has__type();
  inline void set_has__stageid();
  inline void clear_has__stageid();
  inline void set_has__times();
  inline void clear_has__times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _type_;
  ::google::protobuf::uint32 _stageid_;
  ::google::protobuf::uint32 _times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static sweep_stage* default_instance_;
};
// -------------------------------------------------------------------

class buy_skill_stren_point : public ::google::protobuf::Message {
 public:
  buy_skill_stren_point();
  virtual ~buy_skill_stren_point();

  buy_skill_stren_point(const buy_skill_stren_point& from);

  inline buy_skill_stren_point& operator=(const buy_skill_stren_point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buy_skill_stren_point& default_instance();

  void Swap(buy_skill_stren_point* other);

  // implements Message ----------------------------------------------

  buy_skill_stren_point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buy_skill_stren_point& from);
  void MergeFrom(const buy_skill_stren_point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.buy_skill_stren_point)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static buy_skill_stren_point* default_instance_;
};
// -------------------------------------------------------------------

class ask_magicsoul : public ::google::protobuf::Message {
 public:
  ask_magicsoul();
  virtual ~ask_magicsoul();

  ask_magicsoul(const ask_magicsoul& from);

  inline ask_magicsoul& operator=(const ask_magicsoul& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ask_magicsoul& default_instance();

  void Swap(ask_magicsoul* other);

  // implements Message ----------------------------------------------

  ask_magicsoul* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ask_magicsoul& from);
  void MergeFrom(const ask_magicsoul& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.ask_magicsoul)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static ask_magicsoul* default_instance_;
};
// -------------------------------------------------------------------

class tavern_draw : public ::google::protobuf::Message {
 public:
  tavern_draw();
  virtual ~tavern_draw();

  tavern_draw(const tavern_draw& from);

  inline tavern_draw& operator=(const tavern_draw& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tavern_draw& default_instance();

  void Swap(tavern_draw* other);

  // implements Message ----------------------------------------------

  tavern_draw* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tavern_draw& from);
  void MergeFrom(const tavern_draw& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef tavern_draw_draw_type draw_type;
  static const draw_type single = tavern_draw_draw_type_single;
  static const draw_type combo = tavern_draw_draw_type_combo;
  static const draw_type stone = tavern_draw_draw_type_stone;
  static const draw_type free = tavern_draw_draw_type_free;
  static inline bool draw_type_IsValid(int value) {
    return tavern_draw_draw_type_IsValid(value);
  }
  static const draw_type draw_type_MIN =
    tavern_draw_draw_type_draw_type_MIN;
  static const draw_type draw_type_MAX =
    tavern_draw_draw_type_draw_type_MAX;
  static const int draw_type_ARRAYSIZE =
    tavern_draw_draw_type_draw_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  draw_type_descriptor() {
    return tavern_draw_draw_type_descriptor();
  }
  static inline const ::std::string& draw_type_Name(draw_type value) {
    return tavern_draw_draw_type_Name(value);
  }
  static inline bool draw_type_Parse(const ::std::string& name,
      draw_type* value) {
    return tavern_draw_draw_type_Parse(name, value);
  }

  typedef tavern_draw_box_type box_type;
  static const box_type green = tavern_draw_box_type_green;
  static const box_type blue = tavern_draw_box_type_blue;
  static const box_type purple = tavern_draw_box_type_purple;
  static const box_type magicsoul = tavern_draw_box_type_magicsoul;
  static const box_type stone_green = tavern_draw_box_type_stone_green;
  static const box_type stone_blue = tavern_draw_box_type_stone_blue;
  static const box_type stone_purple = tavern_draw_box_type_stone_purple;
  static inline bool box_type_IsValid(int value) {
    return tavern_draw_box_type_IsValid(value);
  }
  static const box_type box_type_MIN =
    tavern_draw_box_type_box_type_MIN;
  static const box_type box_type_MAX =
    tavern_draw_box_type_box_type_MAX;
  static const int box_type_ARRAYSIZE =
    tavern_draw_box_type_box_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  box_type_descriptor() {
    return tavern_draw_box_type_descriptor();
  }
  static inline const ::std::string& box_type_Name(box_type value) {
    return tavern_draw_box_type_Name(value);
  }
  static inline bool box_type_Parse(const ::std::string& name,
      box_type* value) {
    return tavern_draw_box_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.tavern_draw.draw_type _draw_type = 1 [default = single];
  inline bool has__draw_type() const;
  inline void clear__draw_type();
  static const int kDrawTypeFieldNumber = 1;
  inline ::up::tavern_draw_draw_type _draw_type() const;
  inline void set__draw_type(::up::tavern_draw_draw_type value);

  // required .up.tavern_draw.box_type _box_type = 2 [default = green];
  inline bool has__box_type() const;
  inline void clear__box_type();
  static const int kBoxTypeFieldNumber = 2;
  inline ::up::tavern_draw_box_type _box_type() const;
  inline void set__box_type(::up::tavern_draw_box_type value);

  // @@protoc_insertion_point(class_scope:up.tavern_draw)
 private:
  inline void set_has__draw_type();
  inline void clear_has__draw_type();
  inline void set_has__box_type();
  inline void clear_has__box_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _draw_type_;
  int _box_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tavern_draw* default_instance_;
};
// -------------------------------------------------------------------

class hero_evolve : public ::google::protobuf::Message {
 public:
  hero_evolve();
  virtual ~hero_evolve();

  hero_evolve(const hero_evolve& from);

  inline hero_evolve& operator=(const hero_evolve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_evolve& default_instance();

  void Swap(hero_evolve* other);

  // implements Message ----------------------------------------------

  hero_evolve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_evolve& from);
  void MergeFrom(const hero_evolve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _heroid = 1;
  inline bool has__heroid() const;
  inline void clear__heroid();
  static const int kHeroidFieldNumber = 1;
  inline ::google::protobuf::uint32 _heroid() const;
  inline void set__heroid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.hero_evolve)
 private:
  inline void set_has__heroid();
  inline void clear_has__heroid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _heroid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static hero_evolve* default_instance_;
};
// -------------------------------------------------------------------

class enter_act_stage : public ::google::protobuf::Message {
 public:
  enter_act_stage();
  virtual ~enter_act_stage();

  enter_act_stage(const enter_act_stage& from);

  inline enter_act_stage& operator=(const enter_act_stage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const enter_act_stage& default_instance();

  void Swap(enter_act_stage* other);

  // implements Message ----------------------------------------------

  enter_act_stage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const enter_act_stage& from);
  void MergeFrom(const enter_act_stage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _stage_group = 1;
  inline bool has__stage_group() const;
  inline void clear__stage_group();
  static const int kStageGroupFieldNumber = 1;
  inline ::google::protobuf::uint32 _stage_group() const;
  inline void set__stage_group(::google::protobuf::uint32 value);

  // required uint32 _stage = 2;
  inline bool has__stage() const;
  inline void clear__stage();
  static const int kStageFieldNumber = 2;
  inline ::google::protobuf::uint32 _stage() const;
  inline void set__stage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.enter_act_stage)
 private:
  inline void set_has__stage_group();
  inline void clear_has__stage_group();
  inline void set_has__stage();
  inline void clear_has__stage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _stage_group_;
  ::google::protobuf::uint32 _stage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static enter_act_stage* default_instance_;
};
// -------------------------------------------------------------------

class ladder : public ::google::protobuf::Message {
 public:
  ladder();
  virtual ~ladder();

  ladder(const ladder& from);

  inline ladder& operator=(const ladder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ladder& default_instance();

  void Swap(ladder* other);

  // implements Message ----------------------------------------------

  ladder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ladder& from);
  void MergeFrom(const ladder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .up.open_panel _open_panel = 1;
  inline bool has__open_panel() const;
  inline void clear__open_panel();
  static const int kOpenPanelFieldNumber = 1;
  inline const ::up::open_panel& _open_panel() const;
  inline ::up::open_panel* mutable__open_panel();
  inline ::up::open_panel* release__open_panel();
  inline void set_allocated__open_panel(::up::open_panel* _open_panel);

  // optional .up.apply_opponent _apply_opponent = 2;
  inline bool has__apply_opponent() const;
  inline void clear__apply_opponent();
  static const int kApplyOpponentFieldNumber = 2;
  inline const ::up::apply_opponent& _apply_opponent() const;
  inline ::up::apply_opponent* mutable__apply_opponent();
  inline ::up::apply_opponent* release__apply_opponent();
  inline void set_allocated__apply_opponent(::up::apply_opponent* _apply_opponent);

  // optional .up.start_battle _start_battle = 3;
  inline bool has__start_battle() const;
  inline void clear__start_battle();
  static const int kStartBattleFieldNumber = 3;
  inline const ::up::start_battle& _start_battle() const;
  inline ::up::start_battle* mutable__start_battle();
  inline ::up::start_battle* release__start_battle();
  inline void set_allocated__start_battle(::up::start_battle* _start_battle);

  // optional .up.end_battle _end_battle = 4;
  inline bool has__end_battle() const;
  inline void clear__end_battle();
  static const int kEndBattleFieldNumber = 4;
  inline const ::up::end_battle& _end_battle() const;
  inline ::up::end_battle* mutable__end_battle();
  inline ::up::end_battle* release__end_battle();
  inline void set_allocated__end_battle(::up::end_battle* _end_battle);

  // optional .up.set_lineup _set_lineup = 5;
  inline bool has__set_lineup() const;
  inline void clear__set_lineup();
  static const int kSetLineupFieldNumber = 5;
  inline const ::up::set_lineup& _set_lineup() const;
  inline ::up::set_lineup* mutable__set_lineup();
  inline ::up::set_lineup* release__set_lineup();
  inline void set_allocated__set_lineup(::up::set_lineup* _set_lineup);

  // optional .up.query_records _query_records = 6;
  inline bool has__query_records() const;
  inline void clear__query_records();
  static const int kQueryRecordsFieldNumber = 6;
  inline const ::up::query_records& _query_records() const;
  inline ::up::query_records* mutable__query_records();
  inline ::up::query_records* release__query_records();
  inline void set_allocated__query_records(::up::query_records* _query_records);

  // optional .up.query_replay _query_replay = 7;
  inline bool has__query_replay() const;
  inline void clear__query_replay();
  static const int kQueryReplayFieldNumber = 7;
  inline const ::up::query_replay& _query_replay() const;
  inline ::up::query_replay* mutable__query_replay();
  inline ::up::query_replay* release__query_replay();
  inline void set_allocated__query_replay(::up::query_replay* _query_replay);

  // optional .up.query_rankboard _query_rankboard = 8;
  inline bool has__query_rankboard() const;
  inline void clear__query_rankboard();
  static const int kQueryRankboardFieldNumber = 8;
  inline const ::up::query_rankboard& _query_rankboard() const;
  inline ::up::query_rankboard* mutable__query_rankboard();
  inline ::up::query_rankboard* release__query_rankboard();
  inline void set_allocated__query_rankboard(::up::query_rankboard* _query_rankboard);

  // optional .up.query_oppo_info _query_oppo = 9;
  inline bool has__query_oppo() const;
  inline void clear__query_oppo();
  static const int kQueryOppoFieldNumber = 9;
  inline const ::up::query_oppo_info& _query_oppo() const;
  inline ::up::query_oppo_info* mutable__query_oppo();
  inline ::up::query_oppo_info* release__query_oppo();
  inline void set_allocated__query_oppo(::up::query_oppo_info* _query_oppo);

  // optional .up.clear_battle_cd _clear_battle_cd = 10;
  inline bool has__clear_battle_cd() const;
  inline void clear__clear_battle_cd();
  static const int kClearBattleCdFieldNumber = 10;
  inline const ::up::clear_battle_cd& _clear_battle_cd() const;
  inline ::up::clear_battle_cd* mutable__clear_battle_cd();
  inline ::up::clear_battle_cd* release__clear_battle_cd();
  inline void set_allocated__clear_battle_cd(::up::clear_battle_cd* _clear_battle_cd);

  // optional .up.draw_rank_reward _draw_rank_reward = 11;
  inline bool has__draw_rank_reward() const;
  inline void clear__draw_rank_reward();
  static const int kDrawRankRewardFieldNumber = 11;
  inline const ::up::draw_rank_reward& _draw_rank_reward() const;
  inline ::up::draw_rank_reward* mutable__draw_rank_reward();
  inline ::up::draw_rank_reward* release__draw_rank_reward();
  inline void set_allocated__draw_rank_reward(::up::draw_rank_reward* _draw_rank_reward);

  // optional .up.buy_battle_chance _buy_battle_chance = 12;
  inline bool has__buy_battle_chance() const;
  inline void clear__buy_battle_chance();
  static const int kBuyBattleChanceFieldNumber = 12;
  inline const ::up::buy_battle_chance& _buy_battle_chance() const;
  inline ::up::buy_battle_chance* mutable__buy_battle_chance();
  inline ::up::buy_battle_chance* release__buy_battle_chance();
  inline void set_allocated__buy_battle_chance(::up::buy_battle_chance* _buy_battle_chance);

  // @@protoc_insertion_point(class_scope:up.ladder)
 private:
  inline void set_has__open_panel();
  inline void clear_has__open_panel();
  inline void set_has__apply_opponent();
  inline void clear_has__apply_opponent();
  inline void set_has__start_battle();
  inline void clear_has__start_battle();
  inline void set_has__end_battle();
  inline void clear_has__end_battle();
  inline void set_has__set_lineup();
  inline void clear_has__set_lineup();
  inline void set_has__query_records();
  inline void clear_has__query_records();
  inline void set_has__query_replay();
  inline void clear_has__query_replay();
  inline void set_has__query_rankboard();
  inline void clear_has__query_rankboard();
  inline void set_has__query_oppo();
  inline void clear_has__query_oppo();
  inline void set_has__clear_battle_cd();
  inline void clear_has__clear_battle_cd();
  inline void set_has__draw_rank_reward();
  inline void clear_has__draw_rank_reward();
  inline void set_has__buy_battle_chance();
  inline void clear_has__buy_battle_chance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::up::open_panel* _open_panel_;
  ::up::apply_opponent* _apply_opponent_;
  ::up::start_battle* _start_battle_;
  ::up::end_battle* _end_battle_;
  ::up::set_lineup* _set_lineup_;
  ::up::query_records* _query_records_;
  ::up::query_replay* _query_replay_;
  ::up::query_rankboard* _query_rankboard_;
  ::up::query_oppo_info* _query_oppo_;
  ::up::clear_battle_cd* _clear_battle_cd_;
  ::up::draw_rank_reward* _draw_rank_reward_;
  ::up::buy_battle_chance* _buy_battle_chance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static ladder* default_instance_;
};
// -------------------------------------------------------------------

class open_panel : public ::google::protobuf::Message {
 public:
  open_panel();
  virtual ~open_panel();

  open_panel(const open_panel& from);

  inline open_panel& operator=(const open_panel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const open_panel& default_instance();

  void Swap(open_panel* other);

  // implements Message ----------------------------------------------

  open_panel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const open_panel& from);
  void MergeFrom(const open_panel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.open_panel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static open_panel* default_instance_;
};
// -------------------------------------------------------------------

class apply_opponent : public ::google::protobuf::Message {
 public:
  apply_opponent();
  virtual ~apply_opponent();

  apply_opponent(const apply_opponent& from);

  inline apply_opponent& operator=(const apply_opponent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const apply_opponent& default_instance();

  void Swap(apply_opponent* other);

  // implements Message ----------------------------------------------

  apply_opponent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const apply_opponent& from);
  void MergeFrom(const apply_opponent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.apply_opponent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static apply_opponent* default_instance_;
};
// -------------------------------------------------------------------

class start_battle : public ::google::protobuf::Message {
 public:
  start_battle();
  virtual ~start_battle();

  start_battle(const start_battle& from);

  inline start_battle& operator=(const start_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_battle& default_instance();

  void Swap(start_battle* other);

  // implements Message ----------------------------------------------

  start_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_battle& from);
  void MergeFrom(const start_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _oppo_user_id = 1;
  inline bool has__oppo_user_id() const;
  inline void clear__oppo_user_id();
  static const int kOppoUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _oppo_user_id() const;
  inline void set__oppo_user_id(::google::protobuf::uint32 value);

  // repeated uint32 _attack_lineup = 2;
  inline int _attack_lineup_size() const;
  inline void clear__attack_lineup();
  static const int kAttackLineupFieldNumber = 2;
  inline ::google::protobuf::uint32 _attack_lineup(int index) const;
  inline void set__attack_lineup(int index, ::google::protobuf::uint32 value);
  inline void add__attack_lineup(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _attack_lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__attack_lineup();

  // @@protoc_insertion_point(class_scope:up.start_battle)
 private:
  inline void set_has__oppo_user_id();
  inline void clear_has__oppo_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _attack_lineup_;
  ::google::protobuf::uint32 _oppo_user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static start_battle* default_instance_;
};
// -------------------------------------------------------------------

class end_battle : public ::google::protobuf::Message {
 public:
  end_battle();
  virtual ~end_battle();

  end_battle(const end_battle& from);

  inline end_battle& operator=(const end_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const end_battle& default_instance();

  void Swap(end_battle* other);

  // implements Message ----------------------------------------------

  end_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const end_battle& from);
  void MergeFrom(const end_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.battle_result _result = 1;
  inline bool has__result() const;
  inline void clear__result();
  static const int kResultFieldNumber = 1;
  inline ::up::battle_result _result() const;
  inline void set__result(::up::battle_result value);

  // @@protoc_insertion_point(class_scope:up.end_battle)
 private:
  inline void set_has__result();
  inline void clear_has__result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static end_battle* default_instance_;
};
// -------------------------------------------------------------------

class set_lineup : public ::google::protobuf::Message {
 public:
  set_lineup();
  virtual ~set_lineup();

  set_lineup(const set_lineup& from);

  inline set_lineup& operator=(const set_lineup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const set_lineup& default_instance();

  void Swap(set_lineup* other);

  // implements Message ----------------------------------------------

  set_lineup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const set_lineup& from);
  void MergeFrom(const set_lineup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 _lineup = 1;
  inline int _lineup_size() const;
  inline void clear__lineup();
  static const int kLineupFieldNumber = 1;
  inline ::google::protobuf::uint32 _lineup(int index) const;
  inline void set__lineup(int index, ::google::protobuf::uint32 value);
  inline void add__lineup(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__lineup();

  // @@protoc_insertion_point(class_scope:up.set_lineup)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _lineup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static set_lineup* default_instance_;
};
// -------------------------------------------------------------------

class query_records : public ::google::protobuf::Message {
 public:
  query_records();
  virtual ~query_records();

  query_records(const query_records& from);

  inline query_records& operator=(const query_records& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_records& default_instance();

  void Swap(query_records* other);

  // implements Message ----------------------------------------------

  query_records* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_records& from);
  void MergeFrom(const query_records& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.query_records)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_records* default_instance_;
};
// -------------------------------------------------------------------

class query_replay : public ::google::protobuf::Message {
 public:
  query_replay();
  virtual ~query_replay();

  query_replay(const query_replay& from);

  inline query_replay& operator=(const query_replay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_replay& default_instance();

  void Swap(query_replay* other);

  // implements Message ----------------------------------------------

  query_replay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_replay& from);
  void MergeFrom(const query_replay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _record_index = 1;
  inline bool has__record_index() const;
  inline void clear__record_index();
  static const int kRecordIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 _record_index() const;
  inline void set__record_index(::google::protobuf::uint32 value);

  // optional uint32 _record_svrid = 2;
  inline bool has__record_svrid() const;
  inline void clear__record_svrid();
  static const int kRecordSvridFieldNumber = 2;
  inline ::google::protobuf::uint32 _record_svrid() const;
  inline void set__record_svrid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.query_replay)
 private:
  inline void set_has__record_index();
  inline void clear_has__record_index();
  inline void set_has__record_svrid();
  inline void clear_has__record_svrid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _record_index_;
  ::google::protobuf::uint32 _record_svrid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_replay* default_instance_;
};
// -------------------------------------------------------------------

class sync_skill_stren : public ::google::protobuf::Message {
 public:
  sync_skill_stren();
  virtual ~sync_skill_stren();

  sync_skill_stren(const sync_skill_stren& from);

  inline sync_skill_stren& operator=(const sync_skill_stren& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sync_skill_stren& default_instance();

  void Swap(sync_skill_stren* other);

  // implements Message ----------------------------------------------

  sync_skill_stren* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sync_skill_stren& from);
  void MergeFrom(const sync_skill_stren& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.sync_skill_stren)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static sync_skill_stren* default_instance_;
};
// -------------------------------------------------------------------

class query_rankboard : public ::google::protobuf::Message {
 public:
  query_rankboard();
  virtual ~query_rankboard();

  query_rankboard(const query_rankboard& from);

  inline query_rankboard& operator=(const query_rankboard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_rankboard& default_instance();

  void Swap(query_rankboard* other);

  // implements Message ----------------------------------------------

  query_rankboard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_rankboard& from);
  void MergeFrom(const query_rankboard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef query_rankboard_rankboard_type rankboard_type;
  static const rankboard_type static_c = query_rankboard_rankboard_type_static_c;
  static const rankboard_type dynamic = query_rankboard_rankboard_type_dynamic;
  static inline bool rankboard_type_IsValid(int value) {
    return query_rankboard_rankboard_type_IsValid(value);
  }
  static const rankboard_type rankboard_type_MIN =
    query_rankboard_rankboard_type_rankboard_type_MIN;
  static const rankboard_type rankboard_type_MAX =
    query_rankboard_rankboard_type_rankboard_type_MAX;
  static const int rankboard_type_ARRAYSIZE =
    query_rankboard_rankboard_type_rankboard_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  rankboard_type_descriptor() {
    return query_rankboard_rankboard_type_descriptor();
  }
  static inline const ::std::string& rankboard_type_Name(rankboard_type value) {
    return query_rankboard_rankboard_type_Name(value);
  }
  static inline bool rankboard_type_Parse(const ::std::string& name,
      rankboard_type* value) {
    return query_rankboard_rankboard_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.query_rankboard.rankboard_type _type = 1;
  inline bool has__type() const;
  inline void clear__type();
  static const int kTypeFieldNumber = 1;
  inline ::up::query_rankboard_rankboard_type _type() const;
  inline void set__type(::up::query_rankboard_rankboard_type value);

  // @@protoc_insertion_point(class_scope:up.query_rankboard)
 private:
  inline void set_has__type();
  inline void clear_has__type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_rankboard* default_instance_;
};
// -------------------------------------------------------------------

class query_oppo_info : public ::google::protobuf::Message {
 public:
  query_oppo_info();
  virtual ~query_oppo_info();

  query_oppo_info(const query_oppo_info& from);

  inline query_oppo_info& operator=(const query_oppo_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_oppo_info& default_instance();

  void Swap(query_oppo_info* other);

  // implements Message ----------------------------------------------

  query_oppo_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_oppo_info& from);
  void MergeFrom(const query_oppo_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _oppo_user_id = 1;
  inline bool has__oppo_user_id() const;
  inline void clear__oppo_user_id();
  static const int kOppoUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _oppo_user_id() const;
  inline void set__oppo_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.query_oppo_info)
 private:
  inline void set_has__oppo_user_id();
  inline void clear_has__oppo_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _oppo_user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_oppo_info* default_instance_;
};
// -------------------------------------------------------------------

class clear_battle_cd : public ::google::protobuf::Message {
 public:
  clear_battle_cd();
  virtual ~clear_battle_cd();

  clear_battle_cd(const clear_battle_cd& from);

  inline clear_battle_cd& operator=(const clear_battle_cd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const clear_battle_cd& default_instance();

  void Swap(clear_battle_cd* other);

  // implements Message ----------------------------------------------

  clear_battle_cd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const clear_battle_cd& from);
  void MergeFrom(const clear_battle_cd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.clear_battle_cd)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static clear_battle_cd* default_instance_;
};
// -------------------------------------------------------------------

class draw_rank_reward : public ::google::protobuf::Message {
 public:
  draw_rank_reward();
  virtual ~draw_rank_reward();

  draw_rank_reward(const draw_rank_reward& from);

  inline draw_rank_reward& operator=(const draw_rank_reward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const draw_rank_reward& default_instance();

  void Swap(draw_rank_reward* other);

  // implements Message ----------------------------------------------

  draw_rank_reward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const draw_rank_reward& from);
  void MergeFrom(const draw_rank_reward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.draw_rank_reward)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static draw_rank_reward* default_instance_;
};
// -------------------------------------------------------------------

class buy_battle_chance : public ::google::protobuf::Message {
 public:
  buy_battle_chance();
  virtual ~buy_battle_chance();

  buy_battle_chance(const buy_battle_chance& from);

  inline buy_battle_chance& operator=(const buy_battle_chance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buy_battle_chance& default_instance();

  void Swap(buy_battle_chance* other);

  // implements Message ----------------------------------------------

  buy_battle_chance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buy_battle_chance& from);
  void MergeFrom(const buy_battle_chance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.buy_battle_chance)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static buy_battle_chance* default_instance_;
};
// -------------------------------------------------------------------

class set_name : public ::google::protobuf::Message {
 public:
  set_name();
  virtual ~set_name();

  set_name(const set_name& from);

  inline set_name& operator=(const set_name& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const set_name& default_instance();

  void Swap(set_name* other);

  // implements Message ----------------------------------------------

  set_name* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const set_name& from);
  void MergeFrom(const set_name& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef set_name_set_type set_type;
  static const set_type free = set_name_set_type_free;
  static const set_type rmb = set_name_set_type_rmb;
  static inline bool set_type_IsValid(int value) {
    return set_name_set_type_IsValid(value);
  }
  static const set_type set_type_MIN =
    set_name_set_type_set_type_MIN;
  static const set_type set_type_MAX =
    set_name_set_type_set_type_MAX;
  static const int set_type_ARRAYSIZE =
    set_name_set_type_set_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  set_type_descriptor() {
    return set_name_set_type_descriptor();
  }
  static inline const ::std::string& set_type_Name(set_type value) {
    return set_name_set_type_Name(value);
  }
  static inline bool set_type_Parse(const ::std::string& name,
      set_type* value) {
    return set_name_set_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.set_name.set_type _type = 1;
  inline bool has__type() const;
  inline void clear__type();
  static const int kTypeFieldNumber = 1;
  inline ::up::set_name_set_type _type() const;
  inline void set__type(::up::set_name_set_type value);

  // required string _name = 2;
  inline bool has__name() const;
  inline void clear__name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& _name() const;
  inline void set__name(const ::std::string& value);
  inline void set__name(const char* value);
  inline void set__name(const char* value, size_t size);
  inline ::std::string* mutable__name();
  inline ::std::string* release__name();
  inline void set_allocated__name(::std::string* _name);

  // @@protoc_insertion_point(class_scope:up.set_name)
 private:
  inline void set_has__type();
  inline void clear_has__type();
  inline void set_has__name();
  inline void clear_has__name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _name_;
  int _type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static set_name* default_instance_;
};
// -------------------------------------------------------------------

class set_avatar : public ::google::protobuf::Message {
 public:
  set_avatar();
  virtual ~set_avatar();

  set_avatar(const set_avatar& from);

  inline set_avatar& operator=(const set_avatar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const set_avatar& default_instance();

  void Swap(set_avatar* other);

  // implements Message ----------------------------------------------

  set_avatar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const set_avatar& from);
  void MergeFrom(const set_avatar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _avatar = 1;
  inline bool has__avatar() const;
  inline void clear__avatar();
  static const int kAvatarFieldNumber = 1;
  inline ::google::protobuf::uint32 _avatar() const;
  inline void set__avatar(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.set_avatar)
 private:
  inline void set_has__avatar();
  inline void clear_has__avatar();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _avatar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static set_avatar* default_instance_;
};
// -------------------------------------------------------------------

class query_data : public ::google::protobuf::Message {
 public:
  query_data();
  virtual ~query_data();

  query_data(const query_data& from);

  inline query_data& operator=(const query_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_data& default_instance();

  void Swap(query_data* other);

  // implements Message ----------------------------------------------

  query_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_data& from);
  void MergeFrom(const query_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef query_data_query_type query_type;
  static const query_type rmb = query_data_query_type_rmb;
  static const query_type hero = query_data_query_type_hero;
  static const query_type recharge = query_data_query_type_recharge;
  static const query_type monthcard = query_data_query_type_monthcard;
  static inline bool query_type_IsValid(int value) {
    return query_data_query_type_IsValid(value);
  }
  static const query_type query_type_MIN =
    query_data_query_type_query_type_MIN;
  static const query_type query_type_MAX =
    query_data_query_type_query_type_MAX;
  static const int query_type_ARRAYSIZE =
    query_data_query_type_query_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  query_type_descriptor() {
    return query_data_query_type_descriptor();
  }
  static inline const ::std::string& query_type_Name(query_type value) {
    return query_data_query_type_Name(value);
  }
  static inline bool query_type_Parse(const ::std::string& name,
      query_type* value) {
    return query_data_query_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .up.query_data.query_type _type = 1;
  inline int _type_size() const;
  inline void clear__type();
  static const int kTypeFieldNumber = 1;
  inline ::up::query_data_query_type _type(int index) const;
  inline void set__type(int index, ::up::query_data_query_type value);
  inline void add__type(::up::query_data_query_type value);
  inline const ::google::protobuf::RepeatedField<int>& _type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable__type();

  // repeated uint32 _query_heroes = 2;
  inline int _query_heroes_size() const;
  inline void clear__query_heroes();
  static const int kQueryHeroesFieldNumber = 2;
  inline ::google::protobuf::uint32 _query_heroes(int index) const;
  inline void set__query_heroes(int index, ::google::protobuf::uint32 value);
  inline void add__query_heroes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _query_heroes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__query_heroes();

  // repeated uint32 _month_card_id = 3;
  inline int _month_card_id_size() const;
  inline void clear__month_card_id();
  static const int kMonthCardIdFieldNumber = 3;
  inline ::google::protobuf::uint32 _month_card_id(int index) const;
  inline void set__month_card_id(int index, ::google::protobuf::uint32 value);
  inline void add__month_card_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _month_card_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__month_card_id();

  // @@protoc_insertion_point(class_scope:up.query_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> _type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _query_heroes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _month_card_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_data* default_instance_;
};
// -------------------------------------------------------------------

class midas : public ::google::protobuf::Message {
 public:
  midas();
  virtual ~midas();

  midas(const midas& from);

  inline midas& operator=(const midas& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const midas& default_instance();

  void Swap(midas* other);

  // implements Message ----------------------------------------------

  midas* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const midas& from);
  void MergeFrom(const midas& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _times = 1;
  inline bool has__times() const;
  inline void clear__times();
  static const int kTimesFieldNumber = 1;
  inline ::google::protobuf::uint32 _times() const;
  inline void set__times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.midas)
 private:
  inline void set_has__times();
  inline void clear_has__times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static midas* default_instance_;
};
// -------------------------------------------------------------------

class open_shop : public ::google::protobuf::Message {
 public:
  open_shop();
  virtual ~open_shop();

  open_shop(const open_shop& from);

  inline open_shop& operator=(const open_shop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const open_shop& default_instance();

  void Swap(open_shop* other);

  // implements Message ----------------------------------------------

  open_shop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const open_shop& from);
  void MergeFrom(const open_shop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _shopid = 1;
  inline bool has__shopid() const;
  inline void clear__shopid();
  static const int kShopidFieldNumber = 1;
  inline ::google::protobuf::uint32 _shopid() const;
  inline void set__shopid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.open_shop)
 private:
  inline void set_has__shopid();
  inline void clear_has__shopid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _shopid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static open_shop* default_instance_;
};
// -------------------------------------------------------------------

class charge : public ::google::protobuf::Message {
 public:
  charge();
  virtual ~charge();

  charge(const charge& from);

  inline charge& operator=(const charge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const charge& default_instance();

  void Swap(charge* other);

  // implements Message ----------------------------------------------

  charge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const charge& from);
  void MergeFrom(const charge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.platform_type _platid = 1 [default = self];
  inline bool has__platid() const;
  inline void clear__platid();
  static const int kPlatidFieldNumber = 1;
  inline ::up::platform_type _platid() const;
  inline void set__platid(::up::platform_type value);

  // required uint32 _chargeid = 2;
  inline bool has__chargeid() const;
  inline void clear__chargeid();
  static const int kChargeidFieldNumber = 2;
  inline ::google::protobuf::uint32 _chargeid() const;
  inline void set__chargeid(::google::protobuf::uint32 value);

  // optional string _extradata = 3;
  inline bool has__extradata() const;
  inline void clear__extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& _extradata() const;
  inline void set__extradata(const ::std::string& value);
  inline void set__extradata(const char* value);
  inline void set__extradata(const char* value, size_t size);
  inline ::std::string* mutable__extradata();
  inline ::std::string* release__extradata();
  inline void set_allocated__extradata(::std::string* _extradata);

  // @@protoc_insertion_point(class_scope:up.charge)
 private:
  inline void set_has__platid();
  inline void clear_has__platid();
  inline void set_has__chargeid();
  inline void clear_has__chargeid();
  inline void set_has__extradata();
  inline void clear_has__extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _platid_;
  ::google::protobuf::uint32 _chargeid_;
  ::std::string* _extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static charge* default_instance_;
};
// -------------------------------------------------------------------

class ask_daily_login : public ::google::protobuf::Message {
 public:
  ask_daily_login();
  virtual ~ask_daily_login();

  ask_daily_login(const ask_daily_login& from);

  inline ask_daily_login& operator=(const ask_daily_login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ask_daily_login& default_instance();

  void Swap(ask_daily_login* other);

  // implements Message ----------------------------------------------

  ask_daily_login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ask_daily_login& from);
  void MergeFrom(const ask_daily_login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ask_daily_login_status status;
  static const status all = ask_daily_login_status_all;
  static const status common = ask_daily_login_status_common;
  static const status vip = ask_daily_login_status_vip;
  static inline bool status_IsValid(int value) {
    return ask_daily_login_status_IsValid(value);
  }
  static const status status_MIN =
    ask_daily_login_status_status_MIN;
  static const status status_MAX =
    ask_daily_login_status_status_MAX;
  static const int status_ARRAYSIZE =
    ask_daily_login_status_status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  status_descriptor() {
    return ask_daily_login_status_descriptor();
  }
  static inline const ::std::string& status_Name(status value) {
    return ask_daily_login_status_Name(value);
  }
  static inline bool status_Parse(const ::std::string& name,
      status* value) {
    return ask_daily_login_status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.ask_daily_login.status _status = 1;
  inline bool has__status() const;
  inline void clear__status();
  static const int kStatusFieldNumber = 1;
  inline ::up::ask_daily_login_status _status() const;
  inline void set__status(::up::ask_daily_login_status value);

  // @@protoc_insertion_point(class_scope:up.ask_daily_login)
 private:
  inline void set_has__status();
  inline void clear_has__status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static ask_daily_login* default_instance_;
};
// -------------------------------------------------------------------

class tbc : public ::google::protobuf::Message {
 public:
  tbc();
  virtual ~tbc();

  tbc(const tbc& from);

  inline tbc& operator=(const tbc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbc& default_instance();

  void Swap(tbc* other);

  // implements Message ----------------------------------------------

  tbc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbc& from);
  void MergeFrom(const tbc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .up.tbc_open_panel _open_panel = 1;
  inline bool has__open_panel() const;
  inline void clear__open_panel();
  static const int kOpenPanelFieldNumber = 1;
  inline const ::up::tbc_open_panel& _open_panel() const;
  inline ::up::tbc_open_panel* mutable__open_panel();
  inline ::up::tbc_open_panel* release__open_panel();
  inline void set_allocated__open_panel(::up::tbc_open_panel* _open_panel);

  // optional .up.tbc_query_oppo _query_oppo = 2;
  inline bool has__query_oppo() const;
  inline void clear__query_oppo();
  static const int kQueryOppoFieldNumber = 2;
  inline const ::up::tbc_query_oppo& _query_oppo() const;
  inline ::up::tbc_query_oppo* mutable__query_oppo();
  inline ::up::tbc_query_oppo* release__query_oppo();
  inline void set_allocated__query_oppo(::up::tbc_query_oppo* _query_oppo);

  // optional .up.tbc_start_battle _start_bat = 3;
  inline bool has__start_bat() const;
  inline void clear__start_bat();
  static const int kStartBatFieldNumber = 3;
  inline const ::up::tbc_start_battle& _start_bat() const;
  inline ::up::tbc_start_battle* mutable__start_bat();
  inline ::up::tbc_start_battle* release__start_bat();
  inline void set_allocated__start_bat(::up::tbc_start_battle* _start_bat);

  // optional .up.tbc_end_battle _end_bat = 4;
  inline bool has__end_bat() const;
  inline void clear__end_bat();
  static const int kEndBatFieldNumber = 4;
  inline const ::up::tbc_end_battle& _end_bat() const;
  inline ::up::tbc_end_battle* mutable__end_bat();
  inline ::up::tbc_end_battle* release__end_bat();
  inline void set_allocated__end_bat(::up::tbc_end_battle* _end_bat);

  // optional .up.tbc_reset _reset = 5;
  inline bool has__reset() const;
  inline void clear__reset();
  static const int kResetFieldNumber = 5;
  inline const ::up::tbc_reset& _reset() const;
  inline ::up::tbc_reset* mutable__reset();
  inline ::up::tbc_reset* release__reset();
  inline void set_allocated__reset(::up::tbc_reset* _reset);

  // optional .up.tbc_draw_reward _draw_reward = 6;
  inline bool has__draw_reward() const;
  inline void clear__draw_reward();
  static const int kDrawRewardFieldNumber = 6;
  inline const ::up::tbc_draw_reward& _draw_reward() const;
  inline ::up::tbc_draw_reward* mutable__draw_reward();
  inline ::up::tbc_draw_reward* release__draw_reward();
  inline void set_allocated__draw_reward(::up::tbc_draw_reward* _draw_reward);

  // @@protoc_insertion_point(class_scope:up.tbc)
 private:
  inline void set_has__open_panel();
  inline void clear_has__open_panel();
  inline void set_has__query_oppo();
  inline void clear_has__query_oppo();
  inline void set_has__start_bat();
  inline void clear_has__start_bat();
  inline void set_has__end_bat();
  inline void clear_has__end_bat();
  inline void set_has__reset();
  inline void clear_has__reset();
  inline void set_has__draw_reward();
  inline void clear_has__draw_reward();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::up::tbc_open_panel* _open_panel_;
  ::up::tbc_query_oppo* _query_oppo_;
  ::up::tbc_start_battle* _start_bat_;
  ::up::tbc_end_battle* _end_bat_;
  ::up::tbc_reset* _reset_;
  ::up::tbc_draw_reward* _draw_reward_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tbc* default_instance_;
};
// -------------------------------------------------------------------

class tbc_open_panel : public ::google::protobuf::Message {
 public:
  tbc_open_panel();
  virtual ~tbc_open_panel();

  tbc_open_panel(const tbc_open_panel& from);

  inline tbc_open_panel& operator=(const tbc_open_panel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbc_open_panel& default_instance();

  void Swap(tbc_open_panel* other);

  // implements Message ----------------------------------------------

  tbc_open_panel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbc_open_panel& from);
  void MergeFrom(const tbc_open_panel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.tbc_open_panel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tbc_open_panel* default_instance_;
};
// -------------------------------------------------------------------

class tbc_query_oppo : public ::google::protobuf::Message {
 public:
  tbc_query_oppo();
  virtual ~tbc_query_oppo();

  tbc_query_oppo(const tbc_query_oppo& from);

  inline tbc_query_oppo& operator=(const tbc_query_oppo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbc_query_oppo& default_instance();

  void Swap(tbc_query_oppo* other);

  // implements Message ----------------------------------------------

  tbc_query_oppo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbc_query_oppo& from);
  void MergeFrom(const tbc_query_oppo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _stage_id = 1;
  inline bool has__stage_id() const;
  inline void clear__stage_id();
  static const int kStageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _stage_id() const;
  inline void set__stage_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.tbc_query_oppo)
 private:
  inline void set_has__stage_id();
  inline void clear_has__stage_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _stage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tbc_query_oppo* default_instance_;
};
// -------------------------------------------------------------------

class tbc_start_battle : public ::google::protobuf::Message {
 public:
  tbc_start_battle();
  virtual ~tbc_start_battle();

  tbc_start_battle(const tbc_start_battle& from);

  inline tbc_start_battle& operator=(const tbc_start_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbc_start_battle& default_instance();

  void Swap(tbc_start_battle* other);

  // implements Message ----------------------------------------------

  tbc_start_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbc_start_battle& from);
  void MergeFrom(const tbc_start_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 _heroids = 1;
  inline int _heroids_size() const;
  inline void clear__heroids();
  static const int kHeroidsFieldNumber = 1;
  inline ::google::protobuf::uint32 _heroids(int index) const;
  inline void set__heroids(int index, ::google::protobuf::uint32 value);
  inline void add__heroids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _heroids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__heroids();

  // optional uint32 _use_hire = 2;
  inline bool has__use_hire() const;
  inline void clear__use_hire();
  static const int kUseHireFieldNumber = 2;
  inline ::google::protobuf::uint32 _use_hire() const;
  inline void set__use_hire(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.tbc_start_battle)
 private:
  inline void set_has__use_hire();
  inline void clear_has__use_hire();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _heroids_;
  ::google::protobuf::uint32 _use_hire_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tbc_start_battle* default_instance_;
};
// -------------------------------------------------------------------

class tbc_hero : public ::google::protobuf::Message {
 public:
  tbc_hero();
  virtual ~tbc_hero();

  tbc_hero(const tbc_hero& from);

  inline tbc_hero& operator=(const tbc_hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbc_hero& default_instance();

  void Swap(tbc_hero* other);

  // implements Message ----------------------------------------------

  tbc_hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbc_hero& from);
  void MergeFrom(const tbc_hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _heroid = 1;
  inline bool has__heroid() const;
  inline void clear__heroid();
  static const int kHeroidFieldNumber = 1;
  inline ::google::protobuf::uint32 _heroid() const;
  inline void set__heroid(::google::protobuf::uint32 value);

  // required uint32 _hp_perc = 2;
  inline bool has__hp_perc() const;
  inline void clear__hp_perc();
  static const int kHpPercFieldNumber = 2;
  inline ::google::protobuf::uint32 _hp_perc() const;
  inline void set__hp_perc(::google::protobuf::uint32 value);

  // required uint32 _mp_perc = 3;
  inline bool has__mp_perc() const;
  inline void clear__mp_perc();
  static const int kMpPercFieldNumber = 3;
  inline ::google::protobuf::uint32 _mp_perc() const;
  inline void set__mp_perc(::google::protobuf::uint32 value);

  // optional uint32 _custom_data = 4;
  inline bool has__custom_data() const;
  inline void clear__custom_data();
  static const int kCustomDataFieldNumber = 4;
  inline ::google::protobuf::uint32 _custom_data() const;
  inline void set__custom_data(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.tbc_hero)
 private:
  inline void set_has__heroid();
  inline void clear_has__heroid();
  inline void set_has__hp_perc();
  inline void clear_has__hp_perc();
  inline void set_has__mp_perc();
  inline void clear_has__mp_perc();
  inline void set_has__custom_data();
  inline void clear_has__custom_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _heroid_;
  ::google::protobuf::uint32 _hp_perc_;
  ::google::protobuf::uint32 _mp_perc_;
  ::google::protobuf::uint32 _custom_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tbc_hero* default_instance_;
};
// -------------------------------------------------------------------

class tbc_end_battle : public ::google::protobuf::Message {
 public:
  tbc_end_battle();
  virtual ~tbc_end_battle();

  tbc_end_battle(const tbc_end_battle& from);

  inline tbc_end_battle& operator=(const tbc_end_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbc_end_battle& default_instance();

  void Swap(tbc_end_battle* other);

  // implements Message ----------------------------------------------

  tbc_end_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbc_end_battle& from);
  void MergeFrom(const tbc_end_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.battle_result _result = 1 [default = victory];
  inline bool has__result() const;
  inline void clear__result();
  static const int kResultFieldNumber = 1;
  inline ::up::battle_result _result() const;
  inline void set__result(::up::battle_result value);

  // repeated .up.tbc_hero _self_heroes = 2;
  inline int _self_heroes_size() const;
  inline void clear__self_heroes();
  static const int kSelfHeroesFieldNumber = 2;
  inline const ::up::tbc_hero& _self_heroes(int index) const;
  inline ::up::tbc_hero* mutable__self_heroes(int index);
  inline ::up::tbc_hero* add__self_heroes();
  inline const ::google::protobuf::RepeatedPtrField< ::up::tbc_hero >&
      _self_heroes() const;
  inline ::google::protobuf::RepeatedPtrField< ::up::tbc_hero >*
      mutable__self_heroes();

  // repeated .up.tbc_hero _oppo_heroes = 3;
  inline int _oppo_heroes_size() const;
  inline void clear__oppo_heroes();
  static const int kOppoHeroesFieldNumber = 3;
  inline const ::up::tbc_hero& _oppo_heroes(int index) const;
  inline ::up::tbc_hero* mutable__oppo_heroes(int index);
  inline ::up::tbc_hero* add__oppo_heroes();
  inline const ::google::protobuf::RepeatedPtrField< ::up::tbc_hero >&
      _oppo_heroes() const;
  inline ::google::protobuf::RepeatedPtrField< ::up::tbc_hero >*
      mutable__oppo_heroes();

  // repeated uint32 _oprations = 4;
  inline int _oprations_size() const;
  inline void clear__oprations();
  static const int kOprationsFieldNumber = 4;
  inline ::google::protobuf::uint32 _oprations(int index) const;
  inline void set__oprations(int index, ::google::protobuf::uint32 value);
  inline void add__oprations(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _oprations() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__oprations();

  // @@protoc_insertion_point(class_scope:up.tbc_end_battle)
 private:
  inline void set_has__result();
  inline void clear_has__result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::up::tbc_hero > _self_heroes_;
  ::google::protobuf::RepeatedPtrField< ::up::tbc_hero > _oppo_heroes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _oprations_;
  int _result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tbc_end_battle* default_instance_;
};
// -------------------------------------------------------------------

class tbc_reset : public ::google::protobuf::Message {
 public:
  tbc_reset();
  virtual ~tbc_reset();

  tbc_reset(const tbc_reset& from);

  inline tbc_reset& operator=(const tbc_reset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbc_reset& default_instance();

  void Swap(tbc_reset* other);

  // implements Message ----------------------------------------------

  tbc_reset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbc_reset& from);
  void MergeFrom(const tbc_reset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.tbc_reset)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tbc_reset* default_instance_;
};
// -------------------------------------------------------------------

class tbc_draw_reward : public ::google::protobuf::Message {
 public:
  tbc_draw_reward();
  virtual ~tbc_draw_reward();

  tbc_draw_reward(const tbc_draw_reward& from);

  inline tbc_draw_reward& operator=(const tbc_draw_reward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbc_draw_reward& default_instance();

  void Swap(tbc_draw_reward* other);

  // implements Message ----------------------------------------------

  tbc_draw_reward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbc_draw_reward& from);
  void MergeFrom(const tbc_draw_reward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _stage_id = 1;
  inline bool has__stage_id() const;
  inline void clear__stage_id();
  static const int kStageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _stage_id() const;
  inline void set__stage_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.tbc_draw_reward)
 private:
  inline void set_has__stage_id();
  inline void clear_has__stage_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _stage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static tbc_draw_reward* default_instance_;
};
// -------------------------------------------------------------------

class get_maillist : public ::google::protobuf::Message {
 public:
  get_maillist();
  virtual ~get_maillist();

  get_maillist(const get_maillist& from);

  inline get_maillist& operator=(const get_maillist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_maillist& default_instance();

  void Swap(get_maillist* other);

  // implements Message ----------------------------------------------

  get_maillist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_maillist& from);
  void MergeFrom(const get_maillist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.get_maillist)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static get_maillist* default_instance_;
};
// -------------------------------------------------------------------

class read_mail : public ::google::protobuf::Message {
 public:
  read_mail();
  virtual ~read_mail();

  read_mail(const read_mail& from);

  inline read_mail& operator=(const read_mail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const read_mail& default_instance();

  void Swap(read_mail* other);

  // implements Message ----------------------------------------------

  read_mail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const read_mail& from);
  void MergeFrom(const read_mail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _id = 1;
  inline bool has__id() const;
  inline void clear__id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _id() const;
  inline void set__id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.read_mail)
 private:
  inline void set_has__id();
  inline void clear_has__id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static read_mail* default_instance_;
};
// -------------------------------------------------------------------

class get_svr_time : public ::google::protobuf::Message {
 public:
  get_svr_time();
  virtual ~get_svr_time();

  get_svr_time(const get_svr_time& from);

  inline get_svr_time& operator=(const get_svr_time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_svr_time& default_instance();

  void Swap(get_svr_time* other);

  // implements Message ----------------------------------------------

  get_svr_time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_svr_time& from);
  void MergeFrom(const get_svr_time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.get_svr_time)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static get_svr_time* default_instance_;
};
// -------------------------------------------------------------------

class get_vip_gift : public ::google::protobuf::Message {
 public:
  get_vip_gift();
  virtual ~get_vip_gift();

  get_vip_gift(const get_vip_gift& from);

  inline get_vip_gift& operator=(const get_vip_gift& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_vip_gift& default_instance();

  void Swap(get_vip_gift* other);

  // implements Message ----------------------------------------------

  get_vip_gift* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_vip_gift& from);
  void MergeFrom(const get_vip_gift& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _vip = 1;
  inline bool has__vip() const;
  inline void clear__vip();
  static const int kVipFieldNumber = 1;
  inline ::google::protobuf::uint32 _vip() const;
  inline void set__vip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.get_vip_gift)
 private:
  inline void set_has__vip();
  inline void clear_has__vip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _vip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static get_vip_gift* default_instance_;
};
// -------------------------------------------------------------------

class chat : public ::google::protobuf::Message {
 public:
  chat();
  virtual ~chat();

  chat(const chat& from);

  inline chat& operator=(const chat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat& default_instance();

  void Swap(chat* other);

  // implements Message ----------------------------------------------

  chat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat& from);
  void MergeFrom(const chat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .up.chat_say _say = 1;
  inline bool has__say() const;
  inline void clear__say();
  static const int kSayFieldNumber = 1;
  inline const ::up::chat_say& _say() const;
  inline ::up::chat_say* mutable__say();
  inline ::up::chat_say* release__say();
  inline void set_allocated__say(::up::chat_say* _say);

  // optional .up.chat_fresh _fresh = 2;
  inline bool has__fresh() const;
  inline void clear__fresh();
  static const int kFreshFieldNumber = 2;
  inline const ::up::chat_fresh& _fresh() const;
  inline ::up::chat_fresh* mutable__fresh();
  inline ::up::chat_fresh* release__fresh();
  inline void set_allocated__fresh(::up::chat_fresh* _fresh);

  // optional .up.chat_fetch _fetch = 3;
  inline bool has__fetch() const;
  inline void clear__fetch();
  static const int kFetchFieldNumber = 3;
  inline const ::up::chat_fetch& _fetch() const;
  inline ::up::chat_fetch* mutable__fetch();
  inline ::up::chat_fetch* release__fetch();
  inline void set_allocated__fetch(::up::chat_fetch* _fetch);

  // optional .up.chat_add_bl _chat_add_bl = 4;
  inline bool has__chat_add_bl() const;
  inline void clear__chat_add_bl();
  static const int kChatAddBlFieldNumber = 4;
  inline const ::up::chat_add_bl& _chat_add_bl() const;
  inline ::up::chat_add_bl* mutable__chat_add_bl();
  inline ::up::chat_add_bl* release__chat_add_bl();
  inline void set_allocated__chat_add_bl(::up::chat_add_bl* _chat_add_bl);

  // optional .up.chat_del_bl _chat_del_bl = 5;
  inline bool has__chat_del_bl() const;
  inline void clear__chat_del_bl();
  static const int kChatDelBlFieldNumber = 5;
  inline const ::up::chat_del_bl& _chat_del_bl() const;
  inline ::up::chat_del_bl* mutable__chat_del_bl();
  inline ::up::chat_del_bl* release__chat_del_bl();
  inline void set_allocated__chat_del_bl(::up::chat_del_bl* _chat_del_bl);

  // optional .up.chat_fetch_bl _chat_fetch_bl = 6;
  inline bool has__chat_fetch_bl() const;
  inline void clear__chat_fetch_bl();
  static const int kChatFetchBlFieldNumber = 6;
  inline const ::up::chat_fetch_bl& _chat_fetch_bl() const;
  inline ::up::chat_fetch_bl* mutable__chat_fetch_bl();
  inline ::up::chat_fetch_bl* release__chat_fetch_bl();
  inline void set_allocated__chat_fetch_bl(::up::chat_fetch_bl* _chat_fetch_bl);

  // optional .up.chat_broad_say _chat_broad_say = 7;
  inline bool has__chat_broad_say() const;
  inline void clear__chat_broad_say();
  static const int kChatBroadSayFieldNumber = 7;
  inline const ::up::chat_broad_say& _chat_broad_say() const;
  inline ::up::chat_broad_say* mutable__chat_broad_say();
  inline ::up::chat_broad_say* release__chat_broad_say();
  inline void set_allocated__chat_broad_say(::up::chat_broad_say* _chat_broad_say);

  // @@protoc_insertion_point(class_scope:up.chat)
 private:
  inline void set_has__say();
  inline void clear_has__say();
  inline void set_has__fresh();
  inline void clear_has__fresh();
  inline void set_has__fetch();
  inline void clear_has__fetch();
  inline void set_has__chat_add_bl();
  inline void clear_has__chat_add_bl();
  inline void set_has__chat_del_bl();
  inline void clear_has__chat_del_bl();
  inline void set_has__chat_fetch_bl();
  inline void clear_has__chat_fetch_bl();
  inline void set_has__chat_broad_say();
  inline void clear_has__chat_broad_say();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::up::chat_say* _say_;
  ::up::chat_fresh* _fresh_;
  ::up::chat_fetch* _fetch_;
  ::up::chat_add_bl* _chat_add_bl_;
  ::up::chat_del_bl* _chat_del_bl_;
  ::up::chat_fetch_bl* _chat_fetch_bl_;
  ::up::chat_broad_say* _chat_broad_say_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static chat* default_instance_;
};
// -------------------------------------------------------------------

class chat_broad_say : public ::google::protobuf::Message {
 public:
  chat_broad_say();
  virtual ~chat_broad_say();

  chat_broad_say(const chat_broad_say& from);

  inline chat_broad_say& operator=(const chat_broad_say& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_broad_say& default_instance();

  void Swap(chat_broad_say* other);

  // implements Message ----------------------------------------------

  chat_broad_say* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_broad_say& from);
  void MergeFrom(const chat_broad_say& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .up.chat_channel _channel = 1;
  inline bool has__channel() const;
  inline void clear__channel();
  static const int kChannelFieldNumber = 1;
  inline ::up::chat_channel _channel() const;
  inline void set__channel(::up::chat_channel value);

  // repeated uint32 _target_ids = 2;
  inline int _target_ids_size() const;
  inline void clear__target_ids();
  static const int kTargetIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 _target_ids(int index) const;
  inline void set__target_ids(int index, ::google::protobuf::uint32 value);
  inline void add__target_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _target_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__target_ids();

  // optional uint32 _content_type = 3;
  inline bool has__content_type() const;
  inline void clear__content_type();
  static const int kContentTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 _content_type() const;
  inline void set__content_type(::google::protobuf::uint32 value);

  // optional string _content = 4;
  inline bool has__content() const;
  inline void clear__content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& _content() const;
  inline void set__content(const ::std::string& value);
  inline void set__content(const char* value);
  inline void set__content(const char* value, size_t size);
  inline ::std::string* mutable__content();
  inline ::std::string* release__content();
  inline void set_allocated__content(::std::string* _content);

  // optional .up.chat_acc _accessory = 5;
  inline bool has__accessory() const;
  inline void clear__accessory();
  static const int kAccessoryFieldNumber = 5;
  inline const ::up::chat_acc& _accessory() const;
  inline ::up::chat_acc* mutable__accessory();
  inline ::up::chat_acc* release__accessory();
  inline void set_allocated__accessory(::up::chat_acc* _accessory);

  // @@protoc_insertion_point(class_scope:up.chat_broad_say)
 private:
  inline void set_has__channel();
  inline void clear_has__channel();
  inline void set_has__content_type();
  inline void clear_has__content_type();
  inline void set_has__content();
  inline void clear_has__content();
  inline void set_has__accessory();
  inline void clear_has__accessory();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _target_ids_;
  int _channel_;
  ::google::protobuf::uint32 _content_type_;
  ::std::string* _content_;
  ::up::chat_acc* _accessory_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static chat_broad_say* default_instance_;
};
// -------------------------------------------------------------------

class chat_fetch_bl : public ::google::protobuf::Message {
 public:
  chat_fetch_bl();
  virtual ~chat_fetch_bl();

  chat_fetch_bl(const chat_fetch_bl& from);

  inline chat_fetch_bl& operator=(const chat_fetch_bl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_fetch_bl& default_instance();

  void Swap(chat_fetch_bl* other);

  // implements Message ----------------------------------------------

  chat_fetch_bl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_fetch_bl& from);
  void MergeFrom(const chat_fetch_bl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.chat_fetch_bl)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static chat_fetch_bl* default_instance_;
};
// -------------------------------------------------------------------

class chat_say : public ::google::protobuf::Message {
 public:
  chat_say();
  virtual ~chat_say();

  chat_say(const chat_say& from);

  inline chat_say& operator=(const chat_say& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_say& default_instance();

  void Swap(chat_say* other);

  // implements Message ----------------------------------------------

  chat_say* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_say& from);
  void MergeFrom(const chat_say& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.chat_channel _channel = 1 [default = world_channel];
  inline bool has__channel() const;
  inline void clear__channel();
  static const int kChannelFieldNumber = 1;
  inline ::up::chat_channel _channel() const;
  inline void set__channel(::up::chat_channel value);

  // optional uint32 _target_id = 2;
  inline bool has__target_id() const;
  inline void clear__target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _target_id() const;
  inline void set__target_id(::google::protobuf::uint32 value);

  // required uint32 _content_type = 3;
  inline bool has__content_type() const;
  inline void clear__content_type();
  static const int kContentTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 _content_type() const;
  inline void set__content_type(::google::protobuf::uint32 value);

  // required string _content = 4;
  inline bool has__content() const;
  inline void clear__content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& _content() const;
  inline void set__content(const ::std::string& value);
  inline void set__content(const char* value);
  inline void set__content(const char* value, size_t size);
  inline ::std::string* mutable__content();
  inline ::std::string* release__content();
  inline void set_allocated__content(::std::string* _content);

  // optional .up.chat_acc _accessory = 5;
  inline bool has__accessory() const;
  inline void clear__accessory();
  static const int kAccessoryFieldNumber = 5;
  inline const ::up::chat_acc& _accessory() const;
  inline ::up::chat_acc* mutable__accessory();
  inline ::up::chat_acc* release__accessory();
  inline void set_allocated__accessory(::up::chat_acc* _accessory);

  // @@protoc_insertion_point(class_scope:up.chat_say)
 private:
  inline void set_has__channel();
  inline void clear_has__channel();
  inline void set_has__target_id();
  inline void clear_has__target_id();
  inline void set_has__content_type();
  inline void clear_has__content_type();
  inline void set_has__content();
  inline void clear_has__content();
  inline void set_has__accessory();
  inline void clear_has__accessory();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _channel_;
  ::google::protobuf::uint32 _target_id_;
  ::std::string* _content_;
  ::up::chat_acc* _accessory_;
  ::google::protobuf::uint32 _content_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static chat_say* default_instance_;
};
// -------------------------------------------------------------------

class chat_acc : public ::google::protobuf::Message {
 public:
  chat_acc();
  virtual ~chat_acc();

  chat_acc(const chat_acc& from);

  inline chat_acc& operator=(const chat_acc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_acc& default_instance();

  void Swap(chat_acc* other);

  // implements Message ----------------------------------------------

  chat_acc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_acc& from);
  void MergeFrom(const chat_acc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef chat_acc_chat_acc_t chat_acc_t;
  static const chat_acc_t binary = chat_acc_chat_acc_t_binary;
  static const chat_acc_t pvp_replay = chat_acc_chat_acc_t_pvp_replay;
  static inline bool chat_acc_t_IsValid(int value) {
    return chat_acc_chat_acc_t_IsValid(value);
  }
  static const chat_acc_t chat_acc_t_MIN =
    chat_acc_chat_acc_t_chat_acc_t_MIN;
  static const chat_acc_t chat_acc_t_MAX =
    chat_acc_chat_acc_t_chat_acc_t_MAX;
  static const int chat_acc_t_ARRAYSIZE =
    chat_acc_chat_acc_t_chat_acc_t_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  chat_acc_t_descriptor() {
    return chat_acc_chat_acc_t_descriptor();
  }
  static inline const ::std::string& chat_acc_t_Name(chat_acc_t value) {
    return chat_acc_chat_acc_t_Name(value);
  }
  static inline bool chat_acc_t_Parse(const ::std::string& name,
      chat_acc_t* value) {
    return chat_acc_chat_acc_t_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.chat_acc.chat_acc_t _type = 1 [default = binary];
  inline bool has__type() const;
  inline void clear__type();
  static const int kTypeFieldNumber = 1;
  inline ::up::chat_acc_chat_acc_t _type() const;
  inline void set__type(::up::chat_acc_chat_acc_t value);

  // optional string _binary = 2;
  inline bool has__binary() const;
  inline void clear__binary();
  static const int kBinaryFieldNumber = 2;
  inline const ::std::string& _binary() const;
  inline void set__binary(const ::std::string& value);
  inline void set__binary(const char* value);
  inline void set__binary(const char* value, size_t size);
  inline ::std::string* mutable__binary();
  inline ::std::string* release__binary();
  inline void set_allocated__binary(::std::string* _binary);

  // optional uint32 _record_id = 3;
  inline bool has__record_id() const;
  inline void clear__record_id();
  static const int kRecordIdFieldNumber = 3;
  inline ::google::protobuf::uint32 _record_id() const;
  inline void set__record_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.chat_acc)
 private:
  inline void set_has__type();
  inline void clear_has__type();
  inline void set_has__binary();
  inline void clear_has__binary();
  inline void set_has__record_id();
  inline void clear_has__record_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _binary_;
  int _type_;
  ::google::protobuf::uint32 _record_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static chat_acc* default_instance_;
};
// -------------------------------------------------------------------

class chat_fresh : public ::google::protobuf::Message {
 public:
  chat_fresh();
  virtual ~chat_fresh();

  chat_fresh(const chat_fresh& from);

  inline chat_fresh& operator=(const chat_fresh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_fresh& default_instance();

  void Swap(chat_fresh* other);

  // implements Message ----------------------------------------------

  chat_fresh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_fresh& from);
  void MergeFrom(const chat_fresh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.chat_channel _channel = 1 [default = world_channel];
  inline bool has__channel() const;
  inline void clear__channel();
  static const int kChannelFieldNumber = 1;
  inline ::up::chat_channel _channel() const;
  inline void set__channel(::up::chat_channel value);

  // @@protoc_insertion_point(class_scope:up.chat_fresh)
 private:
  inline void set_has__channel();
  inline void clear_has__channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static chat_fresh* default_instance_;
};
// -------------------------------------------------------------------

class chat_fetch : public ::google::protobuf::Message {
 public:
  chat_fetch();
  virtual ~chat_fetch();

  chat_fetch(const chat_fetch& from);

  inline chat_fetch& operator=(const chat_fetch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_fetch& default_instance();

  void Swap(chat_fetch* other);

  // implements Message ----------------------------------------------

  chat_fetch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_fetch& from);
  void MergeFrom(const chat_fetch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.chat_channel _channel = 1 [default = world_channel];
  inline bool has__channel() const;
  inline void clear__channel();
  static const int kChannelFieldNumber = 1;
  inline ::up::chat_channel _channel() const;
  inline void set__channel(::up::chat_channel value);

  // required uint32 _chat_id = 2;
  inline bool has__chat_id() const;
  inline void clear__chat_id();
  static const int kChatIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _chat_id() const;
  inline void set__chat_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.chat_fetch)
 private:
  inline void set_has__channel();
  inline void clear_has__channel();
  inline void set_has__chat_id();
  inline void clear_has__chat_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _channel_;
  ::google::protobuf::uint32 _chat_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static chat_fetch* default_instance_;
};
// -------------------------------------------------------------------

class chat_add_bl : public ::google::protobuf::Message {
 public:
  chat_add_bl();
  virtual ~chat_add_bl();

  chat_add_bl(const chat_add_bl& from);

  inline chat_add_bl& operator=(const chat_add_bl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_add_bl& default_instance();

  void Swap(chat_add_bl* other);

  // implements Message ----------------------------------------------

  chat_add_bl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_add_bl& from);
  void MergeFrom(const chat_add_bl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _uid = 1;
  inline bool has__uid() const;
  inline void clear__uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 _uid() const;
  inline void set__uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.chat_add_bl)
 private:
  inline void set_has__uid();
  inline void clear_has__uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static chat_add_bl* default_instance_;
};
// -------------------------------------------------------------------

class chat_del_bl : public ::google::protobuf::Message {
 public:
  chat_del_bl();
  virtual ~chat_del_bl();

  chat_del_bl(const chat_del_bl& from);

  inline chat_del_bl& operator=(const chat_del_bl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_del_bl& default_instance();

  void Swap(chat_del_bl* other);

  // implements Message ----------------------------------------------

  chat_del_bl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_del_bl& from);
  void MergeFrom(const chat_del_bl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _uid = 1;
  inline bool has__uid() const;
  inline void clear__uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 _uid() const;
  inline void set__uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.chat_del_bl)
 private:
  inline void set_has__uid();
  inline void clear_has__uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static chat_del_bl* default_instance_;
};
// -------------------------------------------------------------------

class guild : public ::google::protobuf::Message {
 public:
  guild();
  virtual ~guild();

  guild(const guild& from);

  inline guild& operator=(const guild& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild& default_instance();

  void Swap(guild* other);

  // implements Message ----------------------------------------------

  guild* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild& from);
  void MergeFrom(const guild& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .up.guild_create _create = 1;
  inline bool has__create() const;
  inline void clear__create();
  static const int kCreateFieldNumber = 1;
  inline const ::up::guild_create& _create() const;
  inline ::up::guild_create* mutable__create();
  inline ::up::guild_create* release__create();
  inline void set_allocated__create(::up::guild_create* _create);

  // optional .up.guild_dismiss _dismiss = 2;
  inline bool has__dismiss() const;
  inline void clear__dismiss();
  static const int kDismissFieldNumber = 2;
  inline const ::up::guild_dismiss& _dismiss() const;
  inline ::up::guild_dismiss* mutable__dismiss();
  inline ::up::guild_dismiss* release__dismiss();
  inline void set_allocated__dismiss(::up::guild_dismiss* _dismiss);

  // optional .up.guild_list _list = 3;
  inline bool has__list() const;
  inline void clear__list();
  static const int kListFieldNumber = 3;
  inline const ::up::guild_list& _list() const;
  inline ::up::guild_list* mutable__list();
  inline ::up::guild_list* release__list();
  inline void set_allocated__list(::up::guild_list* _list);

  // optional .up.guild_search _search = 4;
  inline bool has__search() const;
  inline void clear__search();
  static const int kSearchFieldNumber = 4;
  inline const ::up::guild_search& _search() const;
  inline ::up::guild_search* mutable__search();
  inline ::up::guild_search* release__search();
  inline void set_allocated__search(::up::guild_search* _search);

  // optional .up.guild_join _join = 5;
  inline bool has__join() const;
  inline void clear__join();
  static const int kJoinFieldNumber = 5;
  inline const ::up::guild_join& _join() const;
  inline ::up::guild_join* mutable__join();
  inline ::up::guild_join* release__join();
  inline void set_allocated__join(::up::guild_join* _join);

  // optional .up.guild_join_confirm _join_confirm = 6;
  inline bool has__join_confirm() const;
  inline void clear__join_confirm();
  static const int kJoinConfirmFieldNumber = 6;
  inline const ::up::guild_join_confirm& _join_confirm() const;
  inline ::up::guild_join_confirm* mutable__join_confirm();
  inline ::up::guild_join_confirm* release__join_confirm();
  inline void set_allocated__join_confirm(::up::guild_join_confirm* _join_confirm);

  // optional .up.guild_leave _guild_leave = 7;
  inline bool has__guild_leave() const;
  inline void clear__guild_leave();
  static const int kGuildLeaveFieldNumber = 7;
  inline const ::up::guild_leave& _guild_leave() const;
  inline ::up::guild_leave* mutable__guild_leave();
  inline ::up::guild_leave* release__guild_leave();
  inline void set_allocated__guild_leave(::up::guild_leave* _guild_leave);

  // optional .up.guild_kick _kick = 8;
  inline bool has__kick() const;
  inline void clear__kick();
  static const int kKickFieldNumber = 8;
  inline const ::up::guild_kick& _kick() const;
  inline ::up::guild_kick* mutable__kick();
  inline ::up::guild_kick* release__kick();
  inline void set_allocated__kick(::up::guild_kick* _kick);

  // optional .up.guild_set _set = 9;
  inline bool has__set() const;
  inline void clear__set();
  static const int kSetFieldNumber = 9;
  inline const ::up::guild_set& _set() const;
  inline ::up::guild_set* mutable__set();
  inline ::up::guild_set* release__set();
  inline void set_allocated__set(::up::guild_set* _set);

  // optional .up.guild_query _query = 10;
  inline bool has__query() const;
  inline void clear__query();
  static const int kQueryFieldNumber = 10;
  inline const ::up::guild_query& _query() const;
  inline ::up::guild_query* mutable__query();
  inline ::up::guild_query* release__query();
  inline void set_allocated__query(::up::guild_query* _query);

  // optional .up.guild_open_pannel _open_pannel = 11;
  inline bool has__open_pannel() const;
  inline void clear__open_pannel();
  static const int kOpenPannelFieldNumber = 11;
  inline const ::up::guild_open_pannel& _open_pannel() const;
  inline ::up::guild_open_pannel* mutable__open_pannel();
  inline ::up::guild_open_pannel* release__open_pannel();
  inline void set_allocated__open_pannel(::up::guild_open_pannel* _open_pannel);

  // optional .up.guild_set_job _set_job = 12;
  inline bool has__set_job() const;
  inline void clear__set_job();
  static const int kSetJobFieldNumber = 12;
  inline const ::up::guild_set_job& _set_job() const;
  inline ::up::guild_set_job* mutable__set_job();
  inline ::up::guild_set_job* release__set_job();
  inline void set_allocated__set_job(::up::guild_set_job* _set_job);

  // optional .up.guild_add_hire _add_hire = 13;
  inline bool has__add_hire() const;
  inline void clear__add_hire();
  static const int kAddHireFieldNumber = 13;
  inline const ::up::guild_add_hire& _add_hire() const;
  inline ::up::guild_add_hire* mutable__add_hire();
  inline ::up::guild_add_hire* release__add_hire();
  inline void set_allocated__add_hire(::up::guild_add_hire* _add_hire);

  // optional .up.guild_del_hire _del_hire = 14;
  inline bool has__del_hire() const;
  inline void clear__del_hire();
  static const int kDelHireFieldNumber = 14;
  inline const ::up::guild_del_hire& _del_hire() const;
  inline ::up::guild_del_hire* mutable__del_hire();
  inline ::up::guild_del_hire* release__del_hire();
  inline void set_allocated__del_hire(::up::guild_del_hire* _del_hire);

  // optional .up.guild_query_hires _query_hires = 15;
  inline bool has__query_hires() const;
  inline void clear__query_hires();
  static const int kQueryHiresFieldNumber = 15;
  inline const ::up::guild_query_hires& _query_hires() const;
  inline ::up::guild_query_hires* mutable__query_hires();
  inline ::up::guild_query_hires* release__query_hires();
  inline void set_allocated__query_hires(::up::guild_query_hires* _query_hires);

  // optional .up.guild_hire_hero _hire_hero = 16;
  inline bool has__hire_hero() const;
  inline void clear__hire_hero();
  static const int kHireHeroFieldNumber = 16;
  inline const ::up::guild_hire_hero& _hire_hero() const;
  inline ::up::guild_hire_hero* mutable__hire_hero();
  inline ::up::guild_hire_hero* release__hire_hero();
  inline void set_allocated__hire_hero(::up::guild_hire_hero* _hire_hero);

  // optional .up.guild_worship_req _worship_req = 17;
  inline bool has__worship_req() const;
  inline void clear__worship_req();
  static const int kWorshipReqFieldNumber = 17;
  inline const ::up::guild_worship_req& _worship_req() const;
  inline ::up::guild_worship_req* mutable__worship_req();
  inline ::up::guild_worship_req* release__worship_req();
  inline void set_allocated__worship_req(::up::guild_worship_req* _worship_req);

  // optional .up.guild_worship_withdraw _worship_withdraw = 18;
  inline bool has__worship_withdraw() const;
  inline void clear__worship_withdraw();
  static const int kWorshipWithdrawFieldNumber = 18;
  inline const ::up::guild_worship_withdraw& _worship_withdraw() const;
  inline ::up::guild_worship_withdraw* mutable__worship_withdraw();
  inline ::up::guild_worship_withdraw* release__worship_withdraw();
  inline void set_allocated__worship_withdraw(::up::guild_worship_withdraw* _worship_withdraw);

  // optional .up.guild_qurey_hh_detail _query_hh_detail = 19;
  inline bool has__query_hh_detail() const;
  inline void clear__query_hh_detail();
  static const int kQueryHhDetailFieldNumber = 19;
  inline const ::up::guild_qurey_hh_detail& _query_hh_detail() const;
  inline ::up::guild_qurey_hh_detail* mutable__query_hh_detail();
  inline ::up::guild_qurey_hh_detail* release__query_hh_detail();
  inline void set_allocated__query_hh_detail(::up::guild_qurey_hh_detail* _query_hh_detail);

  // optional .up.guild_instance_query _instance_query = 20;
  inline bool has__instance_query() const;
  inline void clear__instance_query();
  static const int kInstanceQueryFieldNumber = 20;
  inline const ::up::guild_instance_query& _instance_query() const;
  inline ::up::guild_instance_query* mutable__instance_query();
  inline ::up::guild_instance_query* release__instance_query();
  inline void set_allocated__instance_query(::up::guild_instance_query* _instance_query);

  // optional .up.guild_instance_detail _instance_detail = 21;
  inline bool has__instance_detail() const;
  inline void clear__instance_detail();
  static const int kInstanceDetailFieldNumber = 21;
  inline const ::up::guild_instance_detail& _instance_detail() const;
  inline ::up::guild_instance_detail* mutable__instance_detail();
  inline ::up::guild_instance_detail* release__instance_detail();
  inline void set_allocated__instance_detail(::up::guild_instance_detail* _instance_detail);

  // optional .up.guild_instance_start _instance_start = 22;
  inline bool has__instance_start() const;
  inline void clear__instance_start();
  static const int kInstanceStartFieldNumber = 22;
  inline const ::up::guild_instance_start& _instance_start() const;
  inline ::up::guild_instance_start* mutable__instance_start();
  inline ::up::guild_instance_start* release__instance_start();
  inline void set_allocated__instance_start(::up::guild_instance_start* _instance_start);

  // optional .up.guild_instance_end _instance_end = 23;
  inline bool has__instance_end() const;
  inline void clear__instance_end();
  static const int kInstanceEndFieldNumber = 23;
  inline const ::up::guild_instance_end& _instance_end() const;
  inline ::up::guild_instance_end* mutable__instance_end();
  inline ::up::guild_instance_end* release__instance_end();
  inline void set_allocated__instance_end(::up::guild_instance_end* _instance_end);

  // optional .up.guild_instance_drop _instance_drop = 24;
  inline bool has__instance_drop() const;
  inline void clear__instance_drop();
  static const int kInstanceDropFieldNumber = 24;
  inline const ::up::guild_instance_drop& _instance_drop() const;
  inline ::up::guild_instance_drop* mutable__instance_drop();
  inline ::up::guild_instance_drop* release__instance_drop();
  inline void set_allocated__instance_drop(::up::guild_instance_drop* _instance_drop);

  // optional .up.guild_instance_open _instance_open = 25;
  inline bool has__instance_open() const;
  inline void clear__instance_open();
  static const int kInstanceOpenFieldNumber = 25;
  inline const ::up::guild_instance_open& _instance_open() const;
  inline ::up::guild_instance_open* mutable__instance_open();
  inline ::up::guild_instance_open* release__instance_open();
  inline void set_allocated__instance_open(::up::guild_instance_open* _instance_open);

  // optional .up.guild_instance_apply _instance_apply = 26;
  inline bool has__instance_apply() const;
  inline void clear__instance_apply();
  static const int kInstanceApplyFieldNumber = 26;
  inline const ::up::guild_instance_apply& _instance_apply() const;
  inline ::up::guild_instance_apply* mutable__instance_apply();
  inline ::up::guild_instance_apply* release__instance_apply();
  inline void set_allocated__instance_apply(::up::guild_instance_apply* _instance_apply);

  // optional .up.guild_drop_info _drop_info = 27;
  inline bool has__drop_info() const;
  inline void clear__drop_info();
  static const int kDropInfoFieldNumber = 27;
  inline const ::up::guild_drop_info& _drop_info() const;
  inline ::up::guild_drop_info* mutable__drop_info();
  inline ::up::guild_drop_info* release__drop_info();
  inline void set_allocated__drop_info(::up::guild_drop_info* _drop_info);

  // optional .up.guild_drop_give _drop_give = 28;
  inline bool has__drop_give() const;
  inline void clear__drop_give();
  static const int kDropGiveFieldNumber = 28;
  inline const ::up::guild_drop_give& _drop_give() const;
  inline ::up::guild_drop_give* mutable__drop_give();
  inline ::up::guild_drop_give* release__drop_give();
  inline void set_allocated__drop_give(::up::guild_drop_give* _drop_give);

  // optional .up.guild_instance_damage _instance_damage = 29;
  inline bool has__instance_damage() const;
  inline void clear__instance_damage();
  static const int kInstanceDamageFieldNumber = 29;
  inline const ::up::guild_instance_damage& _instance_damage() const;
  inline ::up::guild_instance_damage* mutable__instance_damage();
  inline ::up::guild_instance_damage* release__instance_damage();
  inline void set_allocated__instance_damage(::up::guild_instance_damage* _instance_damage);

  // optional .up.guild_items_history _items_history = 30;
  inline bool has__items_history() const;
  inline void clear__items_history();
  static const int kItemsHistoryFieldNumber = 30;
  inline const ::up::guild_items_history& _items_history() const;
  inline ::up::guild_items_history* mutable__items_history();
  inline ::up::guild_items_history* release__items_history();
  inline void set_allocated__items_history(::up::guild_items_history* _items_history);

  // optional .up.guild_jump _guild_jump = 31;
  inline bool has__guild_jump() const;
  inline void clear__guild_jump();
  static const int kGuildJumpFieldNumber = 31;
  inline const ::up::guild_jump& _guild_jump() const;
  inline ::up::guild_jump* mutable__guild_jump();
  inline ::up::guild_jump* release__guild_jump();
  inline void set_allocated__guild_jump(::up::guild_jump* _guild_jump);

  // optional .up.guild_app_queue _guild_app_queue = 32;
  inline bool has__guild_app_queue() const;
  inline void clear__guild_app_queue();
  static const int kGuildAppQueueFieldNumber = 32;
  inline const ::up::guild_app_queue& _guild_app_queue() const;
  inline ::up::guild_app_queue* mutable__guild_app_queue();
  inline ::up::guild_app_queue* release__guild_app_queue();
  inline void set_allocated__guild_app_queue(::up::guild_app_queue* _guild_app_queue);

  // optional .up.guild_prepare_instance _instance_prepare = 33;
  inline bool has__instance_prepare() const;
  inline void clear__instance_prepare();
  static const int kInstancePrepareFieldNumber = 33;
  inline const ::up::guild_prepare_instance& _instance_prepare() const;
  inline ::up::guild_prepare_instance* mutable__instance_prepare();
  inline ::up::guild_prepare_instance* release__instance_prepare();
  inline void set_allocated__instance_prepare(::up::guild_prepare_instance* _instance_prepare);

  // optional .up.guild_query_member _guild_query_member = 34;
  inline bool has__guild_query_member() const;
  inline void clear__guild_query_member();
  static const int kGuildQueryMemberFieldNumber = 34;
  inline const ::up::guild_query_member& _guild_query_member() const;
  inline ::up::guild_query_member* mutable__guild_query_member();
  inline ::up::guild_query_member* release__guild_query_member();
  inline void set_allocated__guild_query_member(::up::guild_query_member* _guild_query_member);

  // optional .up.guild_stage_rank _guild_stage_rank = 35;
  inline bool has__guild_stage_rank() const;
  inline void clear__guild_stage_rank();
  static const int kGuildStageRankFieldNumber = 35;
  inline const ::up::guild_stage_rank& _guild_stage_rank() const;
  inline ::up::guild_stage_rank* mutable__guild_stage_rank();
  inline ::up::guild_stage_rank* release__guild_stage_rank();
  inline void set_allocated__guild_stage_rank(::up::guild_stage_rank* _guild_stage_rank);

  // optional .up.guild_set_jump _set_jump = 36;
  inline bool has__set_jump() const;
  inline void clear__set_jump();
  static const int kSetJumpFieldNumber = 36;
  inline const ::up::guild_set_jump& _set_jump() const;
  inline ::up::guild_set_jump* mutable__set_jump();
  inline ::up::guild_set_jump* release__set_jump();
  inline void set_allocated__set_jump(::up::guild_set_jump* _set_jump);

  // @@protoc_insertion_point(class_scope:up.guild)
 private:
  inline void set_has__create();
  inline void clear_has__create();
  inline void set_has__dismiss();
  inline void clear_has__dismiss();
  inline void set_has__list();
  inline void clear_has__list();
  inline void set_has__search();
  inline void clear_has__search();
  inline void set_has__join();
  inline void clear_has__join();
  inline void set_has__join_confirm();
  inline void clear_has__join_confirm();
  inline void set_has__guild_leave();
  inline void clear_has__guild_leave();
  inline void set_has__kick();
  inline void clear_has__kick();
  inline void set_has__set();
  inline void clear_has__set();
  inline void set_has__query();
  inline void clear_has__query();
  inline void set_has__open_pannel();
  inline void clear_has__open_pannel();
  inline void set_has__set_job();
  inline void clear_has__set_job();
  inline void set_has__add_hire();
  inline void clear_has__add_hire();
  inline void set_has__del_hire();
  inline void clear_has__del_hire();
  inline void set_has__query_hires();
  inline void clear_has__query_hires();
  inline void set_has__hire_hero();
  inline void clear_has__hire_hero();
  inline void set_has__worship_req();
  inline void clear_has__worship_req();
  inline void set_has__worship_withdraw();
  inline void clear_has__worship_withdraw();
  inline void set_has__query_hh_detail();
  inline void clear_has__query_hh_detail();
  inline void set_has__instance_query();
  inline void clear_has__instance_query();
  inline void set_has__instance_detail();
  inline void clear_has__instance_detail();
  inline void set_has__instance_start();
  inline void clear_has__instance_start();
  inline void set_has__instance_end();
  inline void clear_has__instance_end();
  inline void set_has__instance_drop();
  inline void clear_has__instance_drop();
  inline void set_has__instance_open();
  inline void clear_has__instance_open();
  inline void set_has__instance_apply();
  inline void clear_has__instance_apply();
  inline void set_has__drop_info();
  inline void clear_has__drop_info();
  inline void set_has__drop_give();
  inline void clear_has__drop_give();
  inline void set_has__instance_damage();
  inline void clear_has__instance_damage();
  inline void set_has__items_history();
  inline void clear_has__items_history();
  inline void set_has__guild_jump();
  inline void clear_has__guild_jump();
  inline void set_has__guild_app_queue();
  inline void clear_has__guild_app_queue();
  inline void set_has__instance_prepare();
  inline void clear_has__instance_prepare();
  inline void set_has__guild_query_member();
  inline void clear_has__guild_query_member();
  inline void set_has__guild_stage_rank();
  inline void clear_has__guild_stage_rank();
  inline void set_has__set_jump();
  inline void clear_has__set_jump();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::up::guild_create* _create_;
  ::up::guild_dismiss* _dismiss_;
  ::up::guild_list* _list_;
  ::up::guild_search* _search_;
  ::up::guild_join* _join_;
  ::up::guild_join_confirm* _join_confirm_;
  ::up::guild_leave* _guild_leave_;
  ::up::guild_kick* _kick_;
  ::up::guild_set* _set_;
  ::up::guild_query* _query_;
  ::up::guild_open_pannel* _open_pannel_;
  ::up::guild_set_job* _set_job_;
  ::up::guild_add_hire* _add_hire_;
  ::up::guild_del_hire* _del_hire_;
  ::up::guild_query_hires* _query_hires_;
  ::up::guild_hire_hero* _hire_hero_;
  ::up::guild_worship_req* _worship_req_;
  ::up::guild_worship_withdraw* _worship_withdraw_;
  ::up::guild_qurey_hh_detail* _query_hh_detail_;
  ::up::guild_instance_query* _instance_query_;
  ::up::guild_instance_detail* _instance_detail_;
  ::up::guild_instance_start* _instance_start_;
  ::up::guild_instance_end* _instance_end_;
  ::up::guild_instance_drop* _instance_drop_;
  ::up::guild_instance_open* _instance_open_;
  ::up::guild_instance_apply* _instance_apply_;
  ::up::guild_drop_info* _drop_info_;
  ::up::guild_drop_give* _drop_give_;
  ::up::guild_instance_damage* _instance_damage_;
  ::up::guild_items_history* _items_history_;
  ::up::guild_jump* _guild_jump_;
  ::up::guild_app_queue* _guild_app_queue_;
  ::up::guild_prepare_instance* _instance_prepare_;
  ::up::guild_query_member* _guild_query_member_;
  ::up::guild_stage_rank* _guild_stage_rank_;
  ::up::guild_set_jump* _set_jump_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(36 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild* default_instance_;
};
// -------------------------------------------------------------------

class guild_set_jump : public ::google::protobuf::Message {
 public:
  guild_set_jump();
  virtual ~guild_set_jump();

  guild_set_jump(const guild_set_jump& from);

  inline guild_set_jump& operator=(const guild_set_jump& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_set_jump& default_instance();

  void Swap(guild_set_jump* other);

  // implements Message ----------------------------------------------

  guild_set_jump* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_set_jump& from);
  void MergeFrom(const guild_set_jump& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef guild_set_jump_is_can_jump is_can_jump;
  static const is_can_jump _true = guild_set_jump_is_can_jump__true;
  static const is_can_jump _false = guild_set_jump_is_can_jump__false;
  static inline bool is_can_jump_IsValid(int value) {
    return guild_set_jump_is_can_jump_IsValid(value);
  }
  static const is_can_jump is_can_jump_MIN =
    guild_set_jump_is_can_jump_is_can_jump_MIN;
  static const is_can_jump is_can_jump_MAX =
    guild_set_jump_is_can_jump_is_can_jump_MAX;
  static const int is_can_jump_ARRAYSIZE =
    guild_set_jump_is_can_jump_is_can_jump_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  is_can_jump_descriptor() {
    return guild_set_jump_is_can_jump_descriptor();
  }
  static inline const ::std::string& is_can_jump_Name(is_can_jump value) {
    return guild_set_jump_is_can_jump_Name(value);
  }
  static inline bool is_can_jump_Parse(const ::std::string& name,
      is_can_jump* value) {
    return guild_set_jump_is_can_jump_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.guild_set_jump.is_can_jump _is_can_jump = 1;
  inline bool has__is_can_jump() const;
  inline void clear__is_can_jump();
  static const int kIsCanJumpFieldNumber = 1;
  inline ::up::guild_set_jump_is_can_jump _is_can_jump() const;
  inline void set__is_can_jump(::up::guild_set_jump_is_can_jump value);

  // @@protoc_insertion_point(class_scope:up.guild_set_jump)
 private:
  inline void set_has__is_can_jump();
  inline void clear_has__is_can_jump();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _is_can_jump_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_set_jump* default_instance_;
};
// -------------------------------------------------------------------

class guild_stage_rank : public ::google::protobuf::Message {
 public:
  guild_stage_rank();
  virtual ~guild_stage_rank();

  guild_stage_rank(const guild_stage_rank& from);

  inline guild_stage_rank& operator=(const guild_stage_rank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_stage_rank& default_instance();

  void Swap(guild_stage_rank* other);

  // implements Message ----------------------------------------------

  guild_stage_rank* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_stage_rank& from);
  void MergeFrom(const guild_stage_rank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _stage_id = 1;
  inline bool has__stage_id() const;
  inline void clear__stage_id();
  static const int kStageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _stage_id() const;
  inline void set__stage_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_stage_rank)
 private:
  inline void set_has__stage_id();
  inline void clear_has__stage_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _stage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_stage_rank* default_instance_;
};
// -------------------------------------------------------------------

class guild_query_member : public ::google::protobuf::Message {
 public:
  guild_query_member();
  virtual ~guild_query_member();

  guild_query_member(const guild_query_member& from);

  inline guild_query_member& operator=(const guild_query_member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_query_member& default_instance();

  void Swap(guild_query_member* other);

  // implements Message ----------------------------------------------

  guild_query_member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_query_member& from);
  void MergeFrom(const guild_query_member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_query_member)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_query_member* default_instance_;
};
// -------------------------------------------------------------------

class guild_prepare_instance : public ::google::protobuf::Message {
 public:
  guild_prepare_instance();
  virtual ~guild_prepare_instance();

  guild_prepare_instance(const guild_prepare_instance& from);

  inline guild_prepare_instance& operator=(const guild_prepare_instance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_prepare_instance& default_instance();

  void Swap(guild_prepare_instance* other);

  // implements Message ----------------------------------------------

  guild_prepare_instance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_prepare_instance& from);
  void MergeFrom(const guild_prepare_instance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _stage_id = 1;
  inline bool has__stage_id() const;
  inline void clear__stage_id();
  static const int kStageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _stage_id() const;
  inline void set__stage_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_prepare_instance)
 private:
  inline void set_has__stage_id();
  inline void clear_has__stage_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _stage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_prepare_instance* default_instance_;
};
// -------------------------------------------------------------------

class guild_app_queue : public ::google::protobuf::Message {
 public:
  guild_app_queue();
  virtual ~guild_app_queue();

  guild_app_queue(const guild_app_queue& from);

  inline guild_app_queue& operator=(const guild_app_queue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_app_queue& default_instance();

  void Swap(guild_app_queue* other);

  // implements Message ----------------------------------------------

  guild_app_queue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_app_queue& from);
  void MergeFrom(const guild_app_queue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _item_id = 1;
  inline bool has__item_id() const;
  inline void clear__item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _item_id() const;
  inline void set__item_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_app_queue)
 private:
  inline void set_has__item_id();
  inline void clear_has__item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_app_queue* default_instance_;
};
// -------------------------------------------------------------------

class guild_jump : public ::google::protobuf::Message {
 public:
  guild_jump();
  virtual ~guild_jump();

  guild_jump(const guild_jump& from);

  inline guild_jump& operator=(const guild_jump& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_jump& default_instance();

  void Swap(guild_jump* other);

  // implements Message ----------------------------------------------

  guild_jump* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_jump& from);
  void MergeFrom(const guild_jump& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_jump)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_jump* default_instance_;
};
// -------------------------------------------------------------------

class guild_items_history : public ::google::protobuf::Message {
 public:
  guild_items_history();
  virtual ~guild_items_history();

  guild_items_history(const guild_items_history& from);

  inline guild_items_history& operator=(const guild_items_history& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_items_history& default_instance();

  void Swap(guild_items_history* other);

  // implements Message ----------------------------------------------

  guild_items_history* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_items_history& from);
  void MergeFrom(const guild_items_history& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_items_history)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_items_history* default_instance_;
};
// -------------------------------------------------------------------

class guild_drop_give : public ::google::protobuf::Message {
 public:
  guild_drop_give();
  virtual ~guild_drop_give();

  guild_drop_give(const guild_drop_give& from);

  inline guild_drop_give& operator=(const guild_drop_give& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_drop_give& default_instance();

  void Swap(guild_drop_give* other);

  // implements Message ----------------------------------------------

  guild_drop_give* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_drop_give& from);
  void MergeFrom(const guild_drop_give& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _item_id = 1;
  inline bool has__item_id() const;
  inline void clear__item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _item_id() const;
  inline void set__item_id(::google::protobuf::uint32 value);

  // required uint32 _raid_id = 2;
  inline bool has__raid_id() const;
  inline void clear__raid_id();
  static const int kRaidIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _raid_id() const;
  inline void set__raid_id(::google::protobuf::uint32 value);

  // required uint32 _user_id = 3;
  inline bool has__user_id() const;
  inline void clear__user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::uint32 _user_id() const;
  inline void set__user_id(::google::protobuf::uint32 value);

  // required uint32 _time_out_end = 4;
  inline bool has__time_out_end() const;
  inline void clear__time_out_end();
  static const int kTimeOutEndFieldNumber = 4;
  inline ::google::protobuf::uint32 _time_out_end() const;
  inline void set__time_out_end(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_drop_give)
 private:
  inline void set_has__item_id();
  inline void clear_has__item_id();
  inline void set_has__raid_id();
  inline void clear_has__raid_id();
  inline void set_has__user_id();
  inline void clear_has__user_id();
  inline void set_has__time_out_end();
  inline void clear_has__time_out_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _item_id_;
  ::google::protobuf::uint32 _raid_id_;
  ::google::protobuf::uint32 _user_id_;
  ::google::protobuf::uint32 _time_out_end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_drop_give* default_instance_;
};
// -------------------------------------------------------------------

class guild_instance_damage : public ::google::protobuf::Message {
 public:
  guild_instance_damage();
  virtual ~guild_instance_damage();

  guild_instance_damage(const guild_instance_damage& from);

  inline guild_instance_damage& operator=(const guild_instance_damage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_instance_damage& default_instance();

  void Swap(guild_instance_damage* other);

  // implements Message ----------------------------------------------

  guild_instance_damage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_instance_damage& from);
  void MergeFrom(const guild_instance_damage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _raid_id = 1;
  inline bool has__raid_id() const;
  inline void clear__raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _raid_id() const;
  inline void set__raid_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_instance_damage)
 private:
  inline void set_has__raid_id();
  inline void clear_has__raid_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _raid_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_instance_damage* default_instance_;
};
// -------------------------------------------------------------------

class guild_drop_info : public ::google::protobuf::Message {
 public:
  guild_drop_info();
  virtual ~guild_drop_info();

  guild_drop_info(const guild_drop_info& from);

  inline guild_drop_info& operator=(const guild_drop_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_drop_info& default_instance();

  void Swap(guild_drop_info* other);

  // implements Message ----------------------------------------------

  guild_drop_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_drop_info& from);
  void MergeFrom(const guild_drop_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_drop_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_drop_info* default_instance_;
};
// -------------------------------------------------------------------

class guild_instance_apply : public ::google::protobuf::Message {
 public:
  guild_instance_apply();
  virtual ~guild_instance_apply();

  guild_instance_apply(const guild_instance_apply& from);

  inline guild_instance_apply& operator=(const guild_instance_apply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_instance_apply& default_instance();

  void Swap(guild_instance_apply* other);

  // implements Message ----------------------------------------------

  guild_instance_apply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_instance_apply& from);
  void MergeFrom(const guild_instance_apply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _raid_id = 1;
  inline bool has__raid_id() const;
  inline void clear__raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _raid_id() const;
  inline void set__raid_id(::google::protobuf::uint32 value);

  // required uint32 _item_id = 2;
  inline bool has__item_id() const;
  inline void clear__item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _item_id() const;
  inline void set__item_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_instance_apply)
 private:
  inline void set_has__raid_id();
  inline void clear_has__raid_id();
  inline void set_has__item_id();
  inline void clear_has__item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _raid_id_;
  ::google::protobuf::uint32 _item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_instance_apply* default_instance_;
};
// -------------------------------------------------------------------

class guild_instance_start : public ::google::protobuf::Message {
 public:
  guild_instance_start();
  virtual ~guild_instance_start();

  guild_instance_start(const guild_instance_start& from);

  inline guild_instance_start& operator=(const guild_instance_start& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_instance_start& default_instance();

  void Swap(guild_instance_start* other);

  // implements Message ----------------------------------------------

  guild_instance_start* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_instance_start& from);
  void MergeFrom(const guild_instance_start& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _stage_id = 1;
  inline bool has__stage_id() const;
  inline void clear__stage_id();
  static const int kStageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _stage_id() const;
  inline void set__stage_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_instance_start)
 private:
  inline void set_has__stage_id();
  inline void clear_has__stage_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _stage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_instance_start* default_instance_;
};
// -------------------------------------------------------------------

class guild_instance_end : public ::google::protobuf::Message {
 public:
  guild_instance_end();
  virtual ~guild_instance_end();

  guild_instance_end(const guild_instance_end& from);

  inline guild_instance_end& operator=(const guild_instance_end& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_instance_end& default_instance();

  void Swap(guild_instance_end* other);

  // implements Message ----------------------------------------------

  guild_instance_end* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_instance_end& from);
  void MergeFrom(const guild_instance_end& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.battle_result _result = 1;
  inline bool has__result() const;
  inline void clear__result();
  static const int kResultFieldNumber = 1;
  inline ::up::battle_result _result() const;
  inline void set__result(::up::battle_result value);

  // repeated uint32 _hp_info = 2;
  inline int _hp_info_size() const;
  inline void clear__hp_info();
  static const int kHpInfoFieldNumber = 2;
  inline ::google::protobuf::uint32 _hp_info(int index) const;
  inline void set__hp_info(int index, ::google::protobuf::uint32 value);
  inline void add__hp_info(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _hp_info() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__hp_info();

  // required uint32 _wave = 3;
  inline bool has__wave() const;
  inline void clear__wave();
  static const int kWaveFieldNumber = 3;
  inline ::google::protobuf::uint32 _wave() const;
  inline void set__wave(::google::protobuf::uint32 value);

  // required uint32 _damage = 4;
  inline bool has__damage() const;
  inline void clear__damage();
  static const int kDamageFieldNumber = 4;
  inline ::google::protobuf::uint32 _damage() const;
  inline void set__damage(::google::protobuf::uint32 value);

  // required uint32 _progress = 5;
  inline bool has__progress() const;
  inline void clear__progress();
  static const int kProgressFieldNumber = 5;
  inline ::google::protobuf::uint32 _progress() const;
  inline void set__progress(::google::protobuf::uint32 value);

  // required uint32 _stage_progress = 6;
  inline bool has__stage_progress() const;
  inline void clear__stage_progress();
  static const int kStageProgressFieldNumber = 6;
  inline ::google::protobuf::uint32 _stage_progress() const;
  inline void set__stage_progress(::google::protobuf::uint32 value);

  // repeated uint32 _oprations = 7;
  inline int _oprations_size() const;
  inline void clear__oprations();
  static const int kOprationsFieldNumber = 7;
  inline ::google::protobuf::uint32 _oprations(int index) const;
  inline void set__oprations(int index, ::google::protobuf::uint32 value);
  inline void add__oprations(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _oprations() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__oprations();

  // repeated uint32 _heroes = 8;
  inline int _heroes_size() const;
  inline void clear__heroes();
  static const int kHeroesFieldNumber = 8;
  inline ::google::protobuf::uint32 _heroes(int index) const;
  inline void set__heroes(int index, ::google::protobuf::uint32 value);
  inline void add__heroes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _heroes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__heroes();

  // @@protoc_insertion_point(class_scope:up.guild_instance_end)
 private:
  inline void set_has__result();
  inline void clear_has__result();
  inline void set_has__wave();
  inline void clear_has__wave();
  inline void set_has__damage();
  inline void clear_has__damage();
  inline void set_has__progress();
  inline void clear_has__progress();
  inline void set_has__stage_progress();
  inline void clear_has__stage_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _hp_info_;
  int _result_;
  ::google::protobuf::uint32 _wave_;
  ::google::protobuf::uint32 _damage_;
  ::google::protobuf::uint32 _progress_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _oprations_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _heroes_;
  ::google::protobuf::uint32 _stage_progress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_instance_end* default_instance_;
};
// -------------------------------------------------------------------

class guild_instance_drop : public ::google::protobuf::Message {
 public:
  guild_instance_drop();
  virtual ~guild_instance_drop();

  guild_instance_drop(const guild_instance_drop& from);

  inline guild_instance_drop& operator=(const guild_instance_drop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_instance_drop& default_instance();

  void Swap(guild_instance_drop* other);

  // implements Message ----------------------------------------------

  guild_instance_drop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_instance_drop& from);
  void MergeFrom(const guild_instance_drop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _raid_id = 1;
  inline bool has__raid_id() const;
  inline void clear__raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _raid_id() const;
  inline void set__raid_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_instance_drop)
 private:
  inline void set_has__raid_id();
  inline void clear_has__raid_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _raid_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_instance_drop* default_instance_;
};
// -------------------------------------------------------------------

class guild_instance_open : public ::google::protobuf::Message {
 public:
  guild_instance_open();
  virtual ~guild_instance_open();

  guild_instance_open(const guild_instance_open& from);

  inline guild_instance_open& operator=(const guild_instance_open& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_instance_open& default_instance();

  void Swap(guild_instance_open* other);

  // implements Message ----------------------------------------------

  guild_instance_open* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_instance_open& from);
  void MergeFrom(const guild_instance_open& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _raid_id = 1;
  inline bool has__raid_id() const;
  inline void clear__raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _raid_id() const;
  inline void set__raid_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_instance_open)
 private:
  inline void set_has__raid_id();
  inline void clear_has__raid_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _raid_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_instance_open* default_instance_;
};
// -------------------------------------------------------------------

class guild_instance_query : public ::google::protobuf::Message {
 public:
  guild_instance_query();
  virtual ~guild_instance_query();

  guild_instance_query(const guild_instance_query& from);

  inline guild_instance_query& operator=(const guild_instance_query& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_instance_query& default_instance();

  void Swap(guild_instance_query* other);

  // implements Message ----------------------------------------------

  guild_instance_query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_instance_query& from);
  void MergeFrom(const guild_instance_query& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_instance_query)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_instance_query* default_instance_;
};
// -------------------------------------------------------------------

class guild_instance_detail : public ::google::protobuf::Message {
 public:
  guild_instance_detail();
  virtual ~guild_instance_detail();

  guild_instance_detail(const guild_instance_detail& from);

  inline guild_instance_detail& operator=(const guild_instance_detail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_instance_detail& default_instance();

  void Swap(guild_instance_detail* other);

  // implements Message ----------------------------------------------

  guild_instance_detail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_instance_detail& from);
  void MergeFrom(const guild_instance_detail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _stage_id = 1;
  inline bool has__stage_id() const;
  inline void clear__stage_id();
  static const int kStageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _stage_id() const;
  inline void set__stage_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_instance_detail)
 private:
  inline void set_has__stage_id();
  inline void clear_has__stage_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _stage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_instance_detail* default_instance_;
};
// -------------------------------------------------------------------

class guild_create : public ::google::protobuf::Message {
 public:
  guild_create();
  virtual ~guild_create();

  guild_create(const guild_create& from);

  inline guild_create& operator=(const guild_create& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_create& default_instance();

  void Swap(guild_create* other);

  // implements Message ----------------------------------------------

  guild_create* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_create& from);
  void MergeFrom(const guild_create& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _name = 1;
  inline bool has__name() const;
  inline void clear__name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& _name() const;
  inline void set__name(const ::std::string& value);
  inline void set__name(const char* value);
  inline void set__name(const char* value, size_t size);
  inline ::std::string* mutable__name();
  inline ::std::string* release__name();
  inline void set_allocated__name(::std::string* _name);

  // required uint32 _avatar = 2;
  inline bool has__avatar() const;
  inline void clear__avatar();
  static const int kAvatarFieldNumber = 2;
  inline ::google::protobuf::uint32 _avatar() const;
  inline void set__avatar(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_create)
 private:
  inline void set_has__name();
  inline void clear_has__name();
  inline void set_has__avatar();
  inline void clear_has__avatar();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _name_;
  ::google::protobuf::uint32 _avatar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_create* default_instance_;
};
// -------------------------------------------------------------------

class guild_dismiss : public ::google::protobuf::Message {
 public:
  guild_dismiss();
  virtual ~guild_dismiss();

  guild_dismiss(const guild_dismiss& from);

  inline guild_dismiss& operator=(const guild_dismiss& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_dismiss& default_instance();

  void Swap(guild_dismiss* other);

  // implements Message ----------------------------------------------

  guild_dismiss* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_dismiss& from);
  void MergeFrom(const guild_dismiss& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_dismiss)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_dismiss* default_instance_;
};
// -------------------------------------------------------------------

class guild_list : public ::google::protobuf::Message {
 public:
  guild_list();
  virtual ~guild_list();

  guild_list(const guild_list& from);

  inline guild_list& operator=(const guild_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_list& default_instance();

  void Swap(guild_list* other);

  // implements Message ----------------------------------------------

  guild_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_list& from);
  void MergeFrom(const guild_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_list* default_instance_;
};
// -------------------------------------------------------------------

class guild_search : public ::google::protobuf::Message {
 public:
  guild_search();
  virtual ~guild_search();

  guild_search(const guild_search& from);

  inline guild_search& operator=(const guild_search& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_search& default_instance();

  void Swap(guild_search* other);

  // implements Message ----------------------------------------------

  guild_search* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_search& from);
  void MergeFrom(const guild_search& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _guild_id = 1;
  inline bool has__guild_id() const;
  inline void clear__guild_id();
  static const int kGuildIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _guild_id() const;
  inline void set__guild_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_search)
 private:
  inline void set_has__guild_id();
  inline void clear_has__guild_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _guild_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_search* default_instance_;
};
// -------------------------------------------------------------------

class guild_join : public ::google::protobuf::Message {
 public:
  guild_join();
  virtual ~guild_join();

  guild_join(const guild_join& from);

  inline guild_join& operator=(const guild_join& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_join& default_instance();

  void Swap(guild_join* other);

  // implements Message ----------------------------------------------

  guild_join* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_join& from);
  void MergeFrom(const guild_join& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _guild_id = 1;
  inline bool has__guild_id() const;
  inline void clear__guild_id();
  static const int kGuildIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _guild_id() const;
  inline void set__guild_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_join)
 private:
  inline void set_has__guild_id();
  inline void clear_has__guild_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _guild_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_join* default_instance_;
};
// -------------------------------------------------------------------

class guild_join_confirm : public ::google::protobuf::Message {
 public:
  guild_join_confirm();
  virtual ~guild_join_confirm();

  guild_join_confirm(const guild_join_confirm& from);

  inline guild_join_confirm& operator=(const guild_join_confirm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_join_confirm& default_instance();

  void Swap(guild_join_confirm* other);

  // implements Message ----------------------------------------------

  guild_join_confirm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_join_confirm& from);
  void MergeFrom(const guild_join_confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef guild_join_confirm_confirm_type confirm_type;
  static const confirm_type accept = guild_join_confirm_confirm_type_accept;
  static const confirm_type reject = guild_join_confirm_confirm_type_reject;
  static inline bool confirm_type_IsValid(int value) {
    return guild_join_confirm_confirm_type_IsValid(value);
  }
  static const confirm_type confirm_type_MIN =
    guild_join_confirm_confirm_type_confirm_type_MIN;
  static const confirm_type confirm_type_MAX =
    guild_join_confirm_confirm_type_confirm_type_MAX;
  static const int confirm_type_ARRAYSIZE =
    guild_join_confirm_confirm_type_confirm_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  confirm_type_descriptor() {
    return guild_join_confirm_confirm_type_descriptor();
  }
  static inline const ::std::string& confirm_type_Name(confirm_type value) {
    return guild_join_confirm_confirm_type_Name(value);
  }
  static inline bool confirm_type_Parse(const ::std::string& name,
      confirm_type* value) {
    return guild_join_confirm_confirm_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 _uid = 1;
  inline bool has__uid() const;
  inline void clear__uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 _uid() const;
  inline void set__uid(::google::protobuf::uint32 value);

  // required .up.guild_join_confirm.confirm_type _type = 2 [default = accept];
  inline bool has__type() const;
  inline void clear__type();
  static const int kTypeFieldNumber = 2;
  inline ::up::guild_join_confirm_confirm_type _type() const;
  inline void set__type(::up::guild_join_confirm_confirm_type value);

  // @@protoc_insertion_point(class_scope:up.guild_join_confirm)
 private:
  inline void set_has__uid();
  inline void clear_has__uid();
  inline void set_has__type();
  inline void clear_has__type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _uid_;
  int _type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_join_confirm* default_instance_;
};
// -------------------------------------------------------------------

class guild_leave : public ::google::protobuf::Message {
 public:
  guild_leave();
  virtual ~guild_leave();

  guild_leave(const guild_leave& from);

  inline guild_leave& operator=(const guild_leave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_leave& default_instance();

  void Swap(guild_leave* other);

  // implements Message ----------------------------------------------

  guild_leave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_leave& from);
  void MergeFrom(const guild_leave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_leave)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_leave* default_instance_;
};
// -------------------------------------------------------------------

class guild_kick : public ::google::protobuf::Message {
 public:
  guild_kick();
  virtual ~guild_kick();

  guild_kick(const guild_kick& from);

  inline guild_kick& operator=(const guild_kick& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_kick& default_instance();

  void Swap(guild_kick* other);

  // implements Message ----------------------------------------------

  guild_kick* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_kick& from);
  void MergeFrom(const guild_kick& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _uid = 1;
  inline bool has__uid() const;
  inline void clear__uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 _uid() const;
  inline void set__uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_kick)
 private:
  inline void set_has__uid();
  inline void clear_has__uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_kick* default_instance_;
};
// -------------------------------------------------------------------

class guild_set : public ::google::protobuf::Message {
 public:
  guild_set();
  virtual ~guild_set();

  guild_set(const guild_set& from);

  inline guild_set& operator=(const guild_set& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_set& default_instance();

  void Swap(guild_set* other);

  // implements Message ----------------------------------------------

  guild_set* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_set& from);
  void MergeFrom(const guild_set& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef guild_set_guild_join_t guild_join_t;
  static const guild_join_t no_verify = guild_set_guild_join_t_no_verify;
  static const guild_join_t verify = guild_set_guild_join_t_verify;
  static const guild_join_t closed = guild_set_guild_join_t_closed;
  static inline bool guild_join_t_IsValid(int value) {
    return guild_set_guild_join_t_IsValid(value);
  }
  static const guild_join_t guild_join_t_MIN =
    guild_set_guild_join_t_guild_join_t_MIN;
  static const guild_join_t guild_join_t_MAX =
    guild_set_guild_join_t_guild_join_t_MAX;
  static const int guild_join_t_ARRAYSIZE =
    guild_set_guild_join_t_guild_join_t_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  guild_join_t_descriptor() {
    return guild_set_guild_join_t_descriptor();
  }
  static inline const ::std::string& guild_join_t_Name(guild_join_t value) {
    return guild_set_guild_join_t_Name(value);
  }
  static inline bool guild_join_t_Parse(const ::std::string& name,
      guild_join_t* value) {
    return guild_set_guild_join_t_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 _avatar = 1;
  inline bool has__avatar() const;
  inline void clear__avatar();
  static const int kAvatarFieldNumber = 1;
  inline ::google::protobuf::uint32 _avatar() const;
  inline void set__avatar(::google::protobuf::uint32 value);

  // optional .up.guild_set.guild_join_t _join_type = 2;
  inline bool has__join_type() const;
  inline void clear__join_type();
  static const int kJoinTypeFieldNumber = 2;
  inline ::up::guild_set_guild_join_t _join_type() const;
  inline void set__join_type(::up::guild_set_guild_join_t value);

  // optional uint32 _join_limit = 3;
  inline bool has__join_limit() const;
  inline void clear__join_limit();
  static const int kJoinLimitFieldNumber = 3;
  inline ::google::protobuf::uint32 _join_limit() const;
  inline void set__join_limit(::google::protobuf::uint32 value);

  // optional string _slogan = 4;
  inline bool has__slogan() const;
  inline void clear__slogan();
  static const int kSloganFieldNumber = 4;
  inline const ::std::string& _slogan() const;
  inline void set__slogan(const ::std::string& value);
  inline void set__slogan(const char* value);
  inline void set__slogan(const char* value, size_t size);
  inline ::std::string* mutable__slogan();
  inline ::std::string* release__slogan();
  inline void set_allocated__slogan(::std::string* _slogan);

  // optional uint32 _can_jump = 5;
  inline bool has__can_jump() const;
  inline void clear__can_jump();
  static const int kCanJumpFieldNumber = 5;
  inline ::google::protobuf::uint32 _can_jump() const;
  inline void set__can_jump(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_set)
 private:
  inline void set_has__avatar();
  inline void clear_has__avatar();
  inline void set_has__join_type();
  inline void clear_has__join_type();
  inline void set_has__join_limit();
  inline void clear_has__join_limit();
  inline void set_has__slogan();
  inline void clear_has__slogan();
  inline void set_has__can_jump();
  inline void clear_has__can_jump();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _avatar_;
  int _join_type_;
  ::std::string* _slogan_;
  ::google::protobuf::uint32 _join_limit_;
  ::google::protobuf::uint32 _can_jump_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_set* default_instance_;
};
// -------------------------------------------------------------------

class guild_query : public ::google::protobuf::Message {
 public:
  guild_query();
  virtual ~guild_query();

  guild_query(const guild_query& from);

  inline guild_query& operator=(const guild_query& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_query& default_instance();

  void Swap(guild_query* other);

  // implements Message ----------------------------------------------

  guild_query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_query& from);
  void MergeFrom(const guild_query& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_query)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_query* default_instance_;
};
// -------------------------------------------------------------------

class guild_open_pannel : public ::google::protobuf::Message {
 public:
  guild_open_pannel();
  virtual ~guild_open_pannel();

  guild_open_pannel(const guild_open_pannel& from);

  inline guild_open_pannel& operator=(const guild_open_pannel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_open_pannel& default_instance();

  void Swap(guild_open_pannel* other);

  // implements Message ----------------------------------------------

  guild_open_pannel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_open_pannel& from);
  void MergeFrom(const guild_open_pannel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_open_pannel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_open_pannel* default_instance_;
};
// -------------------------------------------------------------------

class guild_set_job : public ::google::protobuf::Message {
 public:
  guild_set_job();
  virtual ~guild_set_job();

  guild_set_job(const guild_set_job& from);

  inline guild_set_job& operator=(const guild_set_job& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_set_job& default_instance();

  void Swap(guild_set_job* other);

  // implements Message ----------------------------------------------

  guild_set_job* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_set_job& from);
  void MergeFrom(const guild_set_job& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _uid = 1;
  inline bool has__uid() const;
  inline void clear__uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 _uid() const;
  inline void set__uid(::google::protobuf::uint32 value);

  // required .up.guild_job_t _job = 2;
  inline bool has__job() const;
  inline void clear__job();
  static const int kJobFieldNumber = 2;
  inline ::up::guild_job_t _job() const;
  inline void set__job(::up::guild_job_t value);

  // @@protoc_insertion_point(class_scope:up.guild_set_job)
 private:
  inline void set_has__uid();
  inline void clear_has__uid();
  inline void set_has__job();
  inline void clear_has__job();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _uid_;
  int _job_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_set_job* default_instance_;
};
// -------------------------------------------------------------------

class guild_add_hire : public ::google::protobuf::Message {
 public:
  guild_add_hire();
  virtual ~guild_add_hire();

  guild_add_hire(const guild_add_hire& from);

  inline guild_add_hire& operator=(const guild_add_hire& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_add_hire& default_instance();

  void Swap(guild_add_hire* other);

  // implements Message ----------------------------------------------

  guild_add_hire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_add_hire& from);
  void MergeFrom(const guild_add_hire& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _heroid = 1;
  inline bool has__heroid() const;
  inline void clear__heroid();
  static const int kHeroidFieldNumber = 1;
  inline ::google::protobuf::uint32 _heroid() const;
  inline void set__heroid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_add_hire)
 private:
  inline void set_has__heroid();
  inline void clear_has__heroid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _heroid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_add_hire* default_instance_;
};
// -------------------------------------------------------------------

class guild_del_hire : public ::google::protobuf::Message {
 public:
  guild_del_hire();
  virtual ~guild_del_hire();

  guild_del_hire(const guild_del_hire& from);

  inline guild_del_hire& operator=(const guild_del_hire& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_del_hire& default_instance();

  void Swap(guild_del_hire* other);

  // implements Message ----------------------------------------------

  guild_del_hire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_del_hire& from);
  void MergeFrom(const guild_del_hire& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _heroid = 2;
  inline bool has__heroid() const;
  inline void clear__heroid();
  static const int kHeroidFieldNumber = 2;
  inline ::google::protobuf::uint32 _heroid() const;
  inline void set__heroid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_del_hire)
 private:
  inline void set_has__heroid();
  inline void clear_has__heroid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _heroid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_del_hire* default_instance_;
};
// -------------------------------------------------------------------

class guild_query_hires : public ::google::protobuf::Message {
 public:
  guild_query_hires();
  virtual ~guild_query_hires();

  guild_query_hires(const guild_query_hires& from);

  inline guild_query_hires& operator=(const guild_query_hires& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_query_hires& default_instance();

  void Swap(guild_query_hires* other);

  // implements Message ----------------------------------------------

  guild_query_hires* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_query_hires& from);
  void MergeFrom(const guild_query_hires& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.hire_from _from = 1;
  inline bool has__from() const;
  inline void clear__from();
  static const int kFromFieldNumber = 1;
  inline ::up::hire_from _from() const;
  inline void set__from(::up::hire_from value);

  // @@protoc_insertion_point(class_scope:up.guild_query_hires)
 private:
  inline void set_has__from();
  inline void clear_has__from();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _from_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_query_hires* default_instance_;
};
// -------------------------------------------------------------------

class guild_hire_hero : public ::google::protobuf::Message {
 public:
  guild_hire_hero();
  virtual ~guild_hire_hero();

  guild_hire_hero(const guild_hire_hero& from);

  inline guild_hire_hero& operator=(const guild_hire_hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_hire_hero& default_instance();

  void Swap(guild_hire_hero* other);

  // implements Message ----------------------------------------------

  guild_hire_hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_hire_hero& from);
  void MergeFrom(const guild_hire_hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _uid = 1;
  inline bool has__uid() const;
  inline void clear__uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 _uid() const;
  inline void set__uid(::google::protobuf::uint32 value);

  // required uint32 _heroid = 2;
  inline bool has__heroid() const;
  inline void clear__heroid();
  static const int kHeroidFieldNumber = 2;
  inline ::google::protobuf::uint32 _heroid() const;
  inline void set__heroid(::google::protobuf::uint32 value);

  // required .up.hire_from _from = 3;
  inline bool has__from() const;
  inline void clear__from();
  static const int kFromFieldNumber = 3;
  inline ::up::hire_from _from() const;
  inline void set__from(::up::hire_from value);

  // optional uint32 _stage_id = 4;
  inline bool has__stage_id() const;
  inline void clear__stage_id();
  static const int kStageIdFieldNumber = 4;
  inline ::google::protobuf::uint32 _stage_id() const;
  inline void set__stage_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_hire_hero)
 private:
  inline void set_has__uid();
  inline void clear_has__uid();
  inline void set_has__heroid();
  inline void clear_has__heroid();
  inline void set_has__from();
  inline void clear_has__from();
  inline void set_has__stage_id();
  inline void clear_has__stage_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _uid_;
  ::google::protobuf::uint32 _heroid_;
  int _from_;
  ::google::protobuf::uint32 _stage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_hire_hero* default_instance_;
};
// -------------------------------------------------------------------

class guild_worship_req : public ::google::protobuf::Message {
 public:
  guild_worship_req();
  virtual ~guild_worship_req();

  guild_worship_req(const guild_worship_req& from);

  inline guild_worship_req& operator=(const guild_worship_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_worship_req& default_instance();

  void Swap(guild_worship_req* other);

  // implements Message ----------------------------------------------

  guild_worship_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_worship_req& from);
  void MergeFrom(const guild_worship_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _id = 1;
  inline bool has__id() const;
  inline void clear__id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _id() const;
  inline void set__id(::google::protobuf::uint32 value);

  // required uint32 _uid = 2;
  inline bool has__uid() const;
  inline void clear__uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint32 _uid() const;
  inline void set__uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_worship_req)
 private:
  inline void set_has__id();
  inline void clear_has__id();
  inline void set_has__uid();
  inline void clear_has__uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _id_;
  ::google::protobuf::uint32 _uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_worship_req* default_instance_;
};
// -------------------------------------------------------------------

class guild_worship_withdraw : public ::google::protobuf::Message {
 public:
  guild_worship_withdraw();
  virtual ~guild_worship_withdraw();

  guild_worship_withdraw(const guild_worship_withdraw& from);

  inline guild_worship_withdraw& operator=(const guild_worship_withdraw& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_worship_withdraw& default_instance();

  void Swap(guild_worship_withdraw* other);

  // implements Message ----------------------------------------------

  guild_worship_withdraw* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_worship_withdraw& from);
  void MergeFrom(const guild_worship_withdraw& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.guild_worship_withdraw)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_worship_withdraw* default_instance_;
};
// -------------------------------------------------------------------

class guild_qurey_hh_detail : public ::google::protobuf::Message {
 public:
  guild_qurey_hh_detail();
  virtual ~guild_qurey_hh_detail();

  guild_qurey_hh_detail(const guild_qurey_hh_detail& from);

  inline guild_qurey_hh_detail& operator=(const guild_qurey_hh_detail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const guild_qurey_hh_detail& default_instance();

  void Swap(guild_qurey_hh_detail* other);

  // implements Message ----------------------------------------------

  guild_qurey_hh_detail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const guild_qurey_hh_detail& from);
  void MergeFrom(const guild_qurey_hh_detail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _uid = 1;
  inline bool has__uid() const;
  inline void clear__uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 _uid() const;
  inline void set__uid(::google::protobuf::uint32 value);

  // required uint32 _heroid = 2;
  inline bool has__heroid() const;
  inline void clear__heroid();
  static const int kHeroidFieldNumber = 2;
  inline ::google::protobuf::uint32 _heroid() const;
  inline void set__heroid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.guild_qurey_hh_detail)
 private:
  inline void set_has__uid();
  inline void clear_has__uid();
  inline void set_has__heroid();
  inline void clear_has__heroid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _uid_;
  ::google::protobuf::uint32 _heroid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static guild_qurey_hh_detail* default_instance_;
};
// -------------------------------------------------------------------

class ask_activity_info : public ::google::protobuf::Message {
 public:
  ask_activity_info();
  virtual ~ask_activity_info();

  ask_activity_info(const ask_activity_info& from);

  inline ask_activity_info& operator=(const ask_activity_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ask_activity_info& default_instance();

  void Swap(ask_activity_info* other);

  // implements Message ----------------------------------------------

  ask_activity_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ask_activity_info& from);
  void MergeFrom(const ask_activity_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.ask_activity_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static ask_activity_info* default_instance_;
};
// -------------------------------------------------------------------

class cdkey_gift : public ::google::protobuf::Message {
 public:
  cdkey_gift();
  virtual ~cdkey_gift();

  cdkey_gift(const cdkey_gift& from);

  inline cdkey_gift& operator=(const cdkey_gift& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cdkey_gift& default_instance();

  void Swap(cdkey_gift* other);

  // implements Message ----------------------------------------------

  cdkey_gift* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cdkey_gift& from);
  void MergeFrom(const cdkey_gift& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _cdkey = 1;
  inline bool has__cdkey() const;
  inline void clear__cdkey();
  static const int kCdkeyFieldNumber = 1;
  inline const ::std::string& _cdkey() const;
  inline void set__cdkey(const ::std::string& value);
  inline void set__cdkey(const char* value);
  inline void set__cdkey(const char* value, size_t size);
  inline ::std::string* mutable__cdkey();
  inline ::std::string* release__cdkey();
  inline void set_allocated__cdkey(::std::string* _cdkey);

  // @@protoc_insertion_point(class_scope:up.cdkey_gift)
 private:
  inline void set_has__cdkey();
  inline void clear_has__cdkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _cdkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static cdkey_gift* default_instance_;
};
// -------------------------------------------------------------------

class excavate : public ::google::protobuf::Message {
 public:
  excavate();
  virtual ~excavate();

  excavate(const excavate& from);

  inline excavate& operator=(const excavate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const excavate& default_instance();

  void Swap(excavate* other);

  // implements Message ----------------------------------------------

  excavate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const excavate& from);
  void MergeFrom(const excavate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .up.search_excavate _search_excavate = 1;
  inline bool has__search_excavate() const;
  inline void clear__search_excavate();
  static const int kSearchExcavateFieldNumber = 1;
  inline const ::up::search_excavate& _search_excavate() const;
  inline ::up::search_excavate* mutable__search_excavate();
  inline ::up::search_excavate* release__search_excavate();
  inline void set_allocated__search_excavate(::up::search_excavate* _search_excavate);

  // optional .up.query_excavate_data _query_excavate_data = 2;
  inline bool has__query_excavate_data() const;
  inline void clear__query_excavate_data();
  static const int kQueryExcavateDataFieldNumber = 2;
  inline const ::up::query_excavate_data& _query_excavate_data() const;
  inline ::up::query_excavate_data* mutable__query_excavate_data();
  inline ::up::query_excavate_data* release__query_excavate_data();
  inline void set_allocated__query_excavate_data(::up::query_excavate_data* _query_excavate_data);

  // optional .up.query_excavate_history _query_excavate_history = 3;
  inline bool has__query_excavate_history() const;
  inline void clear__query_excavate_history();
  static const int kQueryExcavateHistoryFieldNumber = 3;
  inline const ::up::query_excavate_history& _query_excavate_history() const;
  inline ::up::query_excavate_history* mutable__query_excavate_history();
  inline ::up::query_excavate_history* release__query_excavate_history();
  inline void set_allocated__query_excavate_history(::up::query_excavate_history* _query_excavate_history);

  // optional .up.query_excavate_battle _query_excavate_battle = 4;
  inline bool has__query_excavate_battle() const;
  inline void clear__query_excavate_battle();
  static const int kQueryExcavateBattleFieldNumber = 4;
  inline const ::up::query_excavate_battle& _query_excavate_battle() const;
  inline ::up::query_excavate_battle* mutable__query_excavate_battle();
  inline ::up::query_excavate_battle* release__query_excavate_battle();
  inline void set_allocated__query_excavate_battle(::up::query_excavate_battle* _query_excavate_battle);

  // optional .up.set_excavate_team _set_excavate_team = 5;
  inline bool has__set_excavate_team() const;
  inline void clear__set_excavate_team();
  static const int kSetExcavateTeamFieldNumber = 5;
  inline const ::up::set_excavate_team& _set_excavate_team() const;
  inline ::up::set_excavate_team* mutable__set_excavate_team();
  inline ::up::set_excavate_team* release__set_excavate_team();
  inline void set_allocated__set_excavate_team(::up::set_excavate_team* _set_excavate_team);

  // optional .up.excavate_start_battle _excavate_start_battle = 6;
  inline bool has__excavate_start_battle() const;
  inline void clear__excavate_start_battle();
  static const int kExcavateStartBattleFieldNumber = 6;
  inline const ::up::excavate_start_battle& _excavate_start_battle() const;
  inline ::up::excavate_start_battle* mutable__excavate_start_battle();
  inline ::up::excavate_start_battle* release__excavate_start_battle();
  inline void set_allocated__excavate_start_battle(::up::excavate_start_battle* _excavate_start_battle);

  // optional .up.excavate_end_battle _excavate_end_battle = 7;
  inline bool has__excavate_end_battle() const;
  inline void clear__excavate_end_battle();
  static const int kExcavateEndBattleFieldNumber = 7;
  inline const ::up::excavate_end_battle& _excavate_end_battle() const;
  inline ::up::excavate_end_battle* mutable__excavate_end_battle();
  inline ::up::excavate_end_battle* release__excavate_end_battle();
  inline void set_allocated__excavate_end_battle(::up::excavate_end_battle* _excavate_end_battle);

  // optional .up.query_excavate_def _query_excavate_def = 8;
  inline bool has__query_excavate_def() const;
  inline void clear__query_excavate_def();
  static const int kQueryExcavateDefFieldNumber = 8;
  inline const ::up::query_excavate_def& _query_excavate_def() const;
  inline ::up::query_excavate_def* mutable__query_excavate_def();
  inline ::up::query_excavate_def* release__query_excavate_def();
  inline void set_allocated__query_excavate_def(::up::query_excavate_def* _query_excavate_def);

  // optional .up.clear_excavate_battle _clear_excavate_battle = 9;
  inline bool has__clear_excavate_battle() const;
  inline void clear__clear_excavate_battle();
  static const int kClearExcavateBattleFieldNumber = 9;
  inline const ::up::clear_excavate_battle& _clear_excavate_battle() const;
  inline ::up::clear_excavate_battle* mutable__clear_excavate_battle();
  inline ::up::clear_excavate_battle* release__clear_excavate_battle();
  inline void set_allocated__clear_excavate_battle(::up::clear_excavate_battle* _clear_excavate_battle);

  // optional .up.withdraw_excavate_hero _withdraw_excavate_hero = 10;
  inline bool has__withdraw_excavate_hero() const;
  inline void clear__withdraw_excavate_hero();
  static const int kWithdrawExcavateHeroFieldNumber = 10;
  inline const ::up::withdraw_excavate_hero& _withdraw_excavate_hero() const;
  inline ::up::withdraw_excavate_hero* mutable__withdraw_excavate_hero();
  inline ::up::withdraw_excavate_hero* release__withdraw_excavate_hero();
  inline void set_allocated__withdraw_excavate_hero(::up::withdraw_excavate_hero* _withdraw_excavate_hero);

  // optional .up.draw_excavate_def_rwd _draw_excavate_def_rwd = 11;
  inline bool has__draw_excavate_def_rwd() const;
  inline void clear__draw_excavate_def_rwd();
  static const int kDrawExcavateDefRwdFieldNumber = 11;
  inline const ::up::draw_excavate_def_rwd& _draw_excavate_def_rwd() const;
  inline ::up::draw_excavate_def_rwd* mutable__draw_excavate_def_rwd();
  inline ::up::draw_excavate_def_rwd* release__draw_excavate_def_rwd();
  inline void set_allocated__draw_excavate_def_rwd(::up::draw_excavate_def_rwd* _draw_excavate_def_rwd);

  // optional .up.drop_excavate _drop_excavate = 12;
  inline bool has__drop_excavate() const;
  inline void clear__drop_excavate();
  static const int kDropExcavateFieldNumber = 12;
  inline const ::up::drop_excavate& _drop_excavate() const;
  inline ::up::drop_excavate* mutable__drop_excavate();
  inline ::up::drop_excavate* release__drop_excavate();
  inline void set_allocated__drop_excavate(::up::drop_excavate* _drop_excavate);

  // optional .up.query_replay _query_replay = 13;
  inline bool has__query_replay() const;
  inline void clear__query_replay();
  static const int kQueryReplayFieldNumber = 13;
  inline const ::up::query_replay& _query_replay() const;
  inline ::up::query_replay* mutable__query_replay();
  inline ::up::query_replay* release__query_replay();
  inline void set_allocated__query_replay(::up::query_replay* _query_replay);

  // @@protoc_insertion_point(class_scope:up.excavate)
 private:
  inline void set_has__search_excavate();
  inline void clear_has__search_excavate();
  inline void set_has__query_excavate_data();
  inline void clear_has__query_excavate_data();
  inline void set_has__query_excavate_history();
  inline void clear_has__query_excavate_history();
  inline void set_has__query_excavate_battle();
  inline void clear_has__query_excavate_battle();
  inline void set_has__set_excavate_team();
  inline void clear_has__set_excavate_team();
  inline void set_has__excavate_start_battle();
  inline void clear_has__excavate_start_battle();
  inline void set_has__excavate_end_battle();
  inline void clear_has__excavate_end_battle();
  inline void set_has__query_excavate_def();
  inline void clear_has__query_excavate_def();
  inline void set_has__clear_excavate_battle();
  inline void clear_has__clear_excavate_battle();
  inline void set_has__withdraw_excavate_hero();
  inline void clear_has__withdraw_excavate_hero();
  inline void set_has__draw_excavate_def_rwd();
  inline void clear_has__draw_excavate_def_rwd();
  inline void set_has__drop_excavate();
  inline void clear_has__drop_excavate();
  inline void set_has__query_replay();
  inline void clear_has__query_replay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::up::search_excavate* _search_excavate_;
  ::up::query_excavate_data* _query_excavate_data_;
  ::up::query_excavate_history* _query_excavate_history_;
  ::up::query_excavate_battle* _query_excavate_battle_;
  ::up::set_excavate_team* _set_excavate_team_;
  ::up::excavate_start_battle* _excavate_start_battle_;
  ::up::excavate_end_battle* _excavate_end_battle_;
  ::up::query_excavate_def* _query_excavate_def_;
  ::up::clear_excavate_battle* _clear_excavate_battle_;
  ::up::withdraw_excavate_hero* _withdraw_excavate_hero_;
  ::up::draw_excavate_def_rwd* _draw_excavate_def_rwd_;
  ::up::drop_excavate* _drop_excavate_;
  ::up::query_replay* _query_replay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static excavate* default_instance_;
};
// -------------------------------------------------------------------

class search_excavate : public ::google::protobuf::Message {
 public:
  search_excavate();
  virtual ~search_excavate();

  search_excavate(const search_excavate& from);

  inline search_excavate& operator=(const search_excavate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const search_excavate& default_instance();

  void Swap(search_excavate* other);

  // implements Message ----------------------------------------------

  search_excavate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const search_excavate& from);
  void MergeFrom(const search_excavate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.search_excavate)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static search_excavate* default_instance_;
};
// -------------------------------------------------------------------

class query_excavate_data : public ::google::protobuf::Message {
 public:
  query_excavate_data();
  virtual ~query_excavate_data();

  query_excavate_data(const query_excavate_data& from);

  inline query_excavate_data& operator=(const query_excavate_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_excavate_data& default_instance();

  void Swap(query_excavate_data* other);

  // implements Message ----------------------------------------------

  query_excavate_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_excavate_data& from);
  void MergeFrom(const query_excavate_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.query_excavate_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_excavate_data* default_instance_;
};
// -------------------------------------------------------------------

class query_excavate_history : public ::google::protobuf::Message {
 public:
  query_excavate_history();
  virtual ~query_excavate_history();

  query_excavate_history(const query_excavate_history& from);

  inline query_excavate_history& operator=(const query_excavate_history& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_excavate_history& default_instance();

  void Swap(query_excavate_history* other);

  // implements Message ----------------------------------------------

  query_excavate_history* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_excavate_history& from);
  void MergeFrom(const query_excavate_history& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.query_excavate_history)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_excavate_history* default_instance_;
};
// -------------------------------------------------------------------

class query_excavate_battle : public ::google::protobuf::Message {
 public:
  query_excavate_battle();
  virtual ~query_excavate_battle();

  query_excavate_battle(const query_excavate_battle& from);

  inline query_excavate_battle& operator=(const query_excavate_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_excavate_battle& default_instance();

  void Swap(query_excavate_battle* other);

  // implements Message ----------------------------------------------

  query_excavate_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_excavate_battle& from);
  void MergeFrom(const query_excavate_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _id = 1;
  inline bool has__id() const;
  inline void clear__id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& _id() const;
  inline void set__id(const ::std::string& value);
  inline void set__id(const char* value);
  inline void set__id(const char* value, size_t size);
  inline ::std::string* mutable__id();
  inline ::std::string* release__id();
  inline void set_allocated__id(::std::string* _id);

  // @@protoc_insertion_point(class_scope:up.query_excavate_battle)
 private:
  inline void set_has__id();
  inline void clear_has__id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_excavate_battle* default_instance_;
};
// -------------------------------------------------------------------

class set_excavate_team : public ::google::protobuf::Message {
 public:
  set_excavate_team();
  virtual ~set_excavate_team();

  set_excavate_team(const set_excavate_team& from);

  inline set_excavate_team& operator=(const set_excavate_team& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const set_excavate_team& default_instance();

  void Swap(set_excavate_team* other);

  // implements Message ----------------------------------------------

  set_excavate_team* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const set_excavate_team& from);
  void MergeFrom(const set_excavate_team& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _excavate_id = 1;
  inline bool has__excavate_id() const;
  inline void clear__excavate_id();
  static const int kExcavateIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _excavate_id() const;
  inline void set__excavate_id(::google::protobuf::uint32 value);

  // repeated uint32 _tid = 2;
  inline int _tid_size() const;
  inline void clear__tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint32 _tid(int index) const;
  inline void set__tid(int index, ::google::protobuf::uint32 value);
  inline void add__tid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _tid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__tid();

  // @@protoc_insertion_point(class_scope:up.set_excavate_team)
 private:
  inline void set_has__excavate_id();
  inline void clear_has__excavate_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _tid_;
  ::google::protobuf::uint32 _excavate_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static set_excavate_team* default_instance_;
};
// -------------------------------------------------------------------

class excavate_start_battle : public ::google::protobuf::Message {
 public:
  excavate_start_battle();
  virtual ~excavate_start_battle();

  excavate_start_battle(const excavate_start_battle& from);

  inline excavate_start_battle& operator=(const excavate_start_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const excavate_start_battle& default_instance();

  void Swap(excavate_start_battle* other);

  // implements Message ----------------------------------------------

  excavate_start_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const excavate_start_battle& from);
  void MergeFrom(const excavate_start_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 _heroids = 1;
  inline int _heroids_size() const;
  inline void clear__heroids();
  static const int kHeroidsFieldNumber = 1;
  inline ::google::protobuf::uint32 _heroids(int index) const;
  inline void set__heroids(int index, ::google::protobuf::uint32 value);
  inline void add__heroids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _heroids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__heroids();

  // required uint32 _excavate_id = 2;
  inline bool has__excavate_id() const;
  inline void clear__excavate_id();
  static const int kExcavateIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _excavate_id() const;
  inline void set__excavate_id(::google::protobuf::uint32 value);

  // required uint32 _team_id = 3;
  inline bool has__team_id() const;
  inline void clear__team_id();
  static const int kTeamIdFieldNumber = 3;
  inline ::google::protobuf::uint32 _team_id() const;
  inline void set__team_id(::google::protobuf::uint32 value);

  // optional uint32 _team_svr_id = 4;
  inline bool has__team_svr_id() const;
  inline void clear__team_svr_id();
  static const int kTeamSvrIdFieldNumber = 4;
  inline ::google::protobuf::uint32 _team_svr_id() const;
  inline void set__team_svr_id(::google::protobuf::uint32 value);

  // optional uint32 _use_hire = 5;
  inline bool has__use_hire() const;
  inline void clear__use_hire();
  static const int kUseHireFieldNumber = 5;
  inline ::google::protobuf::uint32 _use_hire() const;
  inline void set__use_hire(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.excavate_start_battle)
 private:
  inline void set_has__excavate_id();
  inline void clear_has__excavate_id();
  inline void set_has__team_id();
  inline void clear_has__team_id();
  inline void set_has__team_svr_id();
  inline void clear_has__team_svr_id();
  inline void set_has__use_hire();
  inline void clear_has__use_hire();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _heroids_;
  ::google::protobuf::uint32 _excavate_id_;
  ::google::protobuf::uint32 _team_id_;
  ::google::protobuf::uint32 _team_svr_id_;
  ::google::protobuf::uint32 _use_hire_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static excavate_start_battle* default_instance_;
};
// -------------------------------------------------------------------

class excavate_end_battle : public ::google::protobuf::Message {
 public:
  excavate_end_battle();
  virtual ~excavate_end_battle();

  excavate_end_battle(const excavate_end_battle& from);

  inline excavate_end_battle& operator=(const excavate_end_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const excavate_end_battle& default_instance();

  void Swap(excavate_end_battle* other);

  // implements Message ----------------------------------------------

  excavate_end_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const excavate_end_battle& from);
  void MergeFrom(const excavate_end_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.battle_result _result = 1 [default = victory];
  inline bool has__result() const;
  inline void clear__result();
  static const int kResultFieldNumber = 1;
  inline ::up::battle_result _result() const;
  inline void set__result(::up::battle_result value);

  // repeated .up.excavate_hero _self_heroes = 2;
  inline int _self_heroes_size() const;
  inline void clear__self_heroes();
  static const int kSelfHeroesFieldNumber = 2;
  inline const ::up::excavate_hero& _self_heroes(int index) const;
  inline ::up::excavate_hero* mutable__self_heroes(int index);
  inline ::up::excavate_hero* add__self_heroes();
  inline const ::google::protobuf::RepeatedPtrField< ::up::excavate_hero >&
      _self_heroes() const;
  inline ::google::protobuf::RepeatedPtrField< ::up::excavate_hero >*
      mutable__self_heroes();

  // repeated .up.excavate_hero _oppo_heroes = 3;
  inline int _oppo_heroes_size() const;
  inline void clear__oppo_heroes();
  static const int kOppoHeroesFieldNumber = 3;
  inline const ::up::excavate_hero& _oppo_heroes(int index) const;
  inline ::up::excavate_hero* mutable__oppo_heroes(int index);
  inline ::up::excavate_hero* add__oppo_heroes();
  inline const ::google::protobuf::RepeatedPtrField< ::up::excavate_hero >&
      _oppo_heroes() const;
  inline ::google::protobuf::RepeatedPtrField< ::up::excavate_hero >*
      mutable__oppo_heroes();

  // repeated uint32 _oprations = 4;
  inline int _oprations_size() const;
  inline void clear__oprations();
  static const int kOprationsFieldNumber = 4;
  inline ::google::protobuf::uint32 _oprations(int index) const;
  inline void set__oprations(int index, ::google::protobuf::uint32 value);
  inline void add__oprations(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _oprations() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__oprations();

  // required uint32 _type_id = 5;
  inline bool has__type_id() const;
  inline void clear__type_id();
  static const int kTypeIdFieldNumber = 5;
  inline ::google::protobuf::uint32 _type_id() const;
  inline void set__type_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.excavate_end_battle)
 private:
  inline void set_has__result();
  inline void clear_has__result();
  inline void set_has__type_id();
  inline void clear_has__type_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::up::excavate_hero > _self_heroes_;
  ::google::protobuf::RepeatedPtrField< ::up::excavate_hero > _oppo_heroes_;
  int _result_;
  ::google::protobuf::uint32 _type_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _oprations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static excavate_end_battle* default_instance_;
};
// -------------------------------------------------------------------

class query_excavate_def : public ::google::protobuf::Message {
 public:
  query_excavate_def();
  virtual ~query_excavate_def();

  query_excavate_def(const query_excavate_def& from);

  inline query_excavate_def& operator=(const query_excavate_def& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_excavate_def& default_instance();

  void Swap(query_excavate_def* other);

  // implements Message ----------------------------------------------

  query_excavate_def* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_excavate_def& from);
  void MergeFrom(const query_excavate_def& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _mine_id = 1;
  inline bool has__mine_id() const;
  inline void clear__mine_id();
  static const int kMineIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _mine_id() const;
  inline void set__mine_id(::google::protobuf::uint32 value);

  // required uint32 _applier_uid = 2;
  inline bool has__applier_uid() const;
  inline void clear__applier_uid();
  static const int kApplierUidFieldNumber = 2;
  inline ::google::protobuf::uint32 _applier_uid() const;
  inline void set__applier_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.query_excavate_def)
 private:
  inline void set_has__mine_id();
  inline void clear_has__mine_id();
  inline void set_has__applier_uid();
  inline void clear_has__applier_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _mine_id_;
  ::google::protobuf::uint32 _applier_uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_excavate_def* default_instance_;
};
// -------------------------------------------------------------------

class clear_excavate_battle : public ::google::protobuf::Message {
 public:
  clear_excavate_battle();
  virtual ~clear_excavate_battle();

  clear_excavate_battle(const clear_excavate_battle& from);

  inline clear_excavate_battle& operator=(const clear_excavate_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const clear_excavate_battle& default_instance();

  void Swap(clear_excavate_battle* other);

  // implements Message ----------------------------------------------

  clear_excavate_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const clear_excavate_battle& from);
  void MergeFrom(const clear_excavate_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.clear_excavate_battle)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static clear_excavate_battle* default_instance_;
};
// -------------------------------------------------------------------

class withdraw_excavate_hero : public ::google::protobuf::Message {
 public:
  withdraw_excavate_hero();
  virtual ~withdraw_excavate_hero();

  withdraw_excavate_hero(const withdraw_excavate_hero& from);

  inline withdraw_excavate_hero& operator=(const withdraw_excavate_hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const withdraw_excavate_hero& default_instance();

  void Swap(withdraw_excavate_hero* other);

  // implements Message ----------------------------------------------

  withdraw_excavate_hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const withdraw_excavate_hero& from);
  void MergeFrom(const withdraw_excavate_hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _hero_id = 1;
  inline bool has__hero_id() const;
  inline void clear__hero_id();
  static const int kHeroIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _hero_id() const;
  inline void set__hero_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.withdraw_excavate_hero)
 private:
  inline void set_has__hero_id();
  inline void clear_has__hero_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _hero_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static withdraw_excavate_hero* default_instance_;
};
// -------------------------------------------------------------------

class draw_excavate_def_rwd : public ::google::protobuf::Message {
 public:
  draw_excavate_def_rwd();
  virtual ~draw_excavate_def_rwd();

  draw_excavate_def_rwd(const draw_excavate_def_rwd& from);

  inline draw_excavate_def_rwd& operator=(const draw_excavate_def_rwd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const draw_excavate_def_rwd& default_instance();

  void Swap(draw_excavate_def_rwd* other);

  // implements Message ----------------------------------------------

  draw_excavate_def_rwd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const draw_excavate_def_rwd& from);
  void MergeFrom(const draw_excavate_def_rwd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string _id = 1;
  inline bool has__id() const;
  inline void clear__id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& _id() const;
  inline void set__id(const ::std::string& value);
  inline void set__id(const char* value);
  inline void set__id(const char* value, size_t size);
  inline ::std::string* mutable__id();
  inline ::std::string* release__id();
  inline void set_allocated__id(::std::string* _id);

  // @@protoc_insertion_point(class_scope:up.draw_excavate_def_rwd)
 private:
  inline void set_has__id();
  inline void clear_has__id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static draw_excavate_def_rwd* default_instance_;
};
// -------------------------------------------------------------------

class drop_excavate : public ::google::protobuf::Message {
 public:
  drop_excavate();
  virtual ~drop_excavate();

  drop_excavate(const drop_excavate& from);

  inline drop_excavate& operator=(const drop_excavate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const drop_excavate& default_instance();

  void Swap(drop_excavate* other);

  // implements Message ----------------------------------------------

  drop_excavate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const drop_excavate& from);
  void MergeFrom(const drop_excavate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _mine_id = 1;
  inline bool has__mine_id() const;
  inline void clear__mine_id();
  static const int kMineIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _mine_id() const;
  inline void set__mine_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.drop_excavate)
 private:
  inline void set_has__mine_id();
  inline void clear_has__mine_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _mine_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static drop_excavate* default_instance_;
};
// -------------------------------------------------------------------

class excavate_hero : public ::google::protobuf::Message {
 public:
  excavate_hero();
  virtual ~excavate_hero();

  excavate_hero(const excavate_hero& from);

  inline excavate_hero& operator=(const excavate_hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const excavate_hero& default_instance();

  void Swap(excavate_hero* other);

  // implements Message ----------------------------------------------

  excavate_hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const excavate_hero& from);
  void MergeFrom(const excavate_hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _heroid = 1;
  inline bool has__heroid() const;
  inline void clear__heroid();
  static const int kHeroidFieldNumber = 1;
  inline ::google::protobuf::uint32 _heroid() const;
  inline void set__heroid(::google::protobuf::uint32 value);

  // required uint32 _hp_perc = 2;
  inline bool has__hp_perc() const;
  inline void clear__hp_perc();
  static const int kHpPercFieldNumber = 2;
  inline ::google::protobuf::uint32 _hp_perc() const;
  inline void set__hp_perc(::google::protobuf::uint32 value);

  // required uint32 _mp_perc = 3;
  inline bool has__mp_perc() const;
  inline void clear__mp_perc();
  static const int kMpPercFieldNumber = 3;
  inline ::google::protobuf::uint32 _mp_perc() const;
  inline void set__mp_perc(::google::protobuf::uint32 value);

  // optional uint32 _custom_data = 4;
  inline bool has__custom_data() const;
  inline void clear__custom_data();
  static const int kCustomDataFieldNumber = 4;
  inline ::google::protobuf::uint32 _custom_data() const;
  inline void set__custom_data(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.excavate_hero)
 private:
  inline void set_has__heroid();
  inline void clear_has__heroid();
  inline void set_has__hp_perc();
  inline void clear_has__hp_perc();
  inline void set_has__mp_perc();
  inline void clear_has__mp_perc();
  inline void set_has__custom_data();
  inline void clear_has__custom_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _heroid_;
  ::google::protobuf::uint32 _hp_perc_;
  ::google::protobuf::uint32 _mp_perc_;
  ::google::protobuf::uint32 _custom_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static excavate_hero* default_instance_;
};
// -------------------------------------------------------------------

class query_split_data : public ::google::protobuf::Message {
 public:
  query_split_data();
  virtual ~query_split_data();

  query_split_data(const query_split_data& from);

  inline query_split_data& operator=(const query_split_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_split_data& default_instance();

  void Swap(query_split_data* other);

  // implements Message ----------------------------------------------

  query_split_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_split_data& from);
  void MergeFrom(const query_split_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.query_split_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_split_data* default_instance_;
};
// -------------------------------------------------------------------

class query_split_return : public ::google::protobuf::Message {
 public:
  query_split_return();
  virtual ~query_split_return();

  query_split_return(const query_split_return& from);

  inline query_split_return& operator=(const query_split_return& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_split_return& default_instance();

  void Swap(query_split_return* other);

  // implements Message ----------------------------------------------

  query_split_return* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_split_return& from);
  void MergeFrom(const query_split_return& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _tid = 1;
  inline bool has__tid() const;
  inline void clear__tid();
  static const int kTidFieldNumber = 1;
  inline ::google::protobuf::uint32 _tid() const;
  inline void set__tid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.query_split_return)
 private:
  inline void set_has__tid();
  inline void clear_has__tid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _tid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_split_return* default_instance_;
};
// -------------------------------------------------------------------

class split_hero : public ::google::protobuf::Message {
 public:
  split_hero();
  virtual ~split_hero();

  split_hero(const split_hero& from);

  inline split_hero& operator=(const split_hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const split_hero& default_instance();

  void Swap(split_hero* other);

  // implements Message ----------------------------------------------

  split_hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const split_hero& from);
  void MergeFrom(const split_hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _tid = 1;
  inline bool has__tid() const;
  inline void clear__tid();
  static const int kTidFieldNumber = 1;
  inline ::google::protobuf::uint32 _tid() const;
  inline void set__tid(::google::protobuf::uint32 value);

  // optional uint32 _stone_id = 2;
  inline bool has__stone_id() const;
  inline void clear__stone_id();
  static const int kStoneIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _stone_id() const;
  inline void set__stone_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.split_hero)
 private:
  inline void set_has__tid();
  inline void clear_has__tid();
  inline void set_has__stone_id();
  inline void clear_has__stone_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _tid_;
  ::google::protobuf::uint32 _stone_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static split_hero* default_instance_;
};
// -------------------------------------------------------------------

class worldcup : public ::google::protobuf::Message {
 public:
  worldcup();
  virtual ~worldcup();

  worldcup(const worldcup& from);

  inline worldcup& operator=(const worldcup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const worldcup& default_instance();

  void Swap(worldcup* other);

  // implements Message ----------------------------------------------

  worldcup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const worldcup& from);
  void MergeFrom(const worldcup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .up.worldcup_query _worldcup_query = 1;
  inline bool has__worldcup_query() const;
  inline void clear__worldcup_query();
  static const int kWorldcupQueryFieldNumber = 1;
  inline const ::up::worldcup_query& _worldcup_query() const;
  inline ::up::worldcup_query* mutable__worldcup_query();
  inline ::up::worldcup_query* release__worldcup_query();
  inline void set_allocated__worldcup_query(::up::worldcup_query* _worldcup_query);

  // optional .up.worldcup_submit _worldcup_submit = 2;
  inline bool has__worldcup_submit() const;
  inline void clear__worldcup_submit();
  static const int kWorldcupSubmitFieldNumber = 2;
  inline const ::up::worldcup_submit& _worldcup_submit() const;
  inline ::up::worldcup_submit* mutable__worldcup_submit();
  inline ::up::worldcup_submit* release__worldcup_submit();
  inline void set_allocated__worldcup_submit(::up::worldcup_submit* _worldcup_submit);

  // @@protoc_insertion_point(class_scope:up.worldcup)
 private:
  inline void set_has__worldcup_query();
  inline void clear_has__worldcup_query();
  inline void set_has__worldcup_submit();
  inline void clear_has__worldcup_submit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::up::worldcup_query* _worldcup_query_;
  ::up::worldcup_submit* _worldcup_submit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static worldcup* default_instance_;
};
// -------------------------------------------------------------------

class worldcup_query : public ::google::protobuf::Message {
 public:
  worldcup_query();
  virtual ~worldcup_query();

  worldcup_query(const worldcup_query& from);

  inline worldcup_query& operator=(const worldcup_query& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const worldcup_query& default_instance();

  void Swap(worldcup_query* other);

  // implements Message ----------------------------------------------

  worldcup_query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const worldcup_query& from);
  void MergeFrom(const worldcup_query& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.worldcup_query)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static worldcup_query* default_instance_;
};
// -------------------------------------------------------------------

class worldcup_submit : public ::google::protobuf::Message {
 public:
  worldcup_submit();
  virtual ~worldcup_submit();

  worldcup_submit(const worldcup_submit& from);

  inline worldcup_submit& operator=(const worldcup_submit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const worldcup_submit& default_instance();

  void Swap(worldcup_submit* other);

  // implements Message ----------------------------------------------

  worldcup_submit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const worldcup_submit& from);
  void MergeFrom(const worldcup_submit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _guess1 = 1;
  inline bool has__guess1() const;
  inline void clear__guess1();
  static const int kGuess1FieldNumber = 1;
  inline ::google::protobuf::uint32 _guess1() const;
  inline void set__guess1(::google::protobuf::uint32 value);

  // optional uint32 _guess2 = 2;
  inline bool has__guess2() const;
  inline void clear__guess2();
  static const int kGuess2FieldNumber = 2;
  inline ::google::protobuf::uint32 _guess2() const;
  inline void set__guess2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.worldcup_submit)
 private:
  inline void set_has__guess1();
  inline void clear_has__guess1();
  inline void set_has__guess2();
  inline void clear_has__guess2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _guess1_;
  ::google::protobuf::uint32 _guess2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static worldcup_submit* default_instance_;
};
// -------------------------------------------------------------------

class report_battle : public ::google::protobuf::Message {
 public:
  report_battle();
  virtual ~report_battle();

  report_battle(const report_battle& from);

  inline report_battle& operator=(const report_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const report_battle& default_instance();

  void Swap(report_battle* other);

  // implements Message ----------------------------------------------

  report_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const report_battle& from);
  void MergeFrom(const report_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _id = 1;
  inline bool has__id() const;
  inline void clear__id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _id() const;
  inline void set__id(::google::protobuf::uint32 value);

  // required bytes _data = 2;
  inline bool has__data() const;
  inline void clear__data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& _data() const;
  inline void set__data(const ::std::string& value);
  inline void set__data(const char* value);
  inline void set__data(const void* value, size_t size);
  inline ::std::string* mutable__data();
  inline ::std::string* release__data();
  inline void set_allocated__data(::std::string* _data);

  // @@protoc_insertion_point(class_scope:up.report_battle)
 private:
  inline void set_has__id();
  inline void clear_has__id();
  inline void set_has__data();
  inline void clear_has__data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* _data_;
  ::google::protobuf::uint32 _id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static report_battle* default_instance_;
};
// -------------------------------------------------------------------

class query_ranklist : public ::google::protobuf::Message {
 public:
  query_ranklist();
  virtual ~query_ranklist();

  query_ranklist(const query_ranklist& from);

  inline query_ranklist& operator=(const query_ranklist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_ranklist& default_instance();

  void Swap(query_ranklist* other);

  // implements Message ----------------------------------------------

  query_ranklist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_ranklist& from);
  void MergeFrom(const query_ranklist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef query_ranklist_rank_type rank_type;
  static const rank_type guildliveness = query_ranklist_rank_type_guildliveness;
  static const rank_type excavate_rob = query_ranklist_rank_type_excavate_rob;
  static const rank_type excavate_gold = query_ranklist_rank_type_excavate_gold;
  static const rank_type excavate_exp = query_ranklist_rank_type_excavate_exp;
  static const rank_type top_gs = query_ranklist_rank_type_top_gs;
  static const rank_type full_hero_gs = query_ranklist_rank_type_full_hero_gs;
  static const rank_type hero_team_gs = query_ranklist_rank_type_hero_team_gs;
  static const rank_type hero_evo_star = query_ranklist_rank_type_hero_evo_star;
  static const rank_type hero_arousal = query_ranklist_rank_type_hero_arousal;
  static const rank_type top_arena = query_ranklist_rank_type_top_arena;
  static inline bool rank_type_IsValid(int value) {
    return query_ranklist_rank_type_IsValid(value);
  }
  static const rank_type rank_type_MIN =
    query_ranklist_rank_type_rank_type_MIN;
  static const rank_type rank_type_MAX =
    query_ranklist_rank_type_rank_type_MAX;
  static const int rank_type_ARRAYSIZE =
    query_ranklist_rank_type_rank_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  rank_type_descriptor() {
    return query_ranklist_rank_type_descriptor();
  }
  static inline const ::std::string& rank_type_Name(rank_type value) {
    return query_ranklist_rank_type_Name(value);
  }
  static inline bool rank_type_Parse(const ::std::string& name,
      rank_type* value) {
    return query_ranklist_rank_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .up.query_ranklist.rank_type _rank_type = 1;
  inline bool has__rank_type() const;
  inline void clear__rank_type();
  static const int kRankTypeFieldNumber = 1;
  inline ::up::query_ranklist_rank_type _rank_type() const;
  inline void set__rank_type(::up::query_ranklist_rank_type value);

  // @@protoc_insertion_point(class_scope:up.query_ranklist)
 private:
  inline void set_has__rank_type();
  inline void clear_has__rank_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _rank_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_ranklist* default_instance_;
};
// -------------------------------------------------------------------

class dot_info : public ::google::protobuf::Message {
 public:
  dot_info();
  virtual ~dot_info();

  dot_info(const dot_info& from);

  inline dot_info& operator=(const dot_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dot_info& default_instance();

  void Swap(dot_info* other);

  // implements Message ----------------------------------------------

  dot_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dot_info& from);
  void MergeFrom(const dot_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _dot_id = 1;
  inline bool has__dot_id() const;
  inline void clear__dot_id();
  static const int kDotIdFieldNumber = 1;
  inline ::google::protobuf::uint32 _dot_id() const;
  inline void set__dot_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.dot_info)
 private:
  inline void set_has__dot_id();
  inline void clear_has__dot_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _dot_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static dot_info* default_instance_;
};
// -------------------------------------------------------------------

class require_arousal : public ::google::protobuf::Message {
 public:
  require_arousal();
  virtual ~require_arousal();

  require_arousal(const require_arousal& from);

  inline require_arousal& operator=(const require_arousal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const require_arousal& default_instance();

  void Swap(require_arousal* other);

  // implements Message ----------------------------------------------

  require_arousal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const require_arousal& from);
  void MergeFrom(const require_arousal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef require_arousal_arousal_type arousal_type;
  static const arousal_type _require_arousal = require_arousal_arousal_type__require_arousal;
  static const arousal_type apply_arousal = require_arousal_arousal_type_apply_arousal;
  static inline bool arousal_type_IsValid(int value) {
    return require_arousal_arousal_type_IsValid(value);
  }
  static const arousal_type arousal_type_MIN =
    require_arousal_arousal_type_arousal_type_MIN;
  static const arousal_type arousal_type_MAX =
    require_arousal_arousal_type_arousal_type_MAX;
  static const int arousal_type_ARRAYSIZE =
    require_arousal_arousal_type_arousal_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  arousal_type_descriptor() {
    return require_arousal_arousal_type_descriptor();
  }
  static inline const ::std::string& arousal_type_Name(arousal_type value) {
    return require_arousal_arousal_type_Name(value);
  }
  static inline bool arousal_type_Parse(const ::std::string& name,
      arousal_type* value) {
    return require_arousal_arousal_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 _hid = 1;
  inline bool has__hid() const;
  inline void clear__hid();
  static const int kHidFieldNumber = 1;
  inline ::google::protobuf::uint32 _hid() const;
  inline void set__hid(::google::protobuf::uint32 value);

  // required .up.require_arousal.arousal_type _arousal_type = 2;
  inline bool has__arousal_type() const;
  inline void clear__arousal_type();
  static const int kArousalTypeFieldNumber = 2;
  inline ::up::require_arousal_arousal_type _arousal_type() const;
  inline void set__arousal_type(::up::require_arousal_arousal_type value);

  // optional uint32 _aid = 3;
  inline bool has__aid() const;
  inline void clear__aid();
  static const int kAidFieldNumber = 3;
  inline ::google::protobuf::uint32 _aid() const;
  inline void set__aid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.require_arousal)
 private:
  inline void set_has__hid();
  inline void clear_has__hid();
  inline void set_has__arousal_type();
  inline void clear_has__arousal_type();
  inline void set_has__aid();
  inline void clear_has__aid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _hid_;
  int _arousal_type_;
  ::google::protobuf::uint32 _aid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static require_arousal* default_instance_;
};
// -------------------------------------------------------------------

class change_server : public ::google::protobuf::Message {
 public:
  change_server();
  virtual ~change_server();

  change_server(const change_server& from);

  inline change_server& operator=(const change_server& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const change_server& default_instance();

  void Swap(change_server* other);

  // implements Message ----------------------------------------------

  change_server* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const change_server& from);
  void MergeFrom(const change_server& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .up.server_opt_type _op_type = 1;
  inline bool has__op_type() const;
  inline void clear__op_type();
  static const int kOpTypeFieldNumber = 1;
  inline ::up::server_opt_type _op_type() const;
  inline void set__op_type(::up::server_opt_type value);

  // optional uint32 _server_id = 2;
  inline bool has__server_id() const;
  inline void clear__server_id();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 _server_id() const;
  inline void set__server_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.change_server)
 private:
  inline void set_has__op_type();
  inline void clear_has__op_type();
  inline void set_has__server_id();
  inline void clear_has__server_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int _op_type_;
  ::google::protobuf::uint32 _server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static change_server* default_instance_;
};
// -------------------------------------------------------------------

class request_guild_log : public ::google::protobuf::Message {
 public:
  request_guild_log();
  virtual ~request_guild_log();

  request_guild_log(const request_guild_log& from);

  inline request_guild_log& operator=(const request_guild_log& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const request_guild_log& default_instance();

  void Swap(request_guild_log* other);

  // implements Message ----------------------------------------------

  request_guild_log* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const request_guild_log& from);
  void MergeFrom(const request_guild_log& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:up.request_guild_log)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static request_guild_log* default_instance_;
};
// -------------------------------------------------------------------

class query_act_stage : public ::google::protobuf::Message {
 public:
  query_act_stage();
  virtual ~query_act_stage();

  query_act_stage(const query_act_stage& from);

  inline query_act_stage& operator=(const query_act_stage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_act_stage& default_instance();

  void Swap(query_act_stage* other);

  // implements Message ----------------------------------------------

  query_act_stage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const query_act_stage& from);
  void MergeFrom(const query_act_stage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 _act_stage_groups = 1;
  inline int _act_stage_groups_size() const;
  inline void clear__act_stage_groups();
  static const int kActStageGroupsFieldNumber = 1;
  inline ::google::protobuf::uint32 _act_stage_groups(int index) const;
  inline void set__act_stage_groups(int index, ::google::protobuf::uint32 value);
  inline void add__act_stage_groups(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      _act_stage_groups() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable__act_stage_groups();

  // @@protoc_insertion_point(class_scope:up.query_act_stage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > _act_stage_groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static query_act_stage* default_instance_;
};
// -------------------------------------------------------------------

class fb_attention : public ::google::protobuf::Message {
 public:
  fb_attention();
  virtual ~fb_attention();

  fb_attention(const fb_attention& from);

  inline fb_attention& operator=(const fb_attention& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fb_attention& default_instance();

  void Swap(fb_attention* other);

  // implements Message ----------------------------------------------

  fb_attention* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fb_attention& from);
  void MergeFrom(const fb_attention& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 _fb_attention = 1;
  inline bool has__fb_attention() const;
  inline void clear__fb_attention();
  static const int kFbAttentionFieldNumber = 1;
  inline ::google::protobuf::uint32 _fb_attention() const;
  inline void set__fb_attention(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:up.fb_attention)
 private:
  inline void set_has__fb_attention();
  inline void clear_has__fb_attention();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _fb_attention_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_up_2eproto();
  friend void protobuf_AssignDesc_up_2eproto();
  friend void protobuf_ShutdownFile_up_2eproto();

  void InitAsDefaultInstance();
  static fb_attention* default_instance_;
};
// ===================================================================


// ===================================================================

// up_msg

// required uint32 _repeat = 1;
inline bool up_msg::has__repeat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void up_msg::set_has__repeat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void up_msg::clear_has__repeat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void up_msg::clear__repeat() {
  _repeat_ = 0u;
  clear_has__repeat();
}
inline ::google::protobuf::uint32 up_msg::_repeat() const {
  return _repeat_;
}
inline void up_msg::set__repeat(::google::protobuf::uint32 value) {
  set_has__repeat();
  _repeat_ = value;
}

// optional uint32 _user_id = 2;
inline bool up_msg::has__user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void up_msg::set_has__user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void up_msg::clear_has__user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void up_msg::clear__user_id() {
  _user_id_ = 0u;
  clear_has__user_id();
}
inline ::google::protobuf::uint32 up_msg::_user_id() const {
  return _user_id_;
}
inline void up_msg::set__user_id(::google::protobuf::uint32 value) {
  set_has__user_id();
  _user_id_ = value;
}

// optional .up.login _login = 3;
inline bool up_msg::has__login() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void up_msg::set_has__login() {
  _has_bits_[0] |= 0x00000004u;
}
inline void up_msg::clear_has__login() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void up_msg::clear__login() {
  if (_login_ != NULL) _login_->::up::login::Clear();
  clear_has__login();
}
inline const ::up::login& up_msg::_login() const {
  return _login_ != NULL ? *_login_ : *default_instance_->_login_;
}
inline ::up::login* up_msg::mutable__login() {
  set_has__login();
  if (_login_ == NULL) _login_ = new ::up::login;
  return _login_;
}
inline ::up::login* up_msg::release__login() {
  clear_has__login();
  ::up::login* temp = _login_;
  _login_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__login(::up::login* _login) {
  delete _login_;
  _login_ = _login;
  if (_login) {
    set_has__login();
  } else {
    clear_has__login();
  }
}

// optional .up.request_userinfo _request_userinfo = 4;
inline bool up_msg::has__request_userinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void up_msg::set_has__request_userinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void up_msg::clear_has__request_userinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void up_msg::clear__request_userinfo() {
  if (_request_userinfo_ != NULL) _request_userinfo_->::up::request_userinfo::Clear();
  clear_has__request_userinfo();
}
inline const ::up::request_userinfo& up_msg::_request_userinfo() const {
  return _request_userinfo_ != NULL ? *_request_userinfo_ : *default_instance_->_request_userinfo_;
}
inline ::up::request_userinfo* up_msg::mutable__request_userinfo() {
  set_has__request_userinfo();
  if (_request_userinfo_ == NULL) _request_userinfo_ = new ::up::request_userinfo;
  return _request_userinfo_;
}
inline ::up::request_userinfo* up_msg::release__request_userinfo() {
  clear_has__request_userinfo();
  ::up::request_userinfo* temp = _request_userinfo_;
  _request_userinfo_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__request_userinfo(::up::request_userinfo* _request_userinfo) {
  delete _request_userinfo_;
  _request_userinfo_ = _request_userinfo;
  if (_request_userinfo) {
    set_has__request_userinfo();
  } else {
    clear_has__request_userinfo();
  }
}

// optional .up.enter_stage _enter_stage = 5;
inline bool up_msg::has__enter_stage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void up_msg::set_has__enter_stage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void up_msg::clear_has__enter_stage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void up_msg::clear__enter_stage() {
  if (_enter_stage_ != NULL) _enter_stage_->::up::enter_stage::Clear();
  clear_has__enter_stage();
}
inline const ::up::enter_stage& up_msg::_enter_stage() const {
  return _enter_stage_ != NULL ? *_enter_stage_ : *default_instance_->_enter_stage_;
}
inline ::up::enter_stage* up_msg::mutable__enter_stage() {
  set_has__enter_stage();
  if (_enter_stage_ == NULL) _enter_stage_ = new ::up::enter_stage;
  return _enter_stage_;
}
inline ::up::enter_stage* up_msg::release__enter_stage() {
  clear_has__enter_stage();
  ::up::enter_stage* temp = _enter_stage_;
  _enter_stage_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__enter_stage(::up::enter_stage* _enter_stage) {
  delete _enter_stage_;
  _enter_stage_ = _enter_stage;
  if (_enter_stage) {
    set_has__enter_stage();
  } else {
    clear_has__enter_stage();
  }
}

// optional .up.exit_stage _exit_stage = 6;
inline bool up_msg::has__exit_stage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void up_msg::set_has__exit_stage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void up_msg::clear_has__exit_stage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void up_msg::clear__exit_stage() {
  if (_exit_stage_ != NULL) _exit_stage_->::up::exit_stage::Clear();
  clear_has__exit_stage();
}
inline const ::up::exit_stage& up_msg::_exit_stage() const {
  return _exit_stage_ != NULL ? *_exit_stage_ : *default_instance_->_exit_stage_;
}
inline ::up::exit_stage* up_msg::mutable__exit_stage() {
  set_has__exit_stage();
  if (_exit_stage_ == NULL) _exit_stage_ = new ::up::exit_stage;
  return _exit_stage_;
}
inline ::up::exit_stage* up_msg::release__exit_stage() {
  clear_has__exit_stage();
  ::up::exit_stage* temp = _exit_stage_;
  _exit_stage_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__exit_stage(::up::exit_stage* _exit_stage) {
  delete _exit_stage_;
  _exit_stage_ = _exit_stage;
  if (_exit_stage) {
    set_has__exit_stage();
  } else {
    clear_has__exit_stage();
  }
}

// optional .up.gm_cmd _gm_cmd = 7;
inline bool up_msg::has__gm_cmd() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void up_msg::set_has__gm_cmd() {
  _has_bits_[0] |= 0x00000040u;
}
inline void up_msg::clear_has__gm_cmd() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void up_msg::clear__gm_cmd() {
  if (_gm_cmd_ != NULL) _gm_cmd_->::up::gm_cmd::Clear();
  clear_has__gm_cmd();
}
inline const ::up::gm_cmd& up_msg::_gm_cmd() const {
  return _gm_cmd_ != NULL ? *_gm_cmd_ : *default_instance_->_gm_cmd_;
}
inline ::up::gm_cmd* up_msg::mutable__gm_cmd() {
  set_has__gm_cmd();
  if (_gm_cmd_ == NULL) _gm_cmd_ = new ::up::gm_cmd;
  return _gm_cmd_;
}
inline ::up::gm_cmd* up_msg::release__gm_cmd() {
  clear_has__gm_cmd();
  ::up::gm_cmd* temp = _gm_cmd_;
  _gm_cmd_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__gm_cmd(::up::gm_cmd* _gm_cmd) {
  delete _gm_cmd_;
  _gm_cmd_ = _gm_cmd;
  if (_gm_cmd) {
    set_has__gm_cmd();
  } else {
    clear_has__gm_cmd();
  }
}

// optional .up.hero_upgrade _hero_upgrade = 8;
inline bool up_msg::has__hero_upgrade() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void up_msg::set_has__hero_upgrade() {
  _has_bits_[0] |= 0x00000080u;
}
inline void up_msg::clear_has__hero_upgrade() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void up_msg::clear__hero_upgrade() {
  if (_hero_upgrade_ != NULL) _hero_upgrade_->::up::hero_upgrade::Clear();
  clear_has__hero_upgrade();
}
inline const ::up::hero_upgrade& up_msg::_hero_upgrade() const {
  return _hero_upgrade_ != NULL ? *_hero_upgrade_ : *default_instance_->_hero_upgrade_;
}
inline ::up::hero_upgrade* up_msg::mutable__hero_upgrade() {
  set_has__hero_upgrade();
  if (_hero_upgrade_ == NULL) _hero_upgrade_ = new ::up::hero_upgrade;
  return _hero_upgrade_;
}
inline ::up::hero_upgrade* up_msg::release__hero_upgrade() {
  clear_has__hero_upgrade();
  ::up::hero_upgrade* temp = _hero_upgrade_;
  _hero_upgrade_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__hero_upgrade(::up::hero_upgrade* _hero_upgrade) {
  delete _hero_upgrade_;
  _hero_upgrade_ = _hero_upgrade;
  if (_hero_upgrade) {
    set_has__hero_upgrade();
  } else {
    clear_has__hero_upgrade();
  }
}

// optional .up.equip_synthesis _equip_synthesis = 9;
inline bool up_msg::has__equip_synthesis() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void up_msg::set_has__equip_synthesis() {
  _has_bits_[0] |= 0x00000100u;
}
inline void up_msg::clear_has__equip_synthesis() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void up_msg::clear__equip_synthesis() {
  if (_equip_synthesis_ != NULL) _equip_synthesis_->::up::equip_synthesis::Clear();
  clear_has__equip_synthesis();
}
inline const ::up::equip_synthesis& up_msg::_equip_synthesis() const {
  return _equip_synthesis_ != NULL ? *_equip_synthesis_ : *default_instance_->_equip_synthesis_;
}
inline ::up::equip_synthesis* up_msg::mutable__equip_synthesis() {
  set_has__equip_synthesis();
  if (_equip_synthesis_ == NULL) _equip_synthesis_ = new ::up::equip_synthesis;
  return _equip_synthesis_;
}
inline ::up::equip_synthesis* up_msg::release__equip_synthesis() {
  clear_has__equip_synthesis();
  ::up::equip_synthesis* temp = _equip_synthesis_;
  _equip_synthesis_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__equip_synthesis(::up::equip_synthesis* _equip_synthesis) {
  delete _equip_synthesis_;
  _equip_synthesis_ = _equip_synthesis;
  if (_equip_synthesis) {
    set_has__equip_synthesis();
  } else {
    clear_has__equip_synthesis();
  }
}

// optional .up.wear_equip _wear_equip = 10;
inline bool up_msg::has__wear_equip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void up_msg::set_has__wear_equip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void up_msg::clear_has__wear_equip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void up_msg::clear__wear_equip() {
  if (_wear_equip_ != NULL) _wear_equip_->::up::wear_equip::Clear();
  clear_has__wear_equip();
}
inline const ::up::wear_equip& up_msg::_wear_equip() const {
  return _wear_equip_ != NULL ? *_wear_equip_ : *default_instance_->_wear_equip_;
}
inline ::up::wear_equip* up_msg::mutable__wear_equip() {
  set_has__wear_equip();
  if (_wear_equip_ == NULL) _wear_equip_ = new ::up::wear_equip;
  return _wear_equip_;
}
inline ::up::wear_equip* up_msg::release__wear_equip() {
  clear_has__wear_equip();
  ::up::wear_equip* temp = _wear_equip_;
  _wear_equip_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__wear_equip(::up::wear_equip* _wear_equip) {
  delete _wear_equip_;
  _wear_equip_ = _wear_equip;
  if (_wear_equip) {
    set_has__wear_equip();
  } else {
    clear_has__wear_equip();
  }
}

// optional .up.consume_item _consume_item = 11;
inline bool up_msg::has__consume_item() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void up_msg::set_has__consume_item() {
  _has_bits_[0] |= 0x00000400u;
}
inline void up_msg::clear_has__consume_item() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void up_msg::clear__consume_item() {
  if (_consume_item_ != NULL) _consume_item_->::up::consume_item::Clear();
  clear_has__consume_item();
}
inline const ::up::consume_item& up_msg::_consume_item() const {
  return _consume_item_ != NULL ? *_consume_item_ : *default_instance_->_consume_item_;
}
inline ::up::consume_item* up_msg::mutable__consume_item() {
  set_has__consume_item();
  if (_consume_item_ == NULL) _consume_item_ = new ::up::consume_item;
  return _consume_item_;
}
inline ::up::consume_item* up_msg::release__consume_item() {
  clear_has__consume_item();
  ::up::consume_item* temp = _consume_item_;
  _consume_item_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__consume_item(::up::consume_item* _consume_item) {
  delete _consume_item_;
  _consume_item_ = _consume_item;
  if (_consume_item) {
    set_has__consume_item();
  } else {
    clear_has__consume_item();
  }
}

// optional .up.shop_refresh _shop_refresh = 12;
inline bool up_msg::has__shop_refresh() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void up_msg::set_has__shop_refresh() {
  _has_bits_[0] |= 0x00000800u;
}
inline void up_msg::clear_has__shop_refresh() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void up_msg::clear__shop_refresh() {
  if (_shop_refresh_ != NULL) _shop_refresh_->::up::shop_refresh::Clear();
  clear_has__shop_refresh();
}
inline const ::up::shop_refresh& up_msg::_shop_refresh() const {
  return _shop_refresh_ != NULL ? *_shop_refresh_ : *default_instance_->_shop_refresh_;
}
inline ::up::shop_refresh* up_msg::mutable__shop_refresh() {
  set_has__shop_refresh();
  if (_shop_refresh_ == NULL) _shop_refresh_ = new ::up::shop_refresh;
  return _shop_refresh_;
}
inline ::up::shop_refresh* up_msg::release__shop_refresh() {
  clear_has__shop_refresh();
  ::up::shop_refresh* temp = _shop_refresh_;
  _shop_refresh_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__shop_refresh(::up::shop_refresh* _shop_refresh) {
  delete _shop_refresh_;
  _shop_refresh_ = _shop_refresh;
  if (_shop_refresh) {
    set_has__shop_refresh();
  } else {
    clear_has__shop_refresh();
  }
}

// optional .up.shop_consume _shop_consume = 13;
inline bool up_msg::has__shop_consume() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void up_msg::set_has__shop_consume() {
  _has_bits_[0] |= 0x00001000u;
}
inline void up_msg::clear_has__shop_consume() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void up_msg::clear__shop_consume() {
  if (_shop_consume_ != NULL) _shop_consume_->::up::shop_consume::Clear();
  clear_has__shop_consume();
}
inline const ::up::shop_consume& up_msg::_shop_consume() const {
  return _shop_consume_ != NULL ? *_shop_consume_ : *default_instance_->_shop_consume_;
}
inline ::up::shop_consume* up_msg::mutable__shop_consume() {
  set_has__shop_consume();
  if (_shop_consume_ == NULL) _shop_consume_ = new ::up::shop_consume;
  return _shop_consume_;
}
inline ::up::shop_consume* up_msg::release__shop_consume() {
  clear_has__shop_consume();
  ::up::shop_consume* temp = _shop_consume_;
  _shop_consume_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__shop_consume(::up::shop_consume* _shop_consume) {
  delete _shop_consume_;
  _shop_consume_ = _shop_consume;
  if (_shop_consume) {
    set_has__shop_consume();
  } else {
    clear_has__shop_consume();
  }
}

// optional .up.skill_levelup _skill_levelup = 14;
inline bool up_msg::has__skill_levelup() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void up_msg::set_has__skill_levelup() {
  _has_bits_[0] |= 0x00002000u;
}
inline void up_msg::clear_has__skill_levelup() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void up_msg::clear__skill_levelup() {
  if (_skill_levelup_ != NULL) _skill_levelup_->::up::skill_levelup::Clear();
  clear_has__skill_levelup();
}
inline const ::up::skill_levelup& up_msg::_skill_levelup() const {
  return _skill_levelup_ != NULL ? *_skill_levelup_ : *default_instance_->_skill_levelup_;
}
inline ::up::skill_levelup* up_msg::mutable__skill_levelup() {
  set_has__skill_levelup();
  if (_skill_levelup_ == NULL) _skill_levelup_ = new ::up::skill_levelup;
  return _skill_levelup_;
}
inline ::up::skill_levelup* up_msg::release__skill_levelup() {
  clear_has__skill_levelup();
  ::up::skill_levelup* temp = _skill_levelup_;
  _skill_levelup_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__skill_levelup(::up::skill_levelup* _skill_levelup) {
  delete _skill_levelup_;
  _skill_levelup_ = _skill_levelup;
  if (_skill_levelup) {
    set_has__skill_levelup();
  } else {
    clear_has__skill_levelup();
  }
}

// optional .up.sell_item _sell_item = 15;
inline bool up_msg::has__sell_item() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void up_msg::set_has__sell_item() {
  _has_bits_[0] |= 0x00004000u;
}
inline void up_msg::clear_has__sell_item() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void up_msg::clear__sell_item() {
  if (_sell_item_ != NULL) _sell_item_->::up::sell_item::Clear();
  clear_has__sell_item();
}
inline const ::up::sell_item& up_msg::_sell_item() const {
  return _sell_item_ != NULL ? *_sell_item_ : *default_instance_->_sell_item_;
}
inline ::up::sell_item* up_msg::mutable__sell_item() {
  set_has__sell_item();
  if (_sell_item_ == NULL) _sell_item_ = new ::up::sell_item;
  return _sell_item_;
}
inline ::up::sell_item* up_msg::release__sell_item() {
  clear_has__sell_item();
  ::up::sell_item* temp = _sell_item_;
  _sell_item_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__sell_item(::up::sell_item* _sell_item) {
  delete _sell_item_;
  _sell_item_ = _sell_item;
  if (_sell_item) {
    set_has__sell_item();
  } else {
    clear_has__sell_item();
  }
}

// optional .up.fragment_compose _fragment_compose = 16;
inline bool up_msg::has__fragment_compose() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void up_msg::set_has__fragment_compose() {
  _has_bits_[0] |= 0x00008000u;
}
inline void up_msg::clear_has__fragment_compose() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void up_msg::clear__fragment_compose() {
  if (_fragment_compose_ != NULL) _fragment_compose_->::up::fragment_compose::Clear();
  clear_has__fragment_compose();
}
inline const ::up::fragment_compose& up_msg::_fragment_compose() const {
  return _fragment_compose_ != NULL ? *_fragment_compose_ : *default_instance_->_fragment_compose_;
}
inline ::up::fragment_compose* up_msg::mutable__fragment_compose() {
  set_has__fragment_compose();
  if (_fragment_compose_ == NULL) _fragment_compose_ = new ::up::fragment_compose;
  return _fragment_compose_;
}
inline ::up::fragment_compose* up_msg::release__fragment_compose() {
  clear_has__fragment_compose();
  ::up::fragment_compose* temp = _fragment_compose_;
  _fragment_compose_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__fragment_compose(::up::fragment_compose* _fragment_compose) {
  delete _fragment_compose_;
  _fragment_compose_ = _fragment_compose;
  if (_fragment_compose) {
    set_has__fragment_compose();
  } else {
    clear_has__fragment_compose();
  }
}

// optional .up.hero_equip_upgrade _hero_equip_upgrade = 17;
inline bool up_msg::has__hero_equip_upgrade() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void up_msg::set_has__hero_equip_upgrade() {
  _has_bits_[0] |= 0x00010000u;
}
inline void up_msg::clear_has__hero_equip_upgrade() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void up_msg::clear__hero_equip_upgrade() {
  if (_hero_equip_upgrade_ != NULL) _hero_equip_upgrade_->::up::hero_equip_upgrade::Clear();
  clear_has__hero_equip_upgrade();
}
inline const ::up::hero_equip_upgrade& up_msg::_hero_equip_upgrade() const {
  return _hero_equip_upgrade_ != NULL ? *_hero_equip_upgrade_ : *default_instance_->_hero_equip_upgrade_;
}
inline ::up::hero_equip_upgrade* up_msg::mutable__hero_equip_upgrade() {
  set_has__hero_equip_upgrade();
  if (_hero_equip_upgrade_ == NULL) _hero_equip_upgrade_ = new ::up::hero_equip_upgrade;
  return _hero_equip_upgrade_;
}
inline ::up::hero_equip_upgrade* up_msg::release__hero_equip_upgrade() {
  clear_has__hero_equip_upgrade();
  ::up::hero_equip_upgrade* temp = _hero_equip_upgrade_;
  _hero_equip_upgrade_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__hero_equip_upgrade(::up::hero_equip_upgrade* _hero_equip_upgrade) {
  delete _hero_equip_upgrade_;
  _hero_equip_upgrade_ = _hero_equip_upgrade;
  if (_hero_equip_upgrade) {
    set_has__hero_equip_upgrade();
  } else {
    clear_has__hero_equip_upgrade();
  }
}

// optional .up.trigger_task _trigger_task = 18;
inline bool up_msg::has__trigger_task() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void up_msg::set_has__trigger_task() {
  _has_bits_[0] |= 0x00020000u;
}
inline void up_msg::clear_has__trigger_task() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void up_msg::clear__trigger_task() {
  if (_trigger_task_ != NULL) _trigger_task_->::up::trigger_task::Clear();
  clear_has__trigger_task();
}
inline const ::up::trigger_task& up_msg::_trigger_task() const {
  return _trigger_task_ != NULL ? *_trigger_task_ : *default_instance_->_trigger_task_;
}
inline ::up::trigger_task* up_msg::mutable__trigger_task() {
  set_has__trigger_task();
  if (_trigger_task_ == NULL) _trigger_task_ = new ::up::trigger_task;
  return _trigger_task_;
}
inline ::up::trigger_task* up_msg::release__trigger_task() {
  clear_has__trigger_task();
  ::up::trigger_task* temp = _trigger_task_;
  _trigger_task_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__trigger_task(::up::trigger_task* _trigger_task) {
  delete _trigger_task_;
  _trigger_task_ = _trigger_task;
  if (_trigger_task) {
    set_has__trigger_task();
  } else {
    clear_has__trigger_task();
  }
}

// optional .up.require_rewards _require_rewards = 19;
inline bool up_msg::has__require_rewards() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void up_msg::set_has__require_rewards() {
  _has_bits_[0] |= 0x00040000u;
}
inline void up_msg::clear_has__require_rewards() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void up_msg::clear__require_rewards() {
  if (_require_rewards_ != NULL) _require_rewards_->::up::require_rewards::Clear();
  clear_has__require_rewards();
}
inline const ::up::require_rewards& up_msg::_require_rewards() const {
  return _require_rewards_ != NULL ? *_require_rewards_ : *default_instance_->_require_rewards_;
}
inline ::up::require_rewards* up_msg::mutable__require_rewards() {
  set_has__require_rewards();
  if (_require_rewards_ == NULL) _require_rewards_ = new ::up::require_rewards;
  return _require_rewards_;
}
inline ::up::require_rewards* up_msg::release__require_rewards() {
  clear_has__require_rewards();
  ::up::require_rewards* temp = _require_rewards_;
  _require_rewards_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__require_rewards(::up::require_rewards* _require_rewards) {
  delete _require_rewards_;
  _require_rewards_ = _require_rewards;
  if (_require_rewards) {
    set_has__require_rewards();
  } else {
    clear_has__require_rewards();
  }
}

// optional .up.trigger_job _trigger_job = 20;
inline bool up_msg::has__trigger_job() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void up_msg::set_has__trigger_job() {
  _has_bits_[0] |= 0x00080000u;
}
inline void up_msg::clear_has__trigger_job() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void up_msg::clear__trigger_job() {
  if (_trigger_job_ != NULL) _trigger_job_->::up::trigger_job::Clear();
  clear_has__trigger_job();
}
inline const ::up::trigger_job& up_msg::_trigger_job() const {
  return _trigger_job_ != NULL ? *_trigger_job_ : *default_instance_->_trigger_job_;
}
inline ::up::trigger_job* up_msg::mutable__trigger_job() {
  set_has__trigger_job();
  if (_trigger_job_ == NULL) _trigger_job_ = new ::up::trigger_job;
  return _trigger_job_;
}
inline ::up::trigger_job* up_msg::release__trigger_job() {
  clear_has__trigger_job();
  ::up::trigger_job* temp = _trigger_job_;
  _trigger_job_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__trigger_job(::up::trigger_job* _trigger_job) {
  delete _trigger_job_;
  _trigger_job_ = _trigger_job;
  if (_trigger_job) {
    set_has__trigger_job();
  } else {
    clear_has__trigger_job();
  }
}

// optional .up.job_rewards _job_rewards = 21;
inline bool up_msg::has__job_rewards() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void up_msg::set_has__job_rewards() {
  _has_bits_[0] |= 0x00100000u;
}
inline void up_msg::clear_has__job_rewards() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void up_msg::clear__job_rewards() {
  if (_job_rewards_ != NULL) _job_rewards_->::up::job_rewards::Clear();
  clear_has__job_rewards();
}
inline const ::up::job_rewards& up_msg::_job_rewards() const {
  return _job_rewards_ != NULL ? *_job_rewards_ : *default_instance_->_job_rewards_;
}
inline ::up::job_rewards* up_msg::mutable__job_rewards() {
  set_has__job_rewards();
  if (_job_rewards_ == NULL) _job_rewards_ = new ::up::job_rewards;
  return _job_rewards_;
}
inline ::up::job_rewards* up_msg::release__job_rewards() {
  clear_has__job_rewards();
  ::up::job_rewards* temp = _job_rewards_;
  _job_rewards_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__job_rewards(::up::job_rewards* _job_rewards) {
  delete _job_rewards_;
  _job_rewards_ = _job_rewards;
  if (_job_rewards) {
    set_has__job_rewards();
  } else {
    clear_has__job_rewards();
  }
}

// optional .up.reset_elite _reset_elite = 22;
inline bool up_msg::has__reset_elite() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void up_msg::set_has__reset_elite() {
  _has_bits_[0] |= 0x00200000u;
}
inline void up_msg::clear_has__reset_elite() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void up_msg::clear__reset_elite() {
  if (_reset_elite_ != NULL) _reset_elite_->::up::reset_elite::Clear();
  clear_has__reset_elite();
}
inline const ::up::reset_elite& up_msg::_reset_elite() const {
  return _reset_elite_ != NULL ? *_reset_elite_ : *default_instance_->_reset_elite_;
}
inline ::up::reset_elite* up_msg::mutable__reset_elite() {
  set_has__reset_elite();
  if (_reset_elite_ == NULL) _reset_elite_ = new ::up::reset_elite;
  return _reset_elite_;
}
inline ::up::reset_elite* up_msg::release__reset_elite() {
  clear_has__reset_elite();
  ::up::reset_elite* temp = _reset_elite_;
  _reset_elite_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__reset_elite(::up::reset_elite* _reset_elite) {
  delete _reset_elite_;
  _reset_elite_ = _reset_elite;
  if (_reset_elite) {
    set_has__reset_elite();
  } else {
    clear_has__reset_elite();
  }
}

// optional .up.sweep_stage _sweep_stage = 23;
inline bool up_msg::has__sweep_stage() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void up_msg::set_has__sweep_stage() {
  _has_bits_[0] |= 0x00400000u;
}
inline void up_msg::clear_has__sweep_stage() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void up_msg::clear__sweep_stage() {
  if (_sweep_stage_ != NULL) _sweep_stage_->::up::sweep_stage::Clear();
  clear_has__sweep_stage();
}
inline const ::up::sweep_stage& up_msg::_sweep_stage() const {
  return _sweep_stage_ != NULL ? *_sweep_stage_ : *default_instance_->_sweep_stage_;
}
inline ::up::sweep_stage* up_msg::mutable__sweep_stage() {
  set_has__sweep_stage();
  if (_sweep_stage_ == NULL) _sweep_stage_ = new ::up::sweep_stage;
  return _sweep_stage_;
}
inline ::up::sweep_stage* up_msg::release__sweep_stage() {
  clear_has__sweep_stage();
  ::up::sweep_stage* temp = _sweep_stage_;
  _sweep_stage_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__sweep_stage(::up::sweep_stage* _sweep_stage) {
  delete _sweep_stage_;
  _sweep_stage_ = _sweep_stage;
  if (_sweep_stage) {
    set_has__sweep_stage();
  } else {
    clear_has__sweep_stage();
  }
}

// optional .up.buy_vitality _buy_vitality = 24;
inline bool up_msg::has__buy_vitality() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void up_msg::set_has__buy_vitality() {
  _has_bits_[0] |= 0x00800000u;
}
inline void up_msg::clear_has__buy_vitality() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void up_msg::clear__buy_vitality() {
  if (_buy_vitality_ != NULL) _buy_vitality_->::up::buy_vitality::Clear();
  clear_has__buy_vitality();
}
inline const ::up::buy_vitality& up_msg::_buy_vitality() const {
  return _buy_vitality_ != NULL ? *_buy_vitality_ : *default_instance_->_buy_vitality_;
}
inline ::up::buy_vitality* up_msg::mutable__buy_vitality() {
  set_has__buy_vitality();
  if (_buy_vitality_ == NULL) _buy_vitality_ = new ::up::buy_vitality;
  return _buy_vitality_;
}
inline ::up::buy_vitality* up_msg::release__buy_vitality() {
  clear_has__buy_vitality();
  ::up::buy_vitality* temp = _buy_vitality_;
  _buy_vitality_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__buy_vitality(::up::buy_vitality* _buy_vitality) {
  delete _buy_vitality_;
  _buy_vitality_ = _buy_vitality;
  if (_buy_vitality) {
    set_has__buy_vitality();
  } else {
    clear_has__buy_vitality();
  }
}

// optional .up.buy_skill_stren_point _buy_skill_stren_point = 25;
inline bool up_msg::has__buy_skill_stren_point() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void up_msg::set_has__buy_skill_stren_point() {
  _has_bits_[0] |= 0x01000000u;
}
inline void up_msg::clear_has__buy_skill_stren_point() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void up_msg::clear__buy_skill_stren_point() {
  if (_buy_skill_stren_point_ != NULL) _buy_skill_stren_point_->::up::buy_skill_stren_point::Clear();
  clear_has__buy_skill_stren_point();
}
inline const ::up::buy_skill_stren_point& up_msg::_buy_skill_stren_point() const {
  return _buy_skill_stren_point_ != NULL ? *_buy_skill_stren_point_ : *default_instance_->_buy_skill_stren_point_;
}
inline ::up::buy_skill_stren_point* up_msg::mutable__buy_skill_stren_point() {
  set_has__buy_skill_stren_point();
  if (_buy_skill_stren_point_ == NULL) _buy_skill_stren_point_ = new ::up::buy_skill_stren_point;
  return _buy_skill_stren_point_;
}
inline ::up::buy_skill_stren_point* up_msg::release__buy_skill_stren_point() {
  clear_has__buy_skill_stren_point();
  ::up::buy_skill_stren_point* temp = _buy_skill_stren_point_;
  _buy_skill_stren_point_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__buy_skill_stren_point(::up::buy_skill_stren_point* _buy_skill_stren_point) {
  delete _buy_skill_stren_point_;
  _buy_skill_stren_point_ = _buy_skill_stren_point;
  if (_buy_skill_stren_point) {
    set_has__buy_skill_stren_point();
  } else {
    clear_has__buy_skill_stren_point();
  }
}

// optional .up.tavern_draw _tavern_draw = 26;
inline bool up_msg::has__tavern_draw() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void up_msg::set_has__tavern_draw() {
  _has_bits_[0] |= 0x02000000u;
}
inline void up_msg::clear_has__tavern_draw() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void up_msg::clear__tavern_draw() {
  if (_tavern_draw_ != NULL) _tavern_draw_->::up::tavern_draw::Clear();
  clear_has__tavern_draw();
}
inline const ::up::tavern_draw& up_msg::_tavern_draw() const {
  return _tavern_draw_ != NULL ? *_tavern_draw_ : *default_instance_->_tavern_draw_;
}
inline ::up::tavern_draw* up_msg::mutable__tavern_draw() {
  set_has__tavern_draw();
  if (_tavern_draw_ == NULL) _tavern_draw_ = new ::up::tavern_draw;
  return _tavern_draw_;
}
inline ::up::tavern_draw* up_msg::release__tavern_draw() {
  clear_has__tavern_draw();
  ::up::tavern_draw* temp = _tavern_draw_;
  _tavern_draw_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__tavern_draw(::up::tavern_draw* _tavern_draw) {
  delete _tavern_draw_;
  _tavern_draw_ = _tavern_draw;
  if (_tavern_draw) {
    set_has__tavern_draw();
  } else {
    clear_has__tavern_draw();
  }
}

// optional .up.query_data _query_data = 27;
inline bool up_msg::has__query_data() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void up_msg::set_has__query_data() {
  _has_bits_[0] |= 0x04000000u;
}
inline void up_msg::clear_has__query_data() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void up_msg::clear__query_data() {
  if (_query_data_ != NULL) _query_data_->::up::query_data::Clear();
  clear_has__query_data();
}
inline const ::up::query_data& up_msg::_query_data() const {
  return _query_data_ != NULL ? *_query_data_ : *default_instance_->_query_data_;
}
inline ::up::query_data* up_msg::mutable__query_data() {
  set_has__query_data();
  if (_query_data_ == NULL) _query_data_ = new ::up::query_data;
  return _query_data_;
}
inline ::up::query_data* up_msg::release__query_data() {
  clear_has__query_data();
  ::up::query_data* temp = _query_data_;
  _query_data_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__query_data(::up::query_data* _query_data) {
  delete _query_data_;
  _query_data_ = _query_data;
  if (_query_data) {
    set_has__query_data();
  } else {
    clear_has__query_data();
  }
}

// optional .up.hero_evolve _hero_evolve = 28;
inline bool up_msg::has__hero_evolve() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void up_msg::set_has__hero_evolve() {
  _has_bits_[0] |= 0x08000000u;
}
inline void up_msg::clear_has__hero_evolve() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void up_msg::clear__hero_evolve() {
  if (_hero_evolve_ != NULL) _hero_evolve_->::up::hero_evolve::Clear();
  clear_has__hero_evolve();
}
inline const ::up::hero_evolve& up_msg::_hero_evolve() const {
  return _hero_evolve_ != NULL ? *_hero_evolve_ : *default_instance_->_hero_evolve_;
}
inline ::up::hero_evolve* up_msg::mutable__hero_evolve() {
  set_has__hero_evolve();
  if (_hero_evolve_ == NULL) _hero_evolve_ = new ::up::hero_evolve;
  return _hero_evolve_;
}
inline ::up::hero_evolve* up_msg::release__hero_evolve() {
  clear_has__hero_evolve();
  ::up::hero_evolve* temp = _hero_evolve_;
  _hero_evolve_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__hero_evolve(::up::hero_evolve* _hero_evolve) {
  delete _hero_evolve_;
  _hero_evolve_ = _hero_evolve;
  if (_hero_evolve) {
    set_has__hero_evolve();
  } else {
    clear_has__hero_evolve();
  }
}

// optional .up.enter_act_stage _enter_act_stage = 29;
inline bool up_msg::has__enter_act_stage() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void up_msg::set_has__enter_act_stage() {
  _has_bits_[0] |= 0x10000000u;
}
inline void up_msg::clear_has__enter_act_stage() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void up_msg::clear__enter_act_stage() {
  if (_enter_act_stage_ != NULL) _enter_act_stage_->::up::enter_act_stage::Clear();
  clear_has__enter_act_stage();
}
inline const ::up::enter_act_stage& up_msg::_enter_act_stage() const {
  return _enter_act_stage_ != NULL ? *_enter_act_stage_ : *default_instance_->_enter_act_stage_;
}
inline ::up::enter_act_stage* up_msg::mutable__enter_act_stage() {
  set_has__enter_act_stage();
  if (_enter_act_stage_ == NULL) _enter_act_stage_ = new ::up::enter_act_stage;
  return _enter_act_stage_;
}
inline ::up::enter_act_stage* up_msg::release__enter_act_stage() {
  clear_has__enter_act_stage();
  ::up::enter_act_stage* temp = _enter_act_stage_;
  _enter_act_stage_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__enter_act_stage(::up::enter_act_stage* _enter_act_stage) {
  delete _enter_act_stage_;
  _enter_act_stage_ = _enter_act_stage;
  if (_enter_act_stage) {
    set_has__enter_act_stage();
  } else {
    clear_has__enter_act_stage();
  }
}

// optional .up.sync_vitality _sync_vitality = 30;
inline bool up_msg::has__sync_vitality() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void up_msg::set_has__sync_vitality() {
  _has_bits_[0] |= 0x20000000u;
}
inline void up_msg::clear_has__sync_vitality() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void up_msg::clear__sync_vitality() {
  if (_sync_vitality_ != NULL) _sync_vitality_->::up::sync_vitality::Clear();
  clear_has__sync_vitality();
}
inline const ::up::sync_vitality& up_msg::_sync_vitality() const {
  return _sync_vitality_ != NULL ? *_sync_vitality_ : *default_instance_->_sync_vitality_;
}
inline ::up::sync_vitality* up_msg::mutable__sync_vitality() {
  set_has__sync_vitality();
  if (_sync_vitality_ == NULL) _sync_vitality_ = new ::up::sync_vitality;
  return _sync_vitality_;
}
inline ::up::sync_vitality* up_msg::release__sync_vitality() {
  clear_has__sync_vitality();
  ::up::sync_vitality* temp = _sync_vitality_;
  _sync_vitality_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__sync_vitality(::up::sync_vitality* _sync_vitality) {
  delete _sync_vitality_;
  _sync_vitality_ = _sync_vitality;
  if (_sync_vitality) {
    set_has__sync_vitality();
  } else {
    clear_has__sync_vitality();
  }
}

// optional .up.suspend_report _suspend_report = 31;
inline bool up_msg::has__suspend_report() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void up_msg::set_has__suspend_report() {
  _has_bits_[0] |= 0x40000000u;
}
inline void up_msg::clear_has__suspend_report() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void up_msg::clear__suspend_report() {
  if (_suspend_report_ != NULL) _suspend_report_->::up::suspend_report::Clear();
  clear_has__suspend_report();
}
inline const ::up::suspend_report& up_msg::_suspend_report() const {
  return _suspend_report_ != NULL ? *_suspend_report_ : *default_instance_->_suspend_report_;
}
inline ::up::suspend_report* up_msg::mutable__suspend_report() {
  set_has__suspend_report();
  if (_suspend_report_ == NULL) _suspend_report_ = new ::up::suspend_report;
  return _suspend_report_;
}
inline ::up::suspend_report* up_msg::release__suspend_report() {
  clear_has__suspend_report();
  ::up::suspend_report* temp = _suspend_report_;
  _suspend_report_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__suspend_report(::up::suspend_report* _suspend_report) {
  delete _suspend_report_;
  _suspend_report_ = _suspend_report;
  if (_suspend_report) {
    set_has__suspend_report();
  } else {
    clear_has__suspend_report();
  }
}

// optional .up.tutorial _tutorial = 32;
inline bool up_msg::has__tutorial() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void up_msg::set_has__tutorial() {
  _has_bits_[0] |= 0x80000000u;
}
inline void up_msg::clear_has__tutorial() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void up_msg::clear__tutorial() {
  if (_tutorial_ != NULL) _tutorial_->::up::tutorial::Clear();
  clear_has__tutorial();
}
inline const ::up::tutorial& up_msg::_tutorial() const {
  return _tutorial_ != NULL ? *_tutorial_ : *default_instance_->_tutorial_;
}
inline ::up::tutorial* up_msg::mutable__tutorial() {
  set_has__tutorial();
  if (_tutorial_ == NULL) _tutorial_ = new ::up::tutorial;
  return _tutorial_;
}
inline ::up::tutorial* up_msg::release__tutorial() {
  clear_has__tutorial();
  ::up::tutorial* temp = _tutorial_;
  _tutorial_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__tutorial(::up::tutorial* _tutorial) {
  delete _tutorial_;
  _tutorial_ = _tutorial;
  if (_tutorial) {
    set_has__tutorial();
  } else {
    clear_has__tutorial();
  }
}

// optional .up.ladder _ladder = 33;
inline bool up_msg::has__ladder() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void up_msg::set_has__ladder() {
  _has_bits_[1] |= 0x00000001u;
}
inline void up_msg::clear_has__ladder() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void up_msg::clear__ladder() {
  if (_ladder_ != NULL) _ladder_->::up::ladder::Clear();
  clear_has__ladder();
}
inline const ::up::ladder& up_msg::_ladder() const {
  return _ladder_ != NULL ? *_ladder_ : *default_instance_->_ladder_;
}
inline ::up::ladder* up_msg::mutable__ladder() {
  set_has__ladder();
  if (_ladder_ == NULL) _ladder_ = new ::up::ladder;
  return _ladder_;
}
inline ::up::ladder* up_msg::release__ladder() {
  clear_has__ladder();
  ::up::ladder* temp = _ladder_;
  _ladder_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__ladder(::up::ladder* _ladder) {
  delete _ladder_;
  _ladder_ = _ladder;
  if (_ladder) {
    set_has__ladder();
  } else {
    clear_has__ladder();
  }
}

// optional .up.set_name _set_name = 34;
inline bool up_msg::has__set_name() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void up_msg::set_has__set_name() {
  _has_bits_[1] |= 0x00000002u;
}
inline void up_msg::clear_has__set_name() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void up_msg::clear__set_name() {
  if (_set_name_ != NULL) _set_name_->::up::set_name::Clear();
  clear_has__set_name();
}
inline const ::up::set_name& up_msg::_set_name() const {
  return _set_name_ != NULL ? *_set_name_ : *default_instance_->_set_name_;
}
inline ::up::set_name* up_msg::mutable__set_name() {
  set_has__set_name();
  if (_set_name_ == NULL) _set_name_ = new ::up::set_name;
  return _set_name_;
}
inline ::up::set_name* up_msg::release__set_name() {
  clear_has__set_name();
  ::up::set_name* temp = _set_name_;
  _set_name_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__set_name(::up::set_name* _set_name) {
  delete _set_name_;
  _set_name_ = _set_name;
  if (_set_name) {
    set_has__set_name();
  } else {
    clear_has__set_name();
  }
}

// optional .up.midas _midas = 35;
inline bool up_msg::has__midas() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void up_msg::set_has__midas() {
  _has_bits_[1] |= 0x00000004u;
}
inline void up_msg::clear_has__midas() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void up_msg::clear__midas() {
  if (_midas_ != NULL) _midas_->::up::midas::Clear();
  clear_has__midas();
}
inline const ::up::midas& up_msg::_midas() const {
  return _midas_ != NULL ? *_midas_ : *default_instance_->_midas_;
}
inline ::up::midas* up_msg::mutable__midas() {
  set_has__midas();
  if (_midas_ == NULL) _midas_ = new ::up::midas;
  return _midas_;
}
inline ::up::midas* up_msg::release__midas() {
  clear_has__midas();
  ::up::midas* temp = _midas_;
  _midas_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__midas(::up::midas* _midas) {
  delete _midas_;
  _midas_ = _midas;
  if (_midas) {
    set_has__midas();
  } else {
    clear_has__midas();
  }
}

// optional .up.open_shop _open_shop = 36;
inline bool up_msg::has__open_shop() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void up_msg::set_has__open_shop() {
  _has_bits_[1] |= 0x00000008u;
}
inline void up_msg::clear_has__open_shop() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void up_msg::clear__open_shop() {
  if (_open_shop_ != NULL) _open_shop_->::up::open_shop::Clear();
  clear_has__open_shop();
}
inline const ::up::open_shop& up_msg::_open_shop() const {
  return _open_shop_ != NULL ? *_open_shop_ : *default_instance_->_open_shop_;
}
inline ::up::open_shop* up_msg::mutable__open_shop() {
  set_has__open_shop();
  if (_open_shop_ == NULL) _open_shop_ = new ::up::open_shop;
  return _open_shop_;
}
inline ::up::open_shop* up_msg::release__open_shop() {
  clear_has__open_shop();
  ::up::open_shop* temp = _open_shop_;
  _open_shop_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__open_shop(::up::open_shop* _open_shop) {
  delete _open_shop_;
  _open_shop_ = _open_shop;
  if (_open_shop) {
    set_has__open_shop();
  } else {
    clear_has__open_shop();
  }
}

// optional .up.charge _charge = 37;
inline bool up_msg::has__charge() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void up_msg::set_has__charge() {
  _has_bits_[1] |= 0x00000010u;
}
inline void up_msg::clear_has__charge() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void up_msg::clear__charge() {
  if (_charge_ != NULL) _charge_->::up::charge::Clear();
  clear_has__charge();
}
inline const ::up::charge& up_msg::_charge() const {
  return _charge_ != NULL ? *_charge_ : *default_instance_->_charge_;
}
inline ::up::charge* up_msg::mutable__charge() {
  set_has__charge();
  if (_charge_ == NULL) _charge_ = new ::up::charge;
  return _charge_;
}
inline ::up::charge* up_msg::release__charge() {
  clear_has__charge();
  ::up::charge* temp = _charge_;
  _charge_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__charge(::up::charge* _charge) {
  delete _charge_;
  _charge_ = _charge;
  if (_charge) {
    set_has__charge();
  } else {
    clear_has__charge();
  }
}

// optional .up.sdk_login _sdk_login = 38;
inline bool up_msg::has__sdk_login() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void up_msg::set_has__sdk_login() {
  _has_bits_[1] |= 0x00000020u;
}
inline void up_msg::clear_has__sdk_login() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void up_msg::clear__sdk_login() {
  if (_sdk_login_ != NULL) _sdk_login_->::up::sdk_login::Clear();
  clear_has__sdk_login();
}
inline const ::up::sdk_login& up_msg::_sdk_login() const {
  return _sdk_login_ != NULL ? *_sdk_login_ : *default_instance_->_sdk_login_;
}
inline ::up::sdk_login* up_msg::mutable__sdk_login() {
  set_has__sdk_login();
  if (_sdk_login_ == NULL) _sdk_login_ = new ::up::sdk_login;
  return _sdk_login_;
}
inline ::up::sdk_login* up_msg::release__sdk_login() {
  clear_has__sdk_login();
  ::up::sdk_login* temp = _sdk_login_;
  _sdk_login_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__sdk_login(::up::sdk_login* _sdk_login) {
  delete _sdk_login_;
  _sdk_login_ = _sdk_login;
  if (_sdk_login) {
    set_has__sdk_login();
  } else {
    clear_has__sdk_login();
  }
}

// optional .up.set_avatar _set_avatar = 39;
inline bool up_msg::has__set_avatar() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void up_msg::set_has__set_avatar() {
  _has_bits_[1] |= 0x00000040u;
}
inline void up_msg::clear_has__set_avatar() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void up_msg::clear__set_avatar() {
  if (_set_avatar_ != NULL) _set_avatar_->::up::set_avatar::Clear();
  clear_has__set_avatar();
}
inline const ::up::set_avatar& up_msg::_set_avatar() const {
  return _set_avatar_ != NULL ? *_set_avatar_ : *default_instance_->_set_avatar_;
}
inline ::up::set_avatar* up_msg::mutable__set_avatar() {
  set_has__set_avatar();
  if (_set_avatar_ == NULL) _set_avatar_ = new ::up::set_avatar;
  return _set_avatar_;
}
inline ::up::set_avatar* up_msg::release__set_avatar() {
  clear_has__set_avatar();
  ::up::set_avatar* temp = _set_avatar_;
  _set_avatar_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__set_avatar(::up::set_avatar* _set_avatar) {
  delete _set_avatar_;
  _set_avatar_ = _set_avatar;
  if (_set_avatar) {
    set_has__set_avatar();
  } else {
    clear_has__set_avatar();
  }
}

// optional .up.ask_daily_login _ask_daily_login = 40;
inline bool up_msg::has__ask_daily_login() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void up_msg::set_has__ask_daily_login() {
  _has_bits_[1] |= 0x00000080u;
}
inline void up_msg::clear_has__ask_daily_login() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void up_msg::clear__ask_daily_login() {
  if (_ask_daily_login_ != NULL) _ask_daily_login_->::up::ask_daily_login::Clear();
  clear_has__ask_daily_login();
}
inline const ::up::ask_daily_login& up_msg::_ask_daily_login() const {
  return _ask_daily_login_ != NULL ? *_ask_daily_login_ : *default_instance_->_ask_daily_login_;
}
inline ::up::ask_daily_login* up_msg::mutable__ask_daily_login() {
  set_has__ask_daily_login();
  if (_ask_daily_login_ == NULL) _ask_daily_login_ = new ::up::ask_daily_login;
  return _ask_daily_login_;
}
inline ::up::ask_daily_login* up_msg::release__ask_daily_login() {
  clear_has__ask_daily_login();
  ::up::ask_daily_login* temp = _ask_daily_login_;
  _ask_daily_login_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__ask_daily_login(::up::ask_daily_login* _ask_daily_login) {
  delete _ask_daily_login_;
  _ask_daily_login_ = _ask_daily_login;
  if (_ask_daily_login) {
    set_has__ask_daily_login();
  } else {
    clear_has__ask_daily_login();
  }
}

// optional .up.tbc _tbc = 41;
inline bool up_msg::has__tbc() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void up_msg::set_has__tbc() {
  _has_bits_[1] |= 0x00000100u;
}
inline void up_msg::clear_has__tbc() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void up_msg::clear__tbc() {
  if (_tbc_ != NULL) _tbc_->::up::tbc::Clear();
  clear_has__tbc();
}
inline const ::up::tbc& up_msg::_tbc() const {
  return _tbc_ != NULL ? *_tbc_ : *default_instance_->_tbc_;
}
inline ::up::tbc* up_msg::mutable__tbc() {
  set_has__tbc();
  if (_tbc_ == NULL) _tbc_ = new ::up::tbc;
  return _tbc_;
}
inline ::up::tbc* up_msg::release__tbc() {
  clear_has__tbc();
  ::up::tbc* temp = _tbc_;
  _tbc_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__tbc(::up::tbc* _tbc) {
  delete _tbc_;
  _tbc_ = _tbc;
  if (_tbc) {
    set_has__tbc();
  } else {
    clear_has__tbc();
  }
}

// optional .up.get_maillist _get_maillist = 42;
inline bool up_msg::has__get_maillist() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void up_msg::set_has__get_maillist() {
  _has_bits_[1] |= 0x00000200u;
}
inline void up_msg::clear_has__get_maillist() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void up_msg::clear__get_maillist() {
  if (_get_maillist_ != NULL) _get_maillist_->::up::get_maillist::Clear();
  clear_has__get_maillist();
}
inline const ::up::get_maillist& up_msg::_get_maillist() const {
  return _get_maillist_ != NULL ? *_get_maillist_ : *default_instance_->_get_maillist_;
}
inline ::up::get_maillist* up_msg::mutable__get_maillist() {
  set_has__get_maillist();
  if (_get_maillist_ == NULL) _get_maillist_ = new ::up::get_maillist;
  return _get_maillist_;
}
inline ::up::get_maillist* up_msg::release__get_maillist() {
  clear_has__get_maillist();
  ::up::get_maillist* temp = _get_maillist_;
  _get_maillist_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__get_maillist(::up::get_maillist* _get_maillist) {
  delete _get_maillist_;
  _get_maillist_ = _get_maillist;
  if (_get_maillist) {
    set_has__get_maillist();
  } else {
    clear_has__get_maillist();
  }
}

// optional .up.read_mail _read_mail = 43;
inline bool up_msg::has__read_mail() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void up_msg::set_has__read_mail() {
  _has_bits_[1] |= 0x00000400u;
}
inline void up_msg::clear_has__read_mail() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void up_msg::clear__read_mail() {
  if (_read_mail_ != NULL) _read_mail_->::up::read_mail::Clear();
  clear_has__read_mail();
}
inline const ::up::read_mail& up_msg::_read_mail() const {
  return _read_mail_ != NULL ? *_read_mail_ : *default_instance_->_read_mail_;
}
inline ::up::read_mail* up_msg::mutable__read_mail() {
  set_has__read_mail();
  if (_read_mail_ == NULL) _read_mail_ = new ::up::read_mail;
  return _read_mail_;
}
inline ::up::read_mail* up_msg::release__read_mail() {
  clear_has__read_mail();
  ::up::read_mail* temp = _read_mail_;
  _read_mail_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__read_mail(::up::read_mail* _read_mail) {
  delete _read_mail_;
  _read_mail_ = _read_mail;
  if (_read_mail) {
    set_has__read_mail();
  } else {
    clear_has__read_mail();
  }
}

// optional .up.get_svr_time _get_svr_time = 44;
inline bool up_msg::has__get_svr_time() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void up_msg::set_has__get_svr_time() {
  _has_bits_[1] |= 0x00000800u;
}
inline void up_msg::clear_has__get_svr_time() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void up_msg::clear__get_svr_time() {
  if (_get_svr_time_ != NULL) _get_svr_time_->::up::get_svr_time::Clear();
  clear_has__get_svr_time();
}
inline const ::up::get_svr_time& up_msg::_get_svr_time() const {
  return _get_svr_time_ != NULL ? *_get_svr_time_ : *default_instance_->_get_svr_time_;
}
inline ::up::get_svr_time* up_msg::mutable__get_svr_time() {
  set_has__get_svr_time();
  if (_get_svr_time_ == NULL) _get_svr_time_ = new ::up::get_svr_time;
  return _get_svr_time_;
}
inline ::up::get_svr_time* up_msg::release__get_svr_time() {
  clear_has__get_svr_time();
  ::up::get_svr_time* temp = _get_svr_time_;
  _get_svr_time_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__get_svr_time(::up::get_svr_time* _get_svr_time) {
  delete _get_svr_time_;
  _get_svr_time_ = _get_svr_time;
  if (_get_svr_time) {
    set_has__get_svr_time();
  } else {
    clear_has__get_svr_time();
  }
}

// optional .up.get_vip_gift _get_vip_gift = 45;
inline bool up_msg::has__get_vip_gift() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void up_msg::set_has__get_vip_gift() {
  _has_bits_[1] |= 0x00001000u;
}
inline void up_msg::clear_has__get_vip_gift() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void up_msg::clear__get_vip_gift() {
  if (_get_vip_gift_ != NULL) _get_vip_gift_->::up::get_vip_gift::Clear();
  clear_has__get_vip_gift();
}
inline const ::up::get_vip_gift& up_msg::_get_vip_gift() const {
  return _get_vip_gift_ != NULL ? *_get_vip_gift_ : *default_instance_->_get_vip_gift_;
}
inline ::up::get_vip_gift* up_msg::mutable__get_vip_gift() {
  set_has__get_vip_gift();
  if (_get_vip_gift_ == NULL) _get_vip_gift_ = new ::up::get_vip_gift;
  return _get_vip_gift_;
}
inline ::up::get_vip_gift* up_msg::release__get_vip_gift() {
  clear_has__get_vip_gift();
  ::up::get_vip_gift* temp = _get_vip_gift_;
  _get_vip_gift_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__get_vip_gift(::up::get_vip_gift* _get_vip_gift) {
  delete _get_vip_gift_;
  _get_vip_gift_ = _get_vip_gift;
  if (_get_vip_gift) {
    set_has__get_vip_gift();
  } else {
    clear_has__get_vip_gift();
  }
}

// optional string _important_data_md5 = 46;
inline bool up_msg::has__important_data_md5() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void up_msg::set_has__important_data_md5() {
  _has_bits_[1] |= 0x00002000u;
}
inline void up_msg::clear_has__important_data_md5() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void up_msg::clear__important_data_md5() {
  if (_important_data_md5_ != &::google::protobuf::internal::kEmptyString) {
    _important_data_md5_->clear();
  }
  clear_has__important_data_md5();
}
inline const ::std::string& up_msg::_important_data_md5() const {
  return *_important_data_md5_;
}
inline void up_msg::set__important_data_md5(const ::std::string& value) {
  set_has__important_data_md5();
  if (_important_data_md5_ == &::google::protobuf::internal::kEmptyString) {
    _important_data_md5_ = new ::std::string;
  }
  _important_data_md5_->assign(value);
}
inline void up_msg::set__important_data_md5(const char* value) {
  set_has__important_data_md5();
  if (_important_data_md5_ == &::google::protobuf::internal::kEmptyString) {
    _important_data_md5_ = new ::std::string;
  }
  _important_data_md5_->assign(value);
}
inline void up_msg::set__important_data_md5(const char* value, size_t size) {
  set_has__important_data_md5();
  if (_important_data_md5_ == &::google::protobuf::internal::kEmptyString) {
    _important_data_md5_ = new ::std::string;
  }
  _important_data_md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* up_msg::mutable__important_data_md5() {
  set_has__important_data_md5();
  if (_important_data_md5_ == &::google::protobuf::internal::kEmptyString) {
    _important_data_md5_ = new ::std::string;
  }
  return _important_data_md5_;
}
inline ::std::string* up_msg::release__important_data_md5() {
  clear_has__important_data_md5();
  if (_important_data_md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _important_data_md5_;
    _important_data_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void up_msg::set_allocated__important_data_md5(::std::string* _important_data_md5) {
  if (_important_data_md5_ != &::google::protobuf::internal::kEmptyString) {
    delete _important_data_md5_;
  }
  if (_important_data_md5) {
    set_has__important_data_md5();
    _important_data_md5_ = _important_data_md5;
  } else {
    clear_has__important_data_md5();
    _important_data_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .up.chat _chat = 47;
inline bool up_msg::has__chat() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void up_msg::set_has__chat() {
  _has_bits_[1] |= 0x00004000u;
}
inline void up_msg::clear_has__chat() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void up_msg::clear__chat() {
  if (_chat_ != NULL) _chat_->::up::chat::Clear();
  clear_has__chat();
}
inline const ::up::chat& up_msg::_chat() const {
  return _chat_ != NULL ? *_chat_ : *default_instance_->_chat_;
}
inline ::up::chat* up_msg::mutable__chat() {
  set_has__chat();
  if (_chat_ == NULL) _chat_ = new ::up::chat;
  return _chat_;
}
inline ::up::chat* up_msg::release__chat() {
  clear_has__chat();
  ::up::chat* temp = _chat_;
  _chat_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__chat(::up::chat* _chat) {
  delete _chat_;
  _chat_ = _chat;
  if (_chat) {
    set_has__chat();
  } else {
    clear_has__chat();
  }
}

// optional .up.cdkey_gift _cdkey_gift = 48;
inline bool up_msg::has__cdkey_gift() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void up_msg::set_has__cdkey_gift() {
  _has_bits_[1] |= 0x00008000u;
}
inline void up_msg::clear_has__cdkey_gift() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void up_msg::clear__cdkey_gift() {
  if (_cdkey_gift_ != NULL) _cdkey_gift_->::up::cdkey_gift::Clear();
  clear_has__cdkey_gift();
}
inline const ::up::cdkey_gift& up_msg::_cdkey_gift() const {
  return _cdkey_gift_ != NULL ? *_cdkey_gift_ : *default_instance_->_cdkey_gift_;
}
inline ::up::cdkey_gift* up_msg::mutable__cdkey_gift() {
  set_has__cdkey_gift();
  if (_cdkey_gift_ == NULL) _cdkey_gift_ = new ::up::cdkey_gift;
  return _cdkey_gift_;
}
inline ::up::cdkey_gift* up_msg::release__cdkey_gift() {
  clear_has__cdkey_gift();
  ::up::cdkey_gift* temp = _cdkey_gift_;
  _cdkey_gift_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__cdkey_gift(::up::cdkey_gift* _cdkey_gift) {
  delete _cdkey_gift_;
  _cdkey_gift_ = _cdkey_gift;
  if (_cdkey_gift) {
    set_has__cdkey_gift();
  } else {
    clear_has__cdkey_gift();
  }
}

// optional .up.guild _guild = 49;
inline bool up_msg::has__guild() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void up_msg::set_has__guild() {
  _has_bits_[1] |= 0x00010000u;
}
inline void up_msg::clear_has__guild() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void up_msg::clear__guild() {
  if (_guild_ != NULL) _guild_->::up::guild::Clear();
  clear_has__guild();
}
inline const ::up::guild& up_msg::_guild() const {
  return _guild_ != NULL ? *_guild_ : *default_instance_->_guild_;
}
inline ::up::guild* up_msg::mutable__guild() {
  set_has__guild();
  if (_guild_ == NULL) _guild_ = new ::up::guild;
  return _guild_;
}
inline ::up::guild* up_msg::release__guild() {
  clear_has__guild();
  ::up::guild* temp = _guild_;
  _guild_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__guild(::up::guild* _guild) {
  delete _guild_;
  _guild_ = _guild;
  if (_guild) {
    set_has__guild();
  } else {
    clear_has__guild();
  }
}

// optional .up.ask_magicsoul _ask_magicsoul = 50;
inline bool up_msg::has__ask_magicsoul() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void up_msg::set_has__ask_magicsoul() {
  _has_bits_[1] |= 0x00020000u;
}
inline void up_msg::clear_has__ask_magicsoul() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void up_msg::clear__ask_magicsoul() {
  if (_ask_magicsoul_ != NULL) _ask_magicsoul_->::up::ask_magicsoul::Clear();
  clear_has__ask_magicsoul();
}
inline const ::up::ask_magicsoul& up_msg::_ask_magicsoul() const {
  return _ask_magicsoul_ != NULL ? *_ask_magicsoul_ : *default_instance_->_ask_magicsoul_;
}
inline ::up::ask_magicsoul* up_msg::mutable__ask_magicsoul() {
  set_has__ask_magicsoul();
  if (_ask_magicsoul_ == NULL) _ask_magicsoul_ = new ::up::ask_magicsoul;
  return _ask_magicsoul_;
}
inline ::up::ask_magicsoul* up_msg::release__ask_magicsoul() {
  clear_has__ask_magicsoul();
  ::up::ask_magicsoul* temp = _ask_magicsoul_;
  _ask_magicsoul_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__ask_magicsoul(::up::ask_magicsoul* _ask_magicsoul) {
  delete _ask_magicsoul_;
  _ask_magicsoul_ = _ask_magicsoul;
  if (_ask_magicsoul) {
    set_has__ask_magicsoul();
  } else {
    clear_has__ask_magicsoul();
  }
}

// optional .up.ask_activity_info _ask_activity_info = 51;
inline bool up_msg::has__ask_activity_info() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void up_msg::set_has__ask_activity_info() {
  _has_bits_[1] |= 0x00040000u;
}
inline void up_msg::clear_has__ask_activity_info() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void up_msg::clear__ask_activity_info() {
  if (_ask_activity_info_ != NULL) _ask_activity_info_->::up::ask_activity_info::Clear();
  clear_has__ask_activity_info();
}
inline const ::up::ask_activity_info& up_msg::_ask_activity_info() const {
  return _ask_activity_info_ != NULL ? *_ask_activity_info_ : *default_instance_->_ask_activity_info_;
}
inline ::up::ask_activity_info* up_msg::mutable__ask_activity_info() {
  set_has__ask_activity_info();
  if (_ask_activity_info_ == NULL) _ask_activity_info_ = new ::up::ask_activity_info;
  return _ask_activity_info_;
}
inline ::up::ask_activity_info* up_msg::release__ask_activity_info() {
  clear_has__ask_activity_info();
  ::up::ask_activity_info* temp = _ask_activity_info_;
  _ask_activity_info_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__ask_activity_info(::up::ask_activity_info* _ask_activity_info) {
  delete _ask_activity_info_;
  _ask_activity_info_ = _ask_activity_info;
  if (_ask_activity_info) {
    set_has__ask_activity_info();
  } else {
    clear_has__ask_activity_info();
  }
}

// optional .up.excavate _excavate = 52;
inline bool up_msg::has__excavate() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void up_msg::set_has__excavate() {
  _has_bits_[1] |= 0x00080000u;
}
inline void up_msg::clear_has__excavate() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void up_msg::clear__excavate() {
  if (_excavate_ != NULL) _excavate_->::up::excavate::Clear();
  clear_has__excavate();
}
inline const ::up::excavate& up_msg::_excavate() const {
  return _excavate_ != NULL ? *_excavate_ : *default_instance_->_excavate_;
}
inline ::up::excavate* up_msg::mutable__excavate() {
  set_has__excavate();
  if (_excavate_ == NULL) _excavate_ = new ::up::excavate;
  return _excavate_;
}
inline ::up::excavate* up_msg::release__excavate() {
  clear_has__excavate();
  ::up::excavate* temp = _excavate_;
  _excavate_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__excavate(::up::excavate* _excavate) {
  delete _excavate_;
  _excavate_ = _excavate;
  if (_excavate) {
    set_has__excavate();
  } else {
    clear_has__excavate();
  }
}

// optional .up.push_notify _push_notify = 53;
inline bool up_msg::has__push_notify() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void up_msg::set_has__push_notify() {
  _has_bits_[1] |= 0x00100000u;
}
inline void up_msg::clear_has__push_notify() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void up_msg::clear__push_notify() {
  if (_push_notify_ != NULL) _push_notify_->::up::push_notify::Clear();
  clear_has__push_notify();
}
inline const ::up::push_notify& up_msg::_push_notify() const {
  return _push_notify_ != NULL ? *_push_notify_ : *default_instance_->_push_notify_;
}
inline ::up::push_notify* up_msg::mutable__push_notify() {
  set_has__push_notify();
  if (_push_notify_ == NULL) _push_notify_ = new ::up::push_notify;
  return _push_notify_;
}
inline ::up::push_notify* up_msg::release__push_notify() {
  clear_has__push_notify();
  ::up::push_notify* temp = _push_notify_;
  _push_notify_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__push_notify(::up::push_notify* _push_notify) {
  delete _push_notify_;
  _push_notify_ = _push_notify;
  if (_push_notify) {
    set_has__push_notify();
  } else {
    clear_has__push_notify();
  }
}

// optional .up.system_setting _system_setting = 54;
inline bool up_msg::has__system_setting() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void up_msg::set_has__system_setting() {
  _has_bits_[1] |= 0x00200000u;
}
inline void up_msg::clear_has__system_setting() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void up_msg::clear__system_setting() {
  if (_system_setting_ != NULL) _system_setting_->::up::system_setting::Clear();
  clear_has__system_setting();
}
inline const ::up::system_setting& up_msg::_system_setting() const {
  return _system_setting_ != NULL ? *_system_setting_ : *default_instance_->_system_setting_;
}
inline ::up::system_setting* up_msg::mutable__system_setting() {
  set_has__system_setting();
  if (_system_setting_ == NULL) _system_setting_ = new ::up::system_setting;
  return _system_setting_;
}
inline ::up::system_setting* up_msg::release__system_setting() {
  clear_has__system_setting();
  ::up::system_setting* temp = _system_setting_;
  _system_setting_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__system_setting(::up::system_setting* _system_setting) {
  delete _system_setting_;
  _system_setting_ = _system_setting;
  if (_system_setting) {
    set_has__system_setting();
  } else {
    clear_has__system_setting();
  }
}

// optional .up.query_split_data _query_split_data = 55;
inline bool up_msg::has__query_split_data() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void up_msg::set_has__query_split_data() {
  _has_bits_[1] |= 0x00400000u;
}
inline void up_msg::clear_has__query_split_data() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void up_msg::clear__query_split_data() {
  if (_query_split_data_ != NULL) _query_split_data_->::up::query_split_data::Clear();
  clear_has__query_split_data();
}
inline const ::up::query_split_data& up_msg::_query_split_data() const {
  return _query_split_data_ != NULL ? *_query_split_data_ : *default_instance_->_query_split_data_;
}
inline ::up::query_split_data* up_msg::mutable__query_split_data() {
  set_has__query_split_data();
  if (_query_split_data_ == NULL) _query_split_data_ = new ::up::query_split_data;
  return _query_split_data_;
}
inline ::up::query_split_data* up_msg::release__query_split_data() {
  clear_has__query_split_data();
  ::up::query_split_data* temp = _query_split_data_;
  _query_split_data_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__query_split_data(::up::query_split_data* _query_split_data) {
  delete _query_split_data_;
  _query_split_data_ = _query_split_data;
  if (_query_split_data) {
    set_has__query_split_data();
  } else {
    clear_has__query_split_data();
  }
}

// optional .up.query_split_return _query_split_return = 56;
inline bool up_msg::has__query_split_return() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void up_msg::set_has__query_split_return() {
  _has_bits_[1] |= 0x00800000u;
}
inline void up_msg::clear_has__query_split_return() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void up_msg::clear__query_split_return() {
  if (_query_split_return_ != NULL) _query_split_return_->::up::query_split_return::Clear();
  clear_has__query_split_return();
}
inline const ::up::query_split_return& up_msg::_query_split_return() const {
  return _query_split_return_ != NULL ? *_query_split_return_ : *default_instance_->_query_split_return_;
}
inline ::up::query_split_return* up_msg::mutable__query_split_return() {
  set_has__query_split_return();
  if (_query_split_return_ == NULL) _query_split_return_ = new ::up::query_split_return;
  return _query_split_return_;
}
inline ::up::query_split_return* up_msg::release__query_split_return() {
  clear_has__query_split_return();
  ::up::query_split_return* temp = _query_split_return_;
  _query_split_return_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__query_split_return(::up::query_split_return* _query_split_return) {
  delete _query_split_return_;
  _query_split_return_ = _query_split_return;
  if (_query_split_return) {
    set_has__query_split_return();
  } else {
    clear_has__query_split_return();
  }
}

// optional .up.split_hero _split_hero = 57;
inline bool up_msg::has__split_hero() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void up_msg::set_has__split_hero() {
  _has_bits_[1] |= 0x01000000u;
}
inline void up_msg::clear_has__split_hero() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void up_msg::clear__split_hero() {
  if (_split_hero_ != NULL) _split_hero_->::up::split_hero::Clear();
  clear_has__split_hero();
}
inline const ::up::split_hero& up_msg::_split_hero() const {
  return _split_hero_ != NULL ? *_split_hero_ : *default_instance_->_split_hero_;
}
inline ::up::split_hero* up_msg::mutable__split_hero() {
  set_has__split_hero();
  if (_split_hero_ == NULL) _split_hero_ = new ::up::split_hero;
  return _split_hero_;
}
inline ::up::split_hero* up_msg::release__split_hero() {
  clear_has__split_hero();
  ::up::split_hero* temp = _split_hero_;
  _split_hero_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__split_hero(::up::split_hero* _split_hero) {
  delete _split_hero_;
  _split_hero_ = _split_hero;
  if (_split_hero) {
    set_has__split_hero();
  } else {
    clear_has__split_hero();
  }
}

// optional .up.worldcup _worldcup = 58;
inline bool up_msg::has__worldcup() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void up_msg::set_has__worldcup() {
  _has_bits_[1] |= 0x02000000u;
}
inline void up_msg::clear_has__worldcup() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void up_msg::clear__worldcup() {
  if (_worldcup_ != NULL) _worldcup_->::up::worldcup::Clear();
  clear_has__worldcup();
}
inline const ::up::worldcup& up_msg::_worldcup() const {
  return _worldcup_ != NULL ? *_worldcup_ : *default_instance_->_worldcup_;
}
inline ::up::worldcup* up_msg::mutable__worldcup() {
  set_has__worldcup();
  if (_worldcup_ == NULL) _worldcup_ = new ::up::worldcup;
  return _worldcup_;
}
inline ::up::worldcup* up_msg::release__worldcup() {
  clear_has__worldcup();
  ::up::worldcup* temp = _worldcup_;
  _worldcup_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__worldcup(::up::worldcup* _worldcup) {
  delete _worldcup_;
  _worldcup_ = _worldcup;
  if (_worldcup) {
    set_has__worldcup();
  } else {
    clear_has__worldcup();
  }
}

// optional .up.report_battle _report_battle = 59;
inline bool up_msg::has__report_battle() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void up_msg::set_has__report_battle() {
  _has_bits_[1] |= 0x04000000u;
}
inline void up_msg::clear_has__report_battle() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void up_msg::clear__report_battle() {
  if (_report_battle_ != NULL) _report_battle_->::up::report_battle::Clear();
  clear_has__report_battle();
}
inline const ::up::report_battle& up_msg::_report_battle() const {
  return _report_battle_ != NULL ? *_report_battle_ : *default_instance_->_report_battle_;
}
inline ::up::report_battle* up_msg::mutable__report_battle() {
  set_has__report_battle();
  if (_report_battle_ == NULL) _report_battle_ = new ::up::report_battle;
  return _report_battle_;
}
inline ::up::report_battle* up_msg::release__report_battle() {
  clear_has__report_battle();
  ::up::report_battle* temp = _report_battle_;
  _report_battle_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__report_battle(::up::report_battle* _report_battle) {
  delete _report_battle_;
  _report_battle_ = _report_battle;
  if (_report_battle) {
    set_has__report_battle();
  } else {
    clear_has__report_battle();
  }
}

// optional .up.query_replay _query_replay = 60;
inline bool up_msg::has__query_replay() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void up_msg::set_has__query_replay() {
  _has_bits_[1] |= 0x08000000u;
}
inline void up_msg::clear_has__query_replay() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void up_msg::clear__query_replay() {
  if (_query_replay_ != NULL) _query_replay_->::up::query_replay::Clear();
  clear_has__query_replay();
}
inline const ::up::query_replay& up_msg::_query_replay() const {
  return _query_replay_ != NULL ? *_query_replay_ : *default_instance_->_query_replay_;
}
inline ::up::query_replay* up_msg::mutable__query_replay() {
  set_has__query_replay();
  if (_query_replay_ == NULL) _query_replay_ = new ::up::query_replay;
  return _query_replay_;
}
inline ::up::query_replay* up_msg::release__query_replay() {
  clear_has__query_replay();
  ::up::query_replay* temp = _query_replay_;
  _query_replay_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__query_replay(::up::query_replay* _query_replay) {
  delete _query_replay_;
  _query_replay_ = _query_replay;
  if (_query_replay) {
    set_has__query_replay();
  } else {
    clear_has__query_replay();
  }
}

// optional .up.sync_skill_stren _sync_skill_stren = 61;
inline bool up_msg::has__sync_skill_stren() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void up_msg::set_has__sync_skill_stren() {
  _has_bits_[1] |= 0x10000000u;
}
inline void up_msg::clear_has__sync_skill_stren() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void up_msg::clear__sync_skill_stren() {
  if (_sync_skill_stren_ != NULL) _sync_skill_stren_->::up::sync_skill_stren::Clear();
  clear_has__sync_skill_stren();
}
inline const ::up::sync_skill_stren& up_msg::_sync_skill_stren() const {
  return _sync_skill_stren_ != NULL ? *_sync_skill_stren_ : *default_instance_->_sync_skill_stren_;
}
inline ::up::sync_skill_stren* up_msg::mutable__sync_skill_stren() {
  set_has__sync_skill_stren();
  if (_sync_skill_stren_ == NULL) _sync_skill_stren_ = new ::up::sync_skill_stren;
  return _sync_skill_stren_;
}
inline ::up::sync_skill_stren* up_msg::release__sync_skill_stren() {
  clear_has__sync_skill_stren();
  ::up::sync_skill_stren* temp = _sync_skill_stren_;
  _sync_skill_stren_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__sync_skill_stren(::up::sync_skill_stren* _sync_skill_stren) {
  delete _sync_skill_stren_;
  _sync_skill_stren_ = _sync_skill_stren;
  if (_sync_skill_stren) {
    set_has__sync_skill_stren();
  } else {
    clear_has__sync_skill_stren();
  }
}

// optional .up.query_ranklist _query_ranklist = 62;
inline bool up_msg::has__query_ranklist() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void up_msg::set_has__query_ranklist() {
  _has_bits_[1] |= 0x20000000u;
}
inline void up_msg::clear_has__query_ranklist() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void up_msg::clear__query_ranklist() {
  if (_query_ranklist_ != NULL) _query_ranklist_->::up::query_ranklist::Clear();
  clear_has__query_ranklist();
}
inline const ::up::query_ranklist& up_msg::_query_ranklist() const {
  return _query_ranklist_ != NULL ? *_query_ranklist_ : *default_instance_->_query_ranklist_;
}
inline ::up::query_ranklist* up_msg::mutable__query_ranklist() {
  set_has__query_ranklist();
  if (_query_ranklist_ == NULL) _query_ranklist_ = new ::up::query_ranklist;
  return _query_ranklist_;
}
inline ::up::query_ranklist* up_msg::release__query_ranklist() {
  clear_has__query_ranklist();
  ::up::query_ranklist* temp = _query_ranklist_;
  _query_ranklist_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__query_ranklist(::up::query_ranklist* _query_ranklist) {
  delete _query_ranklist_;
  _query_ranklist_ = _query_ranklist;
  if (_query_ranklist) {
    set_has__query_ranklist();
  } else {
    clear_has__query_ranklist();
  }
}

// optional .up.change_server _change_server = 63;
inline bool up_msg::has__change_server() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void up_msg::set_has__change_server() {
  _has_bits_[1] |= 0x40000000u;
}
inline void up_msg::clear_has__change_server() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void up_msg::clear__change_server() {
  if (_change_server_ != NULL) _change_server_->::up::change_server::Clear();
  clear_has__change_server();
}
inline const ::up::change_server& up_msg::_change_server() const {
  return _change_server_ != NULL ? *_change_server_ : *default_instance_->_change_server_;
}
inline ::up::change_server* up_msg::mutable__change_server() {
  set_has__change_server();
  if (_change_server_ == NULL) _change_server_ = new ::up::change_server;
  return _change_server_;
}
inline ::up::change_server* up_msg::release__change_server() {
  clear_has__change_server();
  ::up::change_server* temp = _change_server_;
  _change_server_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__change_server(::up::change_server* _change_server) {
  delete _change_server_;
  _change_server_ = _change_server;
  if (_change_server) {
    set_has__change_server();
  } else {
    clear_has__change_server();
  }
}

// optional .up.require_arousal _require_arousal = 64;
inline bool up_msg::has__require_arousal() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void up_msg::set_has__require_arousal() {
  _has_bits_[1] |= 0x80000000u;
}
inline void up_msg::clear_has__require_arousal() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void up_msg::clear__require_arousal() {
  if (_require_arousal_ != NULL) _require_arousal_->::up::require_arousal::Clear();
  clear_has__require_arousal();
}
inline const ::up::require_arousal& up_msg::_require_arousal() const {
  return _require_arousal_ != NULL ? *_require_arousal_ : *default_instance_->_require_arousal_;
}
inline ::up::require_arousal* up_msg::mutable__require_arousal() {
  set_has__require_arousal();
  if (_require_arousal_ == NULL) _require_arousal_ = new ::up::require_arousal;
  return _require_arousal_;
}
inline ::up::require_arousal* up_msg::release__require_arousal() {
  clear_has__require_arousal();
  ::up::require_arousal* temp = _require_arousal_;
  _require_arousal_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__require_arousal(::up::require_arousal* _require_arousal) {
  delete _require_arousal_;
  _require_arousal_ = _require_arousal;
  if (_require_arousal) {
    set_has__require_arousal();
  } else {
    clear_has__require_arousal();
  }
}

// optional .up.change_task_status _change_task_status = 65;
inline bool up_msg::has__change_task_status() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void up_msg::set_has__change_task_status() {
  _has_bits_[2] |= 0x00000001u;
}
inline void up_msg::clear_has__change_task_status() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void up_msg::clear__change_task_status() {
  if (_change_task_status_ != NULL) _change_task_status_->::up::change_task_status::Clear();
  clear_has__change_task_status();
}
inline const ::up::change_task_status& up_msg::_change_task_status() const {
  return _change_task_status_ != NULL ? *_change_task_status_ : *default_instance_->_change_task_status_;
}
inline ::up::change_task_status* up_msg::mutable__change_task_status() {
  set_has__change_task_status();
  if (_change_task_status_ == NULL) _change_task_status_ = new ::up::change_task_status;
  return _change_task_status_;
}
inline ::up::change_task_status* up_msg::release__change_task_status() {
  clear_has__change_task_status();
  ::up::change_task_status* temp = _change_task_status_;
  _change_task_status_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__change_task_status(::up::change_task_status* _change_task_status) {
  delete _change_task_status_;
  _change_task_status_ = _change_task_status;
  if (_change_task_status) {
    set_has__change_task_status();
  } else {
    clear_has__change_task_status();
  }
}

// optional .up.request_guild_log _request_guild_log = 66;
inline bool up_msg::has__request_guild_log() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void up_msg::set_has__request_guild_log() {
  _has_bits_[2] |= 0x00000002u;
}
inline void up_msg::clear_has__request_guild_log() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void up_msg::clear__request_guild_log() {
  if (_request_guild_log_ != NULL) _request_guild_log_->::up::request_guild_log::Clear();
  clear_has__request_guild_log();
}
inline const ::up::request_guild_log& up_msg::_request_guild_log() const {
  return _request_guild_log_ != NULL ? *_request_guild_log_ : *default_instance_->_request_guild_log_;
}
inline ::up::request_guild_log* up_msg::mutable__request_guild_log() {
  set_has__request_guild_log();
  if (_request_guild_log_ == NULL) _request_guild_log_ = new ::up::request_guild_log;
  return _request_guild_log_;
}
inline ::up::request_guild_log* up_msg::release__request_guild_log() {
  clear_has__request_guild_log();
  ::up::request_guild_log* temp = _request_guild_log_;
  _request_guild_log_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__request_guild_log(::up::request_guild_log* _request_guild_log) {
  delete _request_guild_log_;
  _request_guild_log_ = _request_guild_log;
  if (_request_guild_log) {
    set_has__request_guild_log();
  } else {
    clear_has__request_guild_log();
  }
}

// optional .up.query_act_stage _query_act_stage = 67;
inline bool up_msg::has__query_act_stage() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void up_msg::set_has__query_act_stage() {
  _has_bits_[2] |= 0x00000004u;
}
inline void up_msg::clear_has__query_act_stage() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void up_msg::clear__query_act_stage() {
  if (_query_act_stage_ != NULL) _query_act_stage_->::up::query_act_stage::Clear();
  clear_has__query_act_stage();
}
inline const ::up::query_act_stage& up_msg::_query_act_stage() const {
  return _query_act_stage_ != NULL ? *_query_act_stage_ : *default_instance_->_query_act_stage_;
}
inline ::up::query_act_stage* up_msg::mutable__query_act_stage() {
  set_has__query_act_stage();
  if (_query_act_stage_ == NULL) _query_act_stage_ = new ::up::query_act_stage;
  return _query_act_stage_;
}
inline ::up::query_act_stage* up_msg::release__query_act_stage() {
  clear_has__query_act_stage();
  ::up::query_act_stage* temp = _query_act_stage_;
  _query_act_stage_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__query_act_stage(::up::query_act_stage* _query_act_stage) {
  delete _query_act_stage_;
  _query_act_stage_ = _query_act_stage;
  if (_query_act_stage) {
    set_has__query_act_stage();
  } else {
    clear_has__query_act_stage();
  }
}

// optional .up.request_upgrade_arousal_level _request_upgrade_arousal_level = 68;
inline bool up_msg::has__request_upgrade_arousal_level() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void up_msg::set_has__request_upgrade_arousal_level() {
  _has_bits_[2] |= 0x00000008u;
}
inline void up_msg::clear_has__request_upgrade_arousal_level() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void up_msg::clear__request_upgrade_arousal_level() {
  if (_request_upgrade_arousal_level_ != NULL) _request_upgrade_arousal_level_->::up::request_upgrade_arousal_level::Clear();
  clear_has__request_upgrade_arousal_level();
}
inline const ::up::request_upgrade_arousal_level& up_msg::_request_upgrade_arousal_level() const {
  return _request_upgrade_arousal_level_ != NULL ? *_request_upgrade_arousal_level_ : *default_instance_->_request_upgrade_arousal_level_;
}
inline ::up::request_upgrade_arousal_level* up_msg::mutable__request_upgrade_arousal_level() {
  set_has__request_upgrade_arousal_level();
  if (_request_upgrade_arousal_level_ == NULL) _request_upgrade_arousal_level_ = new ::up::request_upgrade_arousal_level;
  return _request_upgrade_arousal_level_;
}
inline ::up::request_upgrade_arousal_level* up_msg::release__request_upgrade_arousal_level() {
  clear_has__request_upgrade_arousal_level();
  ::up::request_upgrade_arousal_level* temp = _request_upgrade_arousal_level_;
  _request_upgrade_arousal_level_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__request_upgrade_arousal_level(::up::request_upgrade_arousal_level* _request_upgrade_arousal_level) {
  delete _request_upgrade_arousal_level_;
  _request_upgrade_arousal_level_ = _request_upgrade_arousal_level;
  if (_request_upgrade_arousal_level) {
    set_has__request_upgrade_arousal_level();
  } else {
    clear_has__request_upgrade_arousal_level();
  }
}

// optional .up.fb_attention _fb_attention = 300;
inline bool up_msg::has__fb_attention() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void up_msg::set_has__fb_attention() {
  _has_bits_[2] |= 0x00000010u;
}
inline void up_msg::clear_has__fb_attention() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void up_msg::clear__fb_attention() {
  if (_fb_attention_ != NULL) _fb_attention_->::up::fb_attention::Clear();
  clear_has__fb_attention();
}
inline const ::up::fb_attention& up_msg::_fb_attention() const {
  return _fb_attention_ != NULL ? *_fb_attention_ : *default_instance_->_fb_attention_;
}
inline ::up::fb_attention* up_msg::mutable__fb_attention() {
  set_has__fb_attention();
  if (_fb_attention_ == NULL) _fb_attention_ = new ::up::fb_attention;
  return _fb_attention_;
}
inline ::up::fb_attention* up_msg::release__fb_attention() {
  clear_has__fb_attention();
  ::up::fb_attention* temp = _fb_attention_;
  _fb_attention_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__fb_attention(::up::fb_attention* _fb_attention) {
  delete _fb_attention_;
  _fb_attention_ = _fb_attention;
  if (_fb_attention) {
    set_has__fb_attention();
  } else {
    clear_has__fb_attention();
  }
}

// optional .up.dot_info _dot_info = 301;
inline bool up_msg::has__dot_info() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void up_msg::set_has__dot_info() {
  _has_bits_[2] |= 0x00000020u;
}
inline void up_msg::clear_has__dot_info() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void up_msg::clear__dot_info() {
  if (_dot_info_ != NULL) _dot_info_->::up::dot_info::Clear();
  clear_has__dot_info();
}
inline const ::up::dot_info& up_msg::_dot_info() const {
  return _dot_info_ != NULL ? *_dot_info_ : *default_instance_->_dot_info_;
}
inline ::up::dot_info* up_msg::mutable__dot_info() {
  set_has__dot_info();
  if (_dot_info_ == NULL) _dot_info_ = new ::up::dot_info;
  return _dot_info_;
}
inline ::up::dot_info* up_msg::release__dot_info() {
  clear_has__dot_info();
  ::up::dot_info* temp = _dot_info_;
  _dot_info_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__dot_info(::up::dot_info* _dot_info) {
  delete _dot_info_;
  _dot_info_ = _dot_info;
  if (_dot_info) {
    set_has__dot_info();
  } else {
    clear_has__dot_info();
  }
}

// optional .up.activity_info _activity_info = 69;
inline bool up_msg::has__activity_info() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void up_msg::set_has__activity_info() {
  _has_bits_[2] |= 0x00000040u;
}
inline void up_msg::clear_has__activity_info() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void up_msg::clear__activity_info() {
  if (_activity_info_ != NULL) _activity_info_->::up::activity_info::Clear();
  clear_has__activity_info();
}
inline const ::up::activity_info& up_msg::_activity_info() const {
  return _activity_info_ != NULL ? *_activity_info_ : *default_instance_->_activity_info_;
}
inline ::up::activity_info* up_msg::mutable__activity_info() {
  set_has__activity_info();
  if (_activity_info_ == NULL) _activity_info_ = new ::up::activity_info;
  return _activity_info_;
}
inline ::up::activity_info* up_msg::release__activity_info() {
  clear_has__activity_info();
  ::up::activity_info* temp = _activity_info_;
  _activity_info_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__activity_info(::up::activity_info* _activity_info) {
  delete _activity_info_;
  _activity_info_ = _activity_info;
  if (_activity_info) {
    set_has__activity_info();
  } else {
    clear_has__activity_info();
  }
}

// optional .up.activity_lotto_info _activity_lotto_info = 70;
inline bool up_msg::has__activity_lotto_info() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void up_msg::set_has__activity_lotto_info() {
  _has_bits_[2] |= 0x00000080u;
}
inline void up_msg::clear_has__activity_lotto_info() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void up_msg::clear__activity_lotto_info() {
  if (_activity_lotto_info_ != NULL) _activity_lotto_info_->::up::activity_lotto_info::Clear();
  clear_has__activity_lotto_info();
}
inline const ::up::activity_lotto_info& up_msg::_activity_lotto_info() const {
  return _activity_lotto_info_ != NULL ? *_activity_lotto_info_ : *default_instance_->_activity_lotto_info_;
}
inline ::up::activity_lotto_info* up_msg::mutable__activity_lotto_info() {
  set_has__activity_lotto_info();
  if (_activity_lotto_info_ == NULL) _activity_lotto_info_ = new ::up::activity_lotto_info;
  return _activity_lotto_info_;
}
inline ::up::activity_lotto_info* up_msg::release__activity_lotto_info() {
  clear_has__activity_lotto_info();
  ::up::activity_lotto_info* temp = _activity_lotto_info_;
  _activity_lotto_info_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__activity_lotto_info(::up::activity_lotto_info* _activity_lotto_info) {
  delete _activity_lotto_info_;
  _activity_lotto_info_ = _activity_lotto_info;
  if (_activity_lotto_info) {
    set_has__activity_lotto_info();
  } else {
    clear_has__activity_lotto_info();
  }
}

// optional .up.activity_lotto_reward _activity_lotto_reward = 71;
inline bool up_msg::has__activity_lotto_reward() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void up_msg::set_has__activity_lotto_reward() {
  _has_bits_[2] |= 0x00000100u;
}
inline void up_msg::clear_has__activity_lotto_reward() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void up_msg::clear__activity_lotto_reward() {
  if (_activity_lotto_reward_ != NULL) _activity_lotto_reward_->::up::activity_lotto_reward::Clear();
  clear_has__activity_lotto_reward();
}
inline const ::up::activity_lotto_reward& up_msg::_activity_lotto_reward() const {
  return _activity_lotto_reward_ != NULL ? *_activity_lotto_reward_ : *default_instance_->_activity_lotto_reward_;
}
inline ::up::activity_lotto_reward* up_msg::mutable__activity_lotto_reward() {
  set_has__activity_lotto_reward();
  if (_activity_lotto_reward_ == NULL) _activity_lotto_reward_ = new ::up::activity_lotto_reward;
  return _activity_lotto_reward_;
}
inline ::up::activity_lotto_reward* up_msg::release__activity_lotto_reward() {
  clear_has__activity_lotto_reward();
  ::up::activity_lotto_reward* temp = _activity_lotto_reward_;
  _activity_lotto_reward_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__activity_lotto_reward(::up::activity_lotto_reward* _activity_lotto_reward) {
  delete _activity_lotto_reward_;
  _activity_lotto_reward_ = _activity_lotto_reward;
  if (_activity_lotto_reward) {
    set_has__activity_lotto_reward();
  } else {
    clear_has__activity_lotto_reward();
  }
}

// optional .up.activity_bigpackage_info _activity_bigpackage_info = 72;
inline bool up_msg::has__activity_bigpackage_info() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void up_msg::set_has__activity_bigpackage_info() {
  _has_bits_[2] |= 0x00000200u;
}
inline void up_msg::clear_has__activity_bigpackage_info() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void up_msg::clear__activity_bigpackage_info() {
  if (_activity_bigpackage_info_ != NULL) _activity_bigpackage_info_->::up::activity_bigpackage_info::Clear();
  clear_has__activity_bigpackage_info();
}
inline const ::up::activity_bigpackage_info& up_msg::_activity_bigpackage_info() const {
  return _activity_bigpackage_info_ != NULL ? *_activity_bigpackage_info_ : *default_instance_->_activity_bigpackage_info_;
}
inline ::up::activity_bigpackage_info* up_msg::mutable__activity_bigpackage_info() {
  set_has__activity_bigpackage_info();
  if (_activity_bigpackage_info_ == NULL) _activity_bigpackage_info_ = new ::up::activity_bigpackage_info;
  return _activity_bigpackage_info_;
}
inline ::up::activity_bigpackage_info* up_msg::release__activity_bigpackage_info() {
  clear_has__activity_bigpackage_info();
  ::up::activity_bigpackage_info* temp = _activity_bigpackage_info_;
  _activity_bigpackage_info_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__activity_bigpackage_info(::up::activity_bigpackage_info* _activity_bigpackage_info) {
  delete _activity_bigpackage_info_;
  _activity_bigpackage_info_ = _activity_bigpackage_info;
  if (_activity_bigpackage_info) {
    set_has__activity_bigpackage_info();
  } else {
    clear_has__activity_bigpackage_info();
  }
}

// optional .up.activity_bigpackage_reward_info _activity_bigpackage_reward_info = 73;
inline bool up_msg::has__activity_bigpackage_reward_info() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void up_msg::set_has__activity_bigpackage_reward_info() {
  _has_bits_[2] |= 0x00000400u;
}
inline void up_msg::clear_has__activity_bigpackage_reward_info() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void up_msg::clear__activity_bigpackage_reward_info() {
  if (_activity_bigpackage_reward_info_ != NULL) _activity_bigpackage_reward_info_->::up::activity_bigpackage_reward_info::Clear();
  clear_has__activity_bigpackage_reward_info();
}
inline const ::up::activity_bigpackage_reward_info& up_msg::_activity_bigpackage_reward_info() const {
  return _activity_bigpackage_reward_info_ != NULL ? *_activity_bigpackage_reward_info_ : *default_instance_->_activity_bigpackage_reward_info_;
}
inline ::up::activity_bigpackage_reward_info* up_msg::mutable__activity_bigpackage_reward_info() {
  set_has__activity_bigpackage_reward_info();
  if (_activity_bigpackage_reward_info_ == NULL) _activity_bigpackage_reward_info_ = new ::up::activity_bigpackage_reward_info;
  return _activity_bigpackage_reward_info_;
}
inline ::up::activity_bigpackage_reward_info* up_msg::release__activity_bigpackage_reward_info() {
  clear_has__activity_bigpackage_reward_info();
  ::up::activity_bigpackage_reward_info* temp = _activity_bigpackage_reward_info_;
  _activity_bigpackage_reward_info_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__activity_bigpackage_reward_info(::up::activity_bigpackage_reward_info* _activity_bigpackage_reward_info) {
  delete _activity_bigpackage_reward_info_;
  _activity_bigpackage_reward_info_ = _activity_bigpackage_reward_info;
  if (_activity_bigpackage_reward_info) {
    set_has__activity_bigpackage_reward_info();
  } else {
    clear_has__activity_bigpackage_reward_info();
  }
}

// optional .up.activity_bigpackage_reset _activity_bigpackage_reset = 74;
inline bool up_msg::has__activity_bigpackage_reset() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void up_msg::set_has__activity_bigpackage_reset() {
  _has_bits_[2] |= 0x00000800u;
}
inline void up_msg::clear_has__activity_bigpackage_reset() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void up_msg::clear__activity_bigpackage_reset() {
  if (_activity_bigpackage_reset_ != NULL) _activity_bigpackage_reset_->::up::activity_bigpackage_reset::Clear();
  clear_has__activity_bigpackage_reset();
}
inline const ::up::activity_bigpackage_reset& up_msg::_activity_bigpackage_reset() const {
  return _activity_bigpackage_reset_ != NULL ? *_activity_bigpackage_reset_ : *default_instance_->_activity_bigpackage_reset_;
}
inline ::up::activity_bigpackage_reset* up_msg::mutable__activity_bigpackage_reset() {
  set_has__activity_bigpackage_reset();
  if (_activity_bigpackage_reset_ == NULL) _activity_bigpackage_reset_ = new ::up::activity_bigpackage_reset;
  return _activity_bigpackage_reset_;
}
inline ::up::activity_bigpackage_reset* up_msg::release__activity_bigpackage_reset() {
  clear_has__activity_bigpackage_reset();
  ::up::activity_bigpackage_reset* temp = _activity_bigpackage_reset_;
  _activity_bigpackage_reset_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__activity_bigpackage_reset(::up::activity_bigpackage_reset* _activity_bigpackage_reset) {
  delete _activity_bigpackage_reset_;
  _activity_bigpackage_reset_ = _activity_bigpackage_reset;
  if (_activity_bigpackage_reset) {
    set_has__activity_bigpackage_reset();
  } else {
    clear_has__activity_bigpackage_reset();
  }
}

// optional .up.continue_pay _continue_pay = 302;
inline bool up_msg::has__continue_pay() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void up_msg::set_has__continue_pay() {
  _has_bits_[2] |= 0x00001000u;
}
inline void up_msg::clear_has__continue_pay() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void up_msg::clear__continue_pay() {
  if (_continue_pay_ != NULL) _continue_pay_->::up::continue_pay::Clear();
  clear_has__continue_pay();
}
inline const ::up::continue_pay& up_msg::_continue_pay() const {
  return _continue_pay_ != NULL ? *_continue_pay_ : *default_instance_->_continue_pay_;
}
inline ::up::continue_pay* up_msg::mutable__continue_pay() {
  set_has__continue_pay();
  if (_continue_pay_ == NULL) _continue_pay_ = new ::up::continue_pay;
  return _continue_pay_;
}
inline ::up::continue_pay* up_msg::release__continue_pay() {
  clear_has__continue_pay();
  ::up::continue_pay* temp = _continue_pay_;
  _continue_pay_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__continue_pay(::up::continue_pay* _continue_pay) {
  delete _continue_pay_;
  _continue_pay_ = _continue_pay;
  if (_continue_pay) {
    set_has__continue_pay();
  } else {
    clear_has__continue_pay();
  }
}

// optional .up.recharge_rebate _recharge_rebate = 303;
inline bool up_msg::has__recharge_rebate() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void up_msg::set_has__recharge_rebate() {
  _has_bits_[2] |= 0x00002000u;
}
inline void up_msg::clear_has__recharge_rebate() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void up_msg::clear__recharge_rebate() {
  if (_recharge_rebate_ != NULL) _recharge_rebate_->::up::recharge_rebate::Clear();
  clear_has__recharge_rebate();
}
inline const ::up::recharge_rebate& up_msg::_recharge_rebate() const {
  return _recharge_rebate_ != NULL ? *_recharge_rebate_ : *default_instance_->_recharge_rebate_;
}
inline ::up::recharge_rebate* up_msg::mutable__recharge_rebate() {
  set_has__recharge_rebate();
  if (_recharge_rebate_ == NULL) _recharge_rebate_ = new ::up::recharge_rebate;
  return _recharge_rebate_;
}
inline ::up::recharge_rebate* up_msg::release__recharge_rebate() {
  clear_has__recharge_rebate();
  ::up::recharge_rebate* temp = _recharge_rebate_;
  _recharge_rebate_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__recharge_rebate(::up::recharge_rebate* _recharge_rebate) {
  delete _recharge_rebate_;
  _recharge_rebate_ = _recharge_rebate;
  if (_recharge_rebate) {
    set_has__recharge_rebate();
  } else {
    clear_has__recharge_rebate();
  }
}

// optional .up.every_day_happy _every_day_happy = 304;
inline bool up_msg::has__every_day_happy() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void up_msg::set_has__every_day_happy() {
  _has_bits_[2] |= 0x00004000u;
}
inline void up_msg::clear_has__every_day_happy() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void up_msg::clear__every_day_happy() {
  if (_every_day_happy_ != NULL) _every_day_happy_->::up::every_day_happy::Clear();
  clear_has__every_day_happy();
}
inline const ::up::every_day_happy& up_msg::_every_day_happy() const {
  return _every_day_happy_ != NULL ? *_every_day_happy_ : *default_instance_->_every_day_happy_;
}
inline ::up::every_day_happy* up_msg::mutable__every_day_happy() {
  set_has__every_day_happy();
  if (_every_day_happy_ == NULL) _every_day_happy_ = new ::up::every_day_happy;
  return _every_day_happy_;
}
inline ::up::every_day_happy* up_msg::release__every_day_happy() {
  clear_has__every_day_happy();
  ::up::every_day_happy* temp = _every_day_happy_;
  _every_day_happy_ = NULL;
  return temp;
}
inline void up_msg::set_allocated__every_day_happy(::up::every_day_happy* _every_day_happy) {
  delete _every_day_happy_;
  _every_day_happy_ = _every_day_happy;
  if (_every_day_happy) {
    set_has__every_day_happy();
  } else {
    clear_has__every_day_happy();
  }
}

// -------------------------------------------------------------------

// request_upgrade_arousal_level

// -------------------------------------------------------------------

// continue_pay

// required uint32 _continue_pay = 1;
inline bool continue_pay::has__continue_pay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void continue_pay::set_has__continue_pay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void continue_pay::clear_has__continue_pay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void continue_pay::clear__continue_pay() {
  _continue_pay_ = 0u;
  clear_has__continue_pay();
}
inline ::google::protobuf::uint32 continue_pay::_continue_pay() const {
  return _continue_pay_;
}
inline void continue_pay::set__continue_pay(::google::protobuf::uint32 value) {
  set_has__continue_pay();
  _continue_pay_ = value;
}

// -------------------------------------------------------------------

// recharge_rebate

// required uint32 _recharge_rebate = 1;
inline bool recharge_rebate::has__recharge_rebate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void recharge_rebate::set_has__recharge_rebate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void recharge_rebate::clear_has__recharge_rebate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void recharge_rebate::clear__recharge_rebate() {
  _recharge_rebate_ = 0u;
  clear_has__recharge_rebate();
}
inline ::google::protobuf::uint32 recharge_rebate::_recharge_rebate() const {
  return _recharge_rebate_;
}
inline void recharge_rebate::set__recharge_rebate(::google::protobuf::uint32 value) {
  set_has__recharge_rebate();
  _recharge_rebate_ = value;
}

// -------------------------------------------------------------------

// every_day_happy

// required uint32 _every_day_happy = 1;
inline bool every_day_happy::has__every_day_happy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void every_day_happy::set_has__every_day_happy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void every_day_happy::clear_has__every_day_happy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void every_day_happy::clear__every_day_happy() {
  _every_day_happy_ = 0u;
  clear_has__every_day_happy();
}
inline ::google::protobuf::uint32 every_day_happy::_every_day_happy() const {
  return _every_day_happy_;
}
inline void every_day_happy::set__every_day_happy(::google::protobuf::uint32 value) {
  set_has__every_day_happy();
  _every_day_happy_ = value;
}

// -------------------------------------------------------------------

// system_setting

// optional .up.system_setting_request _request = 1;
inline bool system_setting::has__request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void system_setting::set_has__request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void system_setting::clear_has__request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void system_setting::clear__request() {
  if (_request_ != NULL) _request_->::up::system_setting_request::Clear();
  clear_has__request();
}
inline const ::up::system_setting_request& system_setting::_request() const {
  return _request_ != NULL ? *_request_ : *default_instance_->_request_;
}
inline ::up::system_setting_request* system_setting::mutable__request() {
  set_has__request();
  if (_request_ == NULL) _request_ = new ::up::system_setting_request;
  return _request_;
}
inline ::up::system_setting_request* system_setting::release__request() {
  clear_has__request();
  ::up::system_setting_request* temp = _request_;
  _request_ = NULL;
  return temp;
}
inline void system_setting::set_allocated__request(::up::system_setting_request* _request) {
  delete _request_;
  _request_ = _request;
  if (_request) {
    set_has__request();
  } else {
    clear_has__request();
  }
}

// optional .up.system_setting_change _change = 2;
inline bool system_setting::has__change() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void system_setting::set_has__change() {
  _has_bits_[0] |= 0x00000002u;
}
inline void system_setting::clear_has__change() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void system_setting::clear__change() {
  if (_change_ != NULL) _change_->::up::system_setting_change::Clear();
  clear_has__change();
}
inline const ::up::system_setting_change& system_setting::_change() const {
  return _change_ != NULL ? *_change_ : *default_instance_->_change_;
}
inline ::up::system_setting_change* system_setting::mutable__change() {
  set_has__change();
  if (_change_ == NULL) _change_ = new ::up::system_setting_change;
  return _change_;
}
inline ::up::system_setting_change* system_setting::release__change() {
  clear_has__change();
  ::up::system_setting_change* temp = _change_;
  _change_ = NULL;
  return temp;
}
inline void system_setting::set_allocated__change(::up::system_setting_change* _change) {
  delete _change_;
  _change_ = _change;
  if (_change) {
    set_has__change();
  } else {
    clear_has__change();
  }
}

// -------------------------------------------------------------------

// system_setting_change

// required string key = 1;
inline bool system_setting_change::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void system_setting_change::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void system_setting_change::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void system_setting_change::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& system_setting_change::key() const {
  return *key_;
}
inline void system_setting_change::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void system_setting_change::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void system_setting_change::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* system_setting_change::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* system_setting_change::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void system_setting_change::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool system_setting_change::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void system_setting_change::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void system_setting_change::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void system_setting_change::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& system_setting_change::value() const {
  return *value_;
}
inline void system_setting_change::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void system_setting_change::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void system_setting_change::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* system_setting_change::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* system_setting_change::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void system_setting_change::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// system_setting_request

// -------------------------------------------------------------------

// push_notify

// required string _client_id = 1;
inline bool push_notify::has__client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void push_notify::set_has__client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void push_notify::clear_has__client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void push_notify::clear__client_id() {
  if (_client_id_ != &::google::protobuf::internal::kEmptyString) {
    _client_id_->clear();
  }
  clear_has__client_id();
}
inline const ::std::string& push_notify::_client_id() const {
  return *_client_id_;
}
inline void push_notify::set__client_id(const ::std::string& value) {
  set_has__client_id();
  if (_client_id_ == &::google::protobuf::internal::kEmptyString) {
    _client_id_ = new ::std::string;
  }
  _client_id_->assign(value);
}
inline void push_notify::set__client_id(const char* value) {
  set_has__client_id();
  if (_client_id_ == &::google::protobuf::internal::kEmptyString) {
    _client_id_ = new ::std::string;
  }
  _client_id_->assign(value);
}
inline void push_notify::set__client_id(const char* value, size_t size) {
  set_has__client_id();
  if (_client_id_ == &::google::protobuf::internal::kEmptyString) {
    _client_id_ = new ::std::string;
  }
  _client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* push_notify::mutable__client_id() {
  set_has__client_id();
  if (_client_id_ == &::google::protobuf::internal::kEmptyString) {
    _client_id_ = new ::std::string;
  }
  return _client_id_;
}
inline ::std::string* push_notify::release__client_id() {
  clear_has__client_id();
  if (_client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _client_id_;
    _client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void push_notify::set_allocated__client_id(::std::string* _client_id) {
  if (_client_id_ != &::google::protobuf::internal::kEmptyString) {
    delete _client_id_;
  }
  if (_client_id) {
    set_has__client_id();
    _client_id_ = _client_id;
  } else {
    clear_has__client_id();
    _client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// login

// optional uint64 _active_code = 1;
inline bool login::has__active_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login::set_has__active_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login::clear_has__active_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login::clear__active_code() {
  _active_code_ = GOOGLE_ULONGLONG(0);
  clear_has__active_code();
}
inline ::google::protobuf::uint64 login::_active_code() const {
  return _active_code_;
}
inline void login::set__active_code(::google::protobuf::uint64 value) {
  set_has__active_code();
  _active_code_ = value;
}

// optional string _old_deviceid = 2;
inline bool login::has__old_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login::set_has__old_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login::clear_has__old_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login::clear__old_deviceid() {
  if (_old_deviceid_ != &::google::protobuf::internal::kEmptyString) {
    _old_deviceid_->clear();
  }
  clear_has__old_deviceid();
}
inline const ::std::string& login::_old_deviceid() const {
  return *_old_deviceid_;
}
inline void login::set__old_deviceid(const ::std::string& value) {
  set_has__old_deviceid();
  if (_old_deviceid_ == &::google::protobuf::internal::kEmptyString) {
    _old_deviceid_ = new ::std::string;
  }
  _old_deviceid_->assign(value);
}
inline void login::set__old_deviceid(const char* value) {
  set_has__old_deviceid();
  if (_old_deviceid_ == &::google::protobuf::internal::kEmptyString) {
    _old_deviceid_ = new ::std::string;
  }
  _old_deviceid_->assign(value);
}
inline void login::set__old_deviceid(const char* value, size_t size) {
  set_has__old_deviceid();
  if (_old_deviceid_ == &::google::protobuf::internal::kEmptyString) {
    _old_deviceid_ = new ::std::string;
  }
  _old_deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* login::mutable__old_deviceid() {
  set_has__old_deviceid();
  if (_old_deviceid_ == &::google::protobuf::internal::kEmptyString) {
    _old_deviceid_ = new ::std::string;
  }
  return _old_deviceid_;
}
inline ::std::string* login::release__old_deviceid() {
  clear_has__old_deviceid();
  if (_old_deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _old_deviceid_;
    _old_deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void login::set_allocated__old_deviceid(::std::string* _old_deviceid) {
  if (_old_deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete _old_deviceid_;
  }
  if (_old_deviceid) {
    set_has__old_deviceid();
    _old_deviceid_ = _old_deviceid;
  } else {
    clear_has__old_deviceid();
    _old_deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string _version = 3;
inline bool login::has__version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login::set_has__version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login::clear_has__version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login::clear__version() {
  if (_version_ != &::google::protobuf::internal::kEmptyString) {
    _version_->clear();
  }
  clear_has__version();
}
inline const ::std::string& login::_version() const {
  return *_version_;
}
inline void login::set__version(const ::std::string& value) {
  set_has__version();
  if (_version_ == &::google::protobuf::internal::kEmptyString) {
    _version_ = new ::std::string;
  }
  _version_->assign(value);
}
inline void login::set__version(const char* value) {
  set_has__version();
  if (_version_ == &::google::protobuf::internal::kEmptyString) {
    _version_ = new ::std::string;
  }
  _version_->assign(value);
}
inline void login::set__version(const char* value, size_t size) {
  set_has__version();
  if (_version_ == &::google::protobuf::internal::kEmptyString) {
    _version_ = new ::std::string;
  }
  _version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* login::mutable__version() {
  set_has__version();
  if (_version_ == &::google::protobuf::internal::kEmptyString) {
    _version_ = new ::std::string;
  }
  return _version_;
}
inline ::std::string* login::release__version() {
  clear_has__version();
  if (_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _version_;
    _version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void login::set_allocated__version(::std::string* _version) {
  if (_version_ != &::google::protobuf::internal::kEmptyString) {
    delete _version_;
  }
  if (_version) {
    set_has__version();
    _version_ = _version;
  } else {
    clear_has__version();
    _version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 _languageid = 4;
inline bool login::has__languageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void login::set_has__languageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void login::clear_has__languageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void login::clear__languageid() {
  _languageid_ = 0u;
  clear_has__languageid();
}
inline ::google::protobuf::uint32 login::_languageid() const {
  return _languageid_;
}
inline void login::set__languageid(::google::protobuf::uint32 value) {
  set_has__languageid();
  _languageid_ = value;
}

// -------------------------------------------------------------------

// sdk_login

// required string _session_key = 1;
inline bool sdk_login::has__session_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sdk_login::set_has__session_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sdk_login::clear_has__session_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sdk_login::clear__session_key() {
  if (_session_key_ != &::google::protobuf::internal::kEmptyString) {
    _session_key_->clear();
  }
  clear_has__session_key();
}
inline const ::std::string& sdk_login::_session_key() const {
  return *_session_key_;
}
inline void sdk_login::set__session_key(const ::std::string& value) {
  set_has__session_key();
  if (_session_key_ == &::google::protobuf::internal::kEmptyString) {
    _session_key_ = new ::std::string;
  }
  _session_key_->assign(value);
}
inline void sdk_login::set__session_key(const char* value) {
  set_has__session_key();
  if (_session_key_ == &::google::protobuf::internal::kEmptyString) {
    _session_key_ = new ::std::string;
  }
  _session_key_->assign(value);
}
inline void sdk_login::set__session_key(const char* value, size_t size) {
  set_has__session_key();
  if (_session_key_ == &::google::protobuf::internal::kEmptyString) {
    _session_key_ = new ::std::string;
  }
  _session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sdk_login::mutable__session_key() {
  set_has__session_key();
  if (_session_key_ == &::google::protobuf::internal::kEmptyString) {
    _session_key_ = new ::std::string;
  }
  return _session_key_;
}
inline ::std::string* sdk_login::release__session_key() {
  clear_has__session_key();
  if (_session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _session_key_;
    _session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sdk_login::set_allocated__session_key(::std::string* _session_key) {
  if (_session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete _session_key_;
  }
  if (_session_key) {
    set_has__session_key();
    _session_key_ = _session_key;
  } else {
    clear_has__session_key();
    _session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .up.platform_type _plat_id = 2;
inline bool sdk_login::has__plat_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sdk_login::set_has__plat_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sdk_login::clear_has__plat_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sdk_login::clear__plat_id() {
  _plat_id_ = 0;
  clear_has__plat_id();
}
inline ::up::platform_type sdk_login::_plat_id() const {
  return static_cast< ::up::platform_type >(_plat_id_);
}
inline void sdk_login::set__plat_id(::up::platform_type value) {
  assert(::up::platform_type_IsValid(value));
  set_has__plat_id();
  _plat_id_ = value;
}

// -------------------------------------------------------------------

// request_userinfo

// -------------------------------------------------------------------

// enter_stage

// required uint32 _stage_id = 1;
inline bool enter_stage::has__stage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void enter_stage::set_has__stage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void enter_stage::clear_has__stage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void enter_stage::clear__stage_id() {
  _stage_id_ = 0u;
  clear_has__stage_id();
}
inline ::google::protobuf::uint32 enter_stage::_stage_id() const {
  return _stage_id_;
}
inline void enter_stage::set__stage_id(::google::protobuf::uint32 value) {
  set_has__stage_id();
  _stage_id_ = value;
}

// -------------------------------------------------------------------

// exit_stage

// required .up.battle_result _result = 1 [default = victory];
inline bool exit_stage::has__result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exit_stage::set_has__result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exit_stage::clear_has__result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exit_stage::clear__result() {
  _result_ = 0;
  clear_has__result();
}
inline ::up::battle_result exit_stage::_result() const {
  return static_cast< ::up::battle_result >(_result_);
}
inline void exit_stage::set__result(::up::battle_result value) {
  assert(::up::battle_result_IsValid(value));
  set_has__result();
  _result_ = value;
}

// optional uint32 _stars = 2;
inline bool exit_stage::has__stars() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exit_stage::set_has__stars() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exit_stage::clear_has__stars() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exit_stage::clear__stars() {
  _stars_ = 0u;
  clear_has__stars();
}
inline ::google::protobuf::uint32 exit_stage::_stars() const {
  return _stars_;
}
inline void exit_stage::set__stars(::google::protobuf::uint32 value) {
  set_has__stars();
  _stars_ = value;
}

// repeated uint32 _heroes = 3;
inline int exit_stage::_heroes_size() const {
  return _heroes_.size();
}
inline void exit_stage::clear__heroes() {
  _heroes_.Clear();
}
inline ::google::protobuf::uint32 exit_stage::_heroes(int index) const {
  return _heroes_.Get(index);
}
inline void exit_stage::set__heroes(int index, ::google::protobuf::uint32 value) {
  _heroes_.Set(index, value);
}
inline void exit_stage::add__heroes(::google::protobuf::uint32 value) {
  _heroes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
exit_stage::_heroes() const {
  return _heroes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
exit_stage::mutable__heroes() {
  return &_heroes_;
}

// repeated uint32 _oprations = 4;
inline int exit_stage::_oprations_size() const {
  return _oprations_.size();
}
inline void exit_stage::clear__oprations() {
  _oprations_.Clear();
}
inline ::google::protobuf::uint32 exit_stage::_oprations(int index) const {
  return _oprations_.Get(index);
}
inline void exit_stage::set__oprations(int index, ::google::protobuf::uint32 value) {
  _oprations_.Set(index, value);
}
inline void exit_stage::add__oprations(::google::protobuf::uint32 value) {
  _oprations_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
exit_stage::_oprations() const {
  return _oprations_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
exit_stage::mutable__oprations() {
  return &_oprations_;
}

// optional string _md5 = 5;
inline bool exit_stage::has__md5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void exit_stage::set_has__md5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void exit_stage::clear_has__md5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void exit_stage::clear__md5() {
  if (_md5_ != &::google::protobuf::internal::kEmptyString) {
    _md5_->clear();
  }
  clear_has__md5();
}
inline const ::std::string& exit_stage::_md5() const {
  return *_md5_;
}
inline void exit_stage::set__md5(const ::std::string& value) {
  set_has__md5();
  if (_md5_ == &::google::protobuf::internal::kEmptyString) {
    _md5_ = new ::std::string;
  }
  _md5_->assign(value);
}
inline void exit_stage::set__md5(const char* value) {
  set_has__md5();
  if (_md5_ == &::google::protobuf::internal::kEmptyString) {
    _md5_ = new ::std::string;
  }
  _md5_->assign(value);
}
inline void exit_stage::set__md5(const char* value, size_t size) {
  set_has__md5();
  if (_md5_ == &::google::protobuf::internal::kEmptyString) {
    _md5_ = new ::std::string;
  }
  _md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exit_stage::mutable__md5() {
  set_has__md5();
  if (_md5_ == &::google::protobuf::internal::kEmptyString) {
    _md5_ = new ::std::string;
  }
  return _md5_;
}
inline ::std::string* exit_stage::release__md5() {
  clear_has__md5();
  if (_md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _md5_;
    _md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exit_stage::set_allocated__md5(::std::string* _md5) {
  if (_md5_ != &::google::protobuf::internal::kEmptyString) {
    delete _md5_;
  }
  if (_md5) {
    set_has__md5();
    _md5_ = _md5;
  } else {
    clear_has__md5();
    _md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 _self_data = 6;
inline int exit_stage::_self_data_size() const {
  return _self_data_.size();
}
inline void exit_stage::clear__self_data() {
  _self_data_.Clear();
}
inline ::google::protobuf::uint32 exit_stage::_self_data(int index) const {
  return _self_data_.Get(index);
}
inline void exit_stage::set__self_data(int index, ::google::protobuf::uint32 value) {
  _self_data_.Set(index, value);
}
inline void exit_stage::add__self_data(::google::protobuf::uint32 value) {
  _self_data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
exit_stage::_self_data() const {
  return _self_data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
exit_stage::mutable__self_data() {
  return &_self_data_;
}

// -------------------------------------------------------------------

// gm_cmd

// optional int32 _unlock_all_stages = 1;
inline bool gm_cmd::has__unlock_all_stages() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_cmd::set_has__unlock_all_stages() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_cmd::clear_has__unlock_all_stages() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_cmd::clear__unlock_all_stages() {
  _unlock_all_stages_ = 0;
  clear_has__unlock_all_stages();
}
inline ::google::protobuf::int32 gm_cmd::_unlock_all_stages() const {
  return _unlock_all_stages_;
}
inline void gm_cmd::set__unlock_all_stages(::google::protobuf::int32 value) {
  set_has__unlock_all_stages();
  _unlock_all_stages_ = value;
}

// optional int32 _get_all_heroes = 2;
inline bool gm_cmd::has__get_all_heroes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm_cmd::set_has__get_all_heroes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm_cmd::clear_has__get_all_heroes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm_cmd::clear__get_all_heroes() {
  _get_all_heroes_ = 0;
  clear_has__get_all_heroes();
}
inline ::google::protobuf::int32 gm_cmd::_get_all_heroes() const {
  return _get_all_heroes_;
}
inline void gm_cmd::set__get_all_heroes(::google::protobuf::int32 value) {
  set_has__get_all_heroes();
  _get_all_heroes_ = value;
}

// repeated .up.hero _set_hero_info = 3;
inline int gm_cmd::_set_hero_info_size() const {
  return _set_hero_info_.size();
}
inline void gm_cmd::clear__set_hero_info() {
  _set_hero_info_.Clear();
}
inline const ::up::hero& gm_cmd::_set_hero_info(int index) const {
  return _set_hero_info_.Get(index);
}
inline ::up::hero* gm_cmd::mutable__set_hero_info(int index) {
  return _set_hero_info_.Mutable(index);
}
inline ::up::hero* gm_cmd::add__set_hero_info() {
  return _set_hero_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::up::hero >&
gm_cmd::_set_hero_info() const {
  return _set_hero_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::up::hero >*
gm_cmd::mutable__set_hero_info() {
  return &_set_hero_info_;
}

// optional int32 _set_vitality = 4;
inline bool gm_cmd::has__set_vitality() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gm_cmd::set_has__set_vitality() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gm_cmd::clear_has__set_vitality() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gm_cmd::clear__set_vitality() {
  _set_vitality_ = 0;
  clear_has__set_vitality();
}
inline ::google::protobuf::int32 gm_cmd::_set_vitality() const {
  return _set_vitality_;
}
inline void gm_cmd::set__set_vitality(::google::protobuf::int32 value) {
  set_has__set_vitality();
  _set_vitality_ = value;
}

// optional .up.set_money _set_money = 5;
inline bool gm_cmd::has__set_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gm_cmd::set_has__set_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gm_cmd::clear_has__set_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gm_cmd::clear__set_money() {
  if (_set_money_ != NULL) _set_money_->::up::set_money::Clear();
  clear_has__set_money();
}
inline const ::up::set_money& gm_cmd::_set_money() const {
  return _set_money_ != NULL ? *_set_money_ : *default_instance_->_set_money_;
}
inline ::up::set_money* gm_cmd::mutable__set_money() {
  set_has__set_money();
  if (_set_money_ == NULL) _set_money_ = new ::up::set_money;
  return _set_money_;
}
inline ::up::set_money* gm_cmd::release__set_money() {
  clear_has__set_money();
  ::up::set_money* temp = _set_money_;
  _set_money_ = NULL;
  return temp;
}
inline void gm_cmd::set_allocated__set_money(::up::set_money* _set_money) {
  delete _set_money_;
  _set_money_ = _set_money;
  if (_set_money) {
    set_has__set_money();
  } else {
    clear_has__set_money();
  }
}

// optional int32 _set_recharge_sum = 6;
inline bool gm_cmd::has__set_recharge_sum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gm_cmd::set_has__set_recharge_sum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gm_cmd::clear_has__set_recharge_sum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gm_cmd::clear__set_recharge_sum() {
  _set_recharge_sum_ = 0;
  clear_has__set_recharge_sum();
}
inline ::google::protobuf::int32 gm_cmd::_set_recharge_sum() const {
  return _set_recharge_sum_;
}
inline void gm_cmd::set__set_recharge_sum(::google::protobuf::int32 value) {
  set_has__set_recharge_sum();
  _set_recharge_sum_ = value;
}

// optional int32 _set_player_level = 7;
inline bool gm_cmd::has__set_player_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void gm_cmd::set_has__set_player_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void gm_cmd::clear_has__set_player_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void gm_cmd::clear__set_player_level() {
  _set_player_level_ = 0;
  clear_has__set_player_level();
}
inline ::google::protobuf::int32 gm_cmd::_set_player_level() const {
  return _set_player_level_;
}
inline void gm_cmd::set__set_player_level(::google::protobuf::int32 value) {
  set_has__set_player_level();
  _set_player_level_ = value;
}

// optional int32 _set_player_exp = 8;
inline bool gm_cmd::has__set_player_exp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void gm_cmd::set_has__set_player_exp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void gm_cmd::clear_has__set_player_exp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void gm_cmd::clear__set_player_exp() {
  _set_player_exp_ = 0;
  clear_has__set_player_exp();
}
inline ::google::protobuf::int32 gm_cmd::_set_player_exp() const {
  return _set_player_exp_;
}
inline void gm_cmd::set__set_player_exp(::google::protobuf::int32 value) {
  set_has__set_player_exp();
  _set_player_exp_ = value;
}

// repeated uint32 _set_items = 9;
inline int gm_cmd::_set_items_size() const {
  return _set_items_.size();
}
inline void gm_cmd::clear__set_items() {
  _set_items_.Clear();
}
inline ::google::protobuf::uint32 gm_cmd::_set_items(int index) const {
  return _set_items_.Get(index);
}
inline void gm_cmd::set__set_items(int index, ::google::protobuf::uint32 value) {
  _set_items_.Set(index, value);
}
inline void gm_cmd::add__set_items(::google::protobuf::uint32 value) {
  _set_items_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
gm_cmd::_set_items() const {
  return _set_items_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
gm_cmd::mutable__set_items() {
  return &_set_items_;
}

// optional uint32 _reset_device = 10;
inline bool gm_cmd::has__reset_device() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void gm_cmd::set_has__reset_device() {
  _has_bits_[0] |= 0x00000200u;
}
inline void gm_cmd::clear_has__reset_device() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void gm_cmd::clear__reset_device() {
  _reset_device_ = 0u;
  clear_has__reset_device();
}
inline ::google::protobuf::uint32 gm_cmd::_reset_device() const {
  return _reset_device_;
}
inline void gm_cmd::set__reset_device(::google::protobuf::uint32 value) {
  set_has__reset_device();
  _reset_device_ = value;
}

// optional uint32 _open_mystery_shop = 11;
inline bool gm_cmd::has__open_mystery_shop() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void gm_cmd::set_has__open_mystery_shop() {
  _has_bits_[0] |= 0x00000400u;
}
inline void gm_cmd::clear_has__open_mystery_shop() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void gm_cmd::clear__open_mystery_shop() {
  _open_mystery_shop_ = 0u;
  clear_has__open_mystery_shop();
}
inline ::google::protobuf::uint32 gm_cmd::_open_mystery_shop() const {
  return _open_mystery_shop_;
}
inline void gm_cmd::set__open_mystery_shop(::google::protobuf::uint32 value) {
  set_has__open_mystery_shop();
  _open_mystery_shop_ = value;
}

// optional uint32 _archive_id = 12;
inline bool gm_cmd::has__archive_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void gm_cmd::set_has__archive_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void gm_cmd::clear_has__archive_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void gm_cmd::clear__archive_id() {
  _archive_id_ = 0u;
  clear_has__archive_id();
}
inline ::google::protobuf::uint32 gm_cmd::_archive_id() const {
  return _archive_id_;
}
inline void gm_cmd::set__archive_id(::google::protobuf::uint32 value) {
  set_has__archive_id();
  _archive_id_ = value;
}

// optional uint32 _restore_id = 13;
inline bool gm_cmd::has__restore_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void gm_cmd::set_has__restore_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void gm_cmd::clear_has__restore_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void gm_cmd::clear__restore_id() {
  _restore_id_ = 0u;
  clear_has__restore_id();
}
inline ::google::protobuf::uint32 gm_cmd::_restore_id() const {
  return _restore_id_;
}
inline void gm_cmd::set__restore_id(::google::protobuf::uint32 value) {
  set_has__restore_id();
  _restore_id_ = value;
}

// optional int32 _reset_sweep = 14;
inline bool gm_cmd::has__reset_sweep() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void gm_cmd::set_has__reset_sweep() {
  _has_bits_[0] |= 0x00002000u;
}
inline void gm_cmd::clear_has__reset_sweep() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void gm_cmd::clear__reset_sweep() {
  _reset_sweep_ = 0;
  clear_has__reset_sweep();
}
inline ::google::protobuf::int32 gm_cmd::_reset_sweep() const {
  return _reset_sweep_;
}
inline void gm_cmd::set__reset_sweep(::google::protobuf::int32 value) {
  set_has__reset_sweep();
  _reset_sweep_ = value;
}

// optional uint32 _set_dailylogin_days = 15;
inline bool gm_cmd::has__set_dailylogin_days() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void gm_cmd::set_has__set_dailylogin_days() {
  _has_bits_[0] |= 0x00004000u;
}
inline void gm_cmd::clear_has__set_dailylogin_days() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void gm_cmd::clear__set_dailylogin_days() {
  _set_dailylogin_days_ = 0u;
  clear_has__set_dailylogin_days();
}
inline ::google::protobuf::uint32 gm_cmd::_set_dailylogin_days() const {
  return _set_dailylogin_days_;
}
inline void gm_cmd::set__set_dailylogin_days(::google::protobuf::uint32 value) {
  set_has__set_dailylogin_days();
  _set_dailylogin_days_ = value;
}

// optional .up.open_all_guild_stage _open_guild_stage = 16;
inline bool gm_cmd::has__open_guild_stage() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void gm_cmd::set_has__open_guild_stage() {
  _has_bits_[0] |= 0x00008000u;
}
inline void gm_cmd::clear_has__open_guild_stage() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void gm_cmd::clear__open_guild_stage() {
  if (_open_guild_stage_ != NULL) _open_guild_stage_->::up::open_all_guild_stage::Clear();
  clear_has__open_guild_stage();
}
inline const ::up::open_all_guild_stage& gm_cmd::_open_guild_stage() const {
  return _open_guild_stage_ != NULL ? *_open_guild_stage_ : *default_instance_->_open_guild_stage_;
}
inline ::up::open_all_guild_stage* gm_cmd::mutable__open_guild_stage() {
  set_has__open_guild_stage();
  if (_open_guild_stage_ == NULL) _open_guild_stage_ = new ::up::open_all_guild_stage;
  return _open_guild_stage_;
}
inline ::up::open_all_guild_stage* gm_cmd::release__open_guild_stage() {
  clear_has__open_guild_stage();
  ::up::open_all_guild_stage* temp = _open_guild_stage_;
  _open_guild_stage_ = NULL;
  return temp;
}
inline void gm_cmd::set_allocated__open_guild_stage(::up::open_all_guild_stage* _open_guild_stage) {
  delete _open_guild_stage_;
  _open_guild_stage_ = _open_guild_stage;
  if (_open_guild_stage) {
    set_has__open_guild_stage();
  } else {
    clear_has__open_guild_stage();
  }
}

// -------------------------------------------------------------------

// activity_info

// required string _player_name = 1;
inline bool activity_info::has__player_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void activity_info::set_has__player_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void activity_info::clear_has__player_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void activity_info::clear__player_name() {
  if (_player_name_ != &::google::protobuf::internal::kEmptyString) {
    _player_name_->clear();
  }
  clear_has__player_name();
}
inline const ::std::string& activity_info::_player_name() const {
  return *_player_name_;
}
inline void activity_info::set__player_name(const ::std::string& value) {
  set_has__player_name();
  if (_player_name_ == &::google::protobuf::internal::kEmptyString) {
    _player_name_ = new ::std::string;
  }
  _player_name_->assign(value);
}
inline void activity_info::set__player_name(const char* value) {
  set_has__player_name();
  if (_player_name_ == &::google::protobuf::internal::kEmptyString) {
    _player_name_ = new ::std::string;
  }
  _player_name_->assign(value);
}
inline void activity_info::set__player_name(const char* value, size_t size) {
  set_has__player_name();
  if (_player_name_ == &::google::protobuf::internal::kEmptyString) {
    _player_name_ = new ::std::string;
  }
  _player_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* activity_info::mutable__player_name() {
  set_has__player_name();
  if (_player_name_ == &::google::protobuf::internal::kEmptyString) {
    _player_name_ = new ::std::string;
  }
  return _player_name_;
}
inline ::std::string* activity_info::release__player_name() {
  clear_has__player_name();
  if (_player_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _player_name_;
    _player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void activity_info::set_allocated__player_name(::std::string* _player_name) {
  if (_player_name_ != &::google::protobuf::internal::kEmptyString) {
    delete _player_name_;
  }
  if (_player_name) {
    set_has__player_name();
    _player_name_ = _player_name;
  } else {
    clear_has__player_name();
    _player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 _version = 2;
inline bool activity_info::has__version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void activity_info::set_has__version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void activity_info::clear_has__version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void activity_info::clear__version() {
  _version_ = 0u;
  clear_has__version();
}
inline ::google::protobuf::uint32 activity_info::_version() const {
  return _version_;
}
inline void activity_info::set__version(::google::protobuf::uint32 value) {
  set_has__version();
  _version_ = value;
}

// -------------------------------------------------------------------

// activity_lotto_info

// required string _group_id = 1;
inline bool activity_lotto_info::has__group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void activity_lotto_info::set_has__group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void activity_lotto_info::clear_has__group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void activity_lotto_info::clear__group_id() {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    _group_id_->clear();
  }
  clear_has__group_id();
}
inline const ::std::string& activity_lotto_info::_group_id() const {
  return *_group_id_;
}
inline void activity_lotto_info::set__group_id(const ::std::string& value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_lotto_info::set__group_id(const char* value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_lotto_info::set__group_id(const char* value, size_t size) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* activity_lotto_info::mutable__group_id() {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  return _group_id_;
}
inline ::std::string* activity_lotto_info::release__group_id() {
  clear_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _group_id_;
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void activity_lotto_info::set_allocated__group_id(::std::string* _group_id) {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete _group_id_;
  }
  if (_group_id) {
    set_has__group_id();
    _group_id_ = _group_id;
  } else {
    clear_has__group_id();
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 _activity_id = 2;
inline bool activity_lotto_info::has__activity_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void activity_lotto_info::set_has__activity_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void activity_lotto_info::clear_has__activity_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void activity_lotto_info::clear__activity_id() {
  _activity_id_ = 0u;
  clear_has__activity_id();
}
inline ::google::protobuf::uint32 activity_lotto_info::_activity_id() const {
  return _activity_id_;
}
inline void activity_lotto_info::set__activity_id(::google::protobuf::uint32 value) {
  set_has__activity_id();
  _activity_id_ = value;
}

// -------------------------------------------------------------------

// activity_bigpackage_info

// required string _group_id = 1;
inline bool activity_bigpackage_info::has__group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void activity_bigpackage_info::set_has__group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void activity_bigpackage_info::clear_has__group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void activity_bigpackage_info::clear__group_id() {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    _group_id_->clear();
  }
  clear_has__group_id();
}
inline const ::std::string& activity_bigpackage_info::_group_id() const {
  return *_group_id_;
}
inline void activity_bigpackage_info::set__group_id(const ::std::string& value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_bigpackage_info::set__group_id(const char* value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_bigpackage_info::set__group_id(const char* value, size_t size) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* activity_bigpackage_info::mutable__group_id() {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  return _group_id_;
}
inline ::std::string* activity_bigpackage_info::release__group_id() {
  clear_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _group_id_;
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void activity_bigpackage_info::set_allocated__group_id(::std::string* _group_id) {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete _group_id_;
  }
  if (_group_id) {
    set_has__group_id();
    _group_id_ = _group_id;
  } else {
    clear_has__group_id();
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 _activity_id = 2;
inline bool activity_bigpackage_info::has__activity_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void activity_bigpackage_info::set_has__activity_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void activity_bigpackage_info::clear_has__activity_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void activity_bigpackage_info::clear__activity_id() {
  _activity_id_ = 0u;
  clear_has__activity_id();
}
inline ::google::protobuf::uint32 activity_bigpackage_info::_activity_id() const {
  return _activity_id_;
}
inline void activity_bigpackage_info::set__activity_id(::google::protobuf::uint32 value) {
  set_has__activity_id();
  _activity_id_ = value;
}

// -------------------------------------------------------------------

// activity_bigpackage_reward_info

// required string _group_id = 1;
inline bool activity_bigpackage_reward_info::has__group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void activity_bigpackage_reward_info::set_has__group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void activity_bigpackage_reward_info::clear_has__group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void activity_bigpackage_reward_info::clear__group_id() {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    _group_id_->clear();
  }
  clear_has__group_id();
}
inline const ::std::string& activity_bigpackage_reward_info::_group_id() const {
  return *_group_id_;
}
inline void activity_bigpackage_reward_info::set__group_id(const ::std::string& value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_bigpackage_reward_info::set__group_id(const char* value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_bigpackage_reward_info::set__group_id(const char* value, size_t size) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* activity_bigpackage_reward_info::mutable__group_id() {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  return _group_id_;
}
inline ::std::string* activity_bigpackage_reward_info::release__group_id() {
  clear_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _group_id_;
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void activity_bigpackage_reward_info::set_allocated__group_id(::std::string* _group_id) {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete _group_id_;
  }
  if (_group_id) {
    set_has__group_id();
    _group_id_ = _group_id;
  } else {
    clear_has__group_id();
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 _activity_id = 2;
inline bool activity_bigpackage_reward_info::has__activity_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void activity_bigpackage_reward_info::set_has__activity_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void activity_bigpackage_reward_info::clear_has__activity_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void activity_bigpackage_reward_info::clear__activity_id() {
  _activity_id_ = 0u;
  clear_has__activity_id();
}
inline ::google::protobuf::uint32 activity_bigpackage_reward_info::_activity_id() const {
  return _activity_id_;
}
inline void activity_bigpackage_reward_info::set__activity_id(::google::protobuf::uint32 value) {
  set_has__activity_id();
  _activity_id_ = value;
}

// required uint32 _box_id = 3;
inline bool activity_bigpackage_reward_info::has__box_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void activity_bigpackage_reward_info::set_has__box_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void activity_bigpackage_reward_info::clear_has__box_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void activity_bigpackage_reward_info::clear__box_id() {
  _box_id_ = 0u;
  clear_has__box_id();
}
inline ::google::protobuf::uint32 activity_bigpackage_reward_info::_box_id() const {
  return _box_id_;
}
inline void activity_bigpackage_reward_info::set__box_id(::google::protobuf::uint32 value) {
  set_has__box_id();
  _box_id_ = value;
}

// -------------------------------------------------------------------

// activity_bigpackage_reset

// required string _group_id = 1;
inline bool activity_bigpackage_reset::has__group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void activity_bigpackage_reset::set_has__group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void activity_bigpackage_reset::clear_has__group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void activity_bigpackage_reset::clear__group_id() {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    _group_id_->clear();
  }
  clear_has__group_id();
}
inline const ::std::string& activity_bigpackage_reset::_group_id() const {
  return *_group_id_;
}
inline void activity_bigpackage_reset::set__group_id(const ::std::string& value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_bigpackage_reset::set__group_id(const char* value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_bigpackage_reset::set__group_id(const char* value, size_t size) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* activity_bigpackage_reset::mutable__group_id() {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  return _group_id_;
}
inline ::std::string* activity_bigpackage_reset::release__group_id() {
  clear_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _group_id_;
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void activity_bigpackage_reset::set_allocated__group_id(::std::string* _group_id) {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete _group_id_;
  }
  if (_group_id) {
    set_has__group_id();
    _group_id_ = _group_id;
  } else {
    clear_has__group_id();
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 _activity_id = 2;
inline bool activity_bigpackage_reset::has__activity_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void activity_bigpackage_reset::set_has__activity_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void activity_bigpackage_reset::clear_has__activity_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void activity_bigpackage_reset::clear__activity_id() {
  _activity_id_ = 0u;
  clear_has__activity_id();
}
inline ::google::protobuf::uint32 activity_bigpackage_reset::_activity_id() const {
  return _activity_id_;
}
inline void activity_bigpackage_reset::set__activity_id(::google::protobuf::uint32 value) {
  set_has__activity_id();
  _activity_id_ = value;
}

// -------------------------------------------------------------------

// activity_lotto_reward

// required string _group_id = 1;
inline bool activity_lotto_reward::has__group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void activity_lotto_reward::set_has__group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void activity_lotto_reward::clear_has__group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void activity_lotto_reward::clear__group_id() {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    _group_id_->clear();
  }
  clear_has__group_id();
}
inline const ::std::string& activity_lotto_reward::_group_id() const {
  return *_group_id_;
}
inline void activity_lotto_reward::set__group_id(const ::std::string& value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_lotto_reward::set__group_id(const char* value) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(value);
}
inline void activity_lotto_reward::set__group_id(const char* value, size_t size) {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  _group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* activity_lotto_reward::mutable__group_id() {
  set_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    _group_id_ = new ::std::string;
  }
  return _group_id_;
}
inline ::std::string* activity_lotto_reward::release__group_id() {
  clear_has__group_id();
  if (_group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _group_id_;
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void activity_lotto_reward::set_allocated__group_id(::std::string* _group_id) {
  if (_group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete _group_id_;
  }
  if (_group_id) {
    set_has__group_id();
    _group_id_ = _group_id;
  } else {
    clear_has__group_id();
    _group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 _activity_id = 2;
inline bool activity_lotto_reward::has__activity_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void activity_lotto_reward::set_has__activity_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void activity_lotto_reward::clear_has__activity_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void activity_lotto_reward::clear__activity_id() {
  _activity_id_ = 0u;
  clear_has__activity_id();
}
inline ::google::protobuf::uint32 activity_lotto_reward::_activity_id() const {
  return _activity_id_;
}
inline void activity_lotto_reward::set__activity_id(::google::protobuf::uint32 value) {
  set_has__activity_id();
  _activity_id_ = value;
}

// -------------------------------------------------------------------

// open_all_guild_stage

// -------------------------------------------------------------------

// set_money

// required .up.set_money.price_type _type = 1;
inline bool set_money::has__type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void set_money::set_has__type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void set_money::clear_has__type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void set_money::clear__type() {
  _type_ = 0;
  clear_has__type();
}
inline ::up::set_money_price_type set_money::_type() const {
  return static_cast< ::up::set_money_price_type >(_type_);
}
inline void set_money::set__type(::up::set_money_price_type value) {
  assert(::up::set_money_price_type_IsValid(value));
  set_has__type();
  _type_ = value;
}

// required uint32 _amount = 2;
inline bool set_money::has__amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void set_money::set_has__amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void set_money::clear_has__amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void set_money::clear__amount() {
  _amount_ = 0u;
  clear_has__amount();
}
inline ::google::protobuf::uint32 set_money::_amount() const {
  return _amount_;
}
inline void set_money::set__amount(::google::protobuf::uint32 value) {
  set_has__amount();
  _amount_ = value;
}

// -------------------------------------------------------------------

// hero_upgrade

// required uint32 _hero_id = 1;
inline bool hero_upgrade::has__hero_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_upgrade::set_has__hero_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_upgrade::clear_has__hero_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_upgrade::clear__hero_id() {
  _hero_id_ = 0u;
  clear_has__hero_id();
}
inline ::google::protobuf::uint32 hero_upgrade::_hero_id() const {
  return _hero_id_;
}
inline void hero_upgrade::set__hero_id(::google::protobuf::uint32 value) {
  set_has__hero_id();
  _hero_id_ = value;
}

// -------------------------------------------------------------------

// equip_synthesis

// required uint32 _equip_id = 1;
inline bool equip_synthesis::has__equip_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void equip_synthesis::set_has__equip_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void equip_synthesis::clear_has__equip_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void equip_synthesis::clear__equip_id() {
  _equip_id_ = 0u;
  clear_has__equip_id();
}
inline ::google::protobuf::uint32 equip_synthesis::_equip_id() const {
  return _equip_id_;
}
inline void equip_synthesis::set__equip_id(::google::protobuf::uint32 value) {
  set_has__equip_id();
  _equip_id_ = value;
}

// -------------------------------------------------------------------

// wear_equip

// required uint32 _hero_id = 1;
inline bool wear_equip::has__hero_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void wear_equip::set_has__hero_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void wear_equip::clear_has__hero_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void wear_equip::clear__hero_id() {
  _hero_id_ = 0u;
  clear_has__hero_id();
}
inline ::google::protobuf::uint32 wear_equip::_hero_id() const {
  return _hero_id_;
}
inline void wear_equip::set__hero_id(::google::protobuf::uint32 value) {
  set_has__hero_id();
  _hero_id_ = value;
}

// required uint32 _item_pos = 2;
inline bool wear_equip::has__item_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void wear_equip::set_has__item_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void wear_equip::clear_has__item_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void wear_equip::clear__item_pos() {
  _item_pos_ = 0u;
  clear_has__item_pos();
}
inline ::google::protobuf::uint32 wear_equip::_item_pos() const {
  return _item_pos_;
}
inline void wear_equip::set__item_pos(::google::protobuf::uint32 value) {
  set_has__item_pos();
  _item_pos_ = value;
}

// -------------------------------------------------------------------

// sync_vitality

// -------------------------------------------------------------------

// buy_vitality

// -------------------------------------------------------------------

// consume_item

// required uint32 _hero_id = 1;
inline bool consume_item::has__hero_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void consume_item::set_has__hero_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void consume_item::clear_has__hero_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void consume_item::clear__hero_id() {
  _hero_id_ = 0u;
  clear_has__hero_id();
}
inline ::google::protobuf::uint32 consume_item::_hero_id() const {
  return _hero_id_;
}
inline void consume_item::set__hero_id(::google::protobuf::uint32 value) {
  set_has__hero_id();
  _hero_id_ = value;
}

// required uint32 _item_id = 2;
inline bool consume_item::has__item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void consume_item::set_has__item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void consume_item::clear_has__item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void consume_item::clear__item_id() {
  _item_id_ = 0u;
  clear_has__item_id();
}
inline ::google::protobuf::uint32 consume_item::_item_id() const {
  return _item_id_;
}
inline void consume_item::set__item_id(::google::protobuf::uint32 value) {
  set_has__item_id();
  _item_id_ = value;
}

// -------------------------------------------------------------------

// shop_refresh

// required .up.shop_refresh.rtype _type = 1 [default = sync];
inline bool shop_refresh::has__type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void shop_refresh::set_has__type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void shop_refresh::clear_has__type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void shop_refresh::clear__type() {
  _type_ = 0;
  clear_has__type();
}
inline ::up::shop_refresh_rtype shop_refresh::_type() const {
  return static_cast< ::up::shop_refresh_rtype >(_type_);
}
inline void shop_refresh::set__type(::up::shop_refresh_rtype value) {
  assert(::up::shop_refresh_rtype_IsValid(value));
  set_has__type();
  _type_ = value;
}

// required uint32 _shop_id = 2;
inline bool shop_refresh::has__shop_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void shop_refresh::set_has__shop_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void shop_refresh::clear_has__shop_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void shop_refresh::clear__shop_id() {
  _shop_id_ = 0u;
  clear_has__shop_id();
}
inline ::google::protobuf::uint32 shop_refresh::_shop_id() const {
  return _shop_id_;
}
inline void shop_refresh::set__shop_id(::google::protobuf::uint32 value) {
  set_has__shop_id();
  _shop_id_ = value;
}

// -------------------------------------------------------------------

// shop_consume

// required uint32 _sid = 1;
inline bool shop_consume::has__sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void shop_consume::set_has__sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void shop_consume::clear_has__sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void shop_consume::clear__sid() {
  _sid_ = 0u;
  clear_has__sid();
}
inline ::google::protobuf::uint32 shop_consume::_sid() const {
  return _sid_;
}
inline void shop_consume::set__sid(::google::protobuf::uint32 value) {
  set_has__sid();
  _sid_ = value;
}

// required uint32 _slotid = 2;
inline bool shop_consume::has__slotid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void shop_consume::set_has__slotid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void shop_consume::clear_has__slotid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void shop_consume::clear__slotid() {
  _slotid_ = 0u;
  clear_has__slotid();
}
inline ::google::protobuf::uint32 shop_consume::_slotid() const {
  return _slotid_;
}
inline void shop_consume::set__slotid(::google::protobuf::uint32 value) {
  set_has__slotid();
  _slotid_ = value;
}

// required uint32 _amount = 3;
inline bool shop_consume::has__amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void shop_consume::set_has__amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void shop_consume::clear_has__amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void shop_consume::clear__amount() {
  _amount_ = 0u;
  clear_has__amount();
}
inline ::google::protobuf::uint32 shop_consume::_amount() const {
  return _amount_;
}
inline void shop_consume::set__amount(::google::protobuf::uint32 value) {
  set_has__amount();
  _amount_ = value;
}

// -------------------------------------------------------------------

// skill_levelup

// required uint32 _heroid = 1;
inline bool skill_levelup::has__heroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skill_levelup::set_has__heroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skill_levelup::clear_has__heroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skill_levelup::clear__heroid() {
  _heroid_ = 0u;
  clear_has__heroid();
}
inline ::google::protobuf::uint32 skill_levelup::_heroid() const {
  return _heroid_;
}
inline void skill_levelup::set__heroid(::google::protobuf::uint32 value) {
  set_has__heroid();
  _heroid_ = value;
}

// repeated uint32 _order = 2;
inline int skill_levelup::_order_size() const {
  return _order_.size();
}
inline void skill_levelup::clear__order() {
  _order_.Clear();
}
inline ::google::protobuf::uint32 skill_levelup::_order(int index) const {
  return _order_.Get(index);
}
inline void skill_levelup::set__order(int index, ::google::protobuf::uint32 value) {
  _order_.Set(index, value);
}
inline void skill_levelup::add__order(::google::protobuf::uint32 value) {
  _order_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
skill_levelup::_order() const {
  return _order_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
skill_levelup::mutable__order() {
  return &_order_;
}

// -------------------------------------------------------------------

// sell_item

// repeated uint32 _item = 1;
inline int sell_item::_item_size() const {
  return _item_.size();
}
inline void sell_item::clear__item() {
  _item_.Clear();
}
inline ::google::protobuf::uint32 sell_item::_item(int index) const {
  return _item_.Get(index);
}
inline void sell_item::set__item(int index, ::google::protobuf::uint32 value) {
  _item_.Set(index, value);
}
inline void sell_item::add__item(::google::protobuf::uint32 value) {
  _item_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
sell_item::_item() const {
  return _item_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
sell_item::mutable__item() {
  return &_item_;
}

// -------------------------------------------------------------------

// fragment_compose

// required uint32 _fragment = 1;
inline bool fragment_compose::has__fragment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fragment_compose::set_has__fragment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fragment_compose::clear_has__fragment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fragment_compose::clear__fragment() {
  _fragment_ = 0u;
  clear_has__fragment();
}
inline ::google::protobuf::uint32 fragment_compose::_fragment() const {
  return _fragment_;
}
inline void fragment_compose::set__fragment(::google::protobuf::uint32 value) {
  set_has__fragment();
  _fragment_ = value;
}

// required uint32 _frag_amount = 2;
inline bool fragment_compose::has__frag_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fragment_compose::set_has__frag_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fragment_compose::clear_has__frag_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fragment_compose::clear__frag_amount() {
  _frag_amount_ = 0u;
  clear_has__frag_amount();
}
inline ::google::protobuf::uint32 fragment_compose::_frag_amount() const {
  return _frag_amount_;
}
inline void fragment_compose::set__frag_amount(::google::protobuf::uint32 value) {
  set_has__frag_amount();
  _frag_amount_ = value;
}

// -------------------------------------------------------------------

// hero_equip_upgrade

// required .up.hero_equip_upgrade.OP_TYPE _op_type = 1 [default = normal];
inline bool hero_equip_upgrade::has__op_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_equip_upgrade::set_has__op_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_equip_upgrade::clear_has__op_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_equip_upgrade::clear__op_type() {
  _op_type_ = 1;
  clear_has__op_type();
}
inline ::up::hero_equip_upgrade_OP_TYPE hero_equip_upgrade::_op_type() const {
  return static_cast< ::up::hero_equip_upgrade_OP_TYPE >(_op_type_);
}
inline void hero_equip_upgrade::set__op_type(::up::hero_equip_upgrade_OP_TYPE value) {
  assert(::up::hero_equip_upgrade_OP_TYPE_IsValid(value));
  set_has__op_type();
  _op_type_ = value;
}

// required uint32 _heroid = 2;
inline bool hero_equip_upgrade::has__heroid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_equip_upgrade::set_has__heroid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_equip_upgrade::clear_has__heroid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_equip_upgrade::clear__heroid() {
  _heroid_ = 0u;
  clear_has__heroid();
}
inline ::google::protobuf::uint32 hero_equip_upgrade::_heroid() const {
  return _heroid_;
}
inline void hero_equip_upgrade::set__heroid(::google::protobuf::uint32 value) {
  set_has__heroid();
  _heroid_ = value;
}

// required uint32 _slot = 3;
inline bool hero_equip_upgrade::has__slot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero_equip_upgrade::set_has__slot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero_equip_upgrade::clear_has__slot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero_equip_upgrade::clear__slot() {
  _slot_ = 0u;
  clear_has__slot();
}
inline ::google::protobuf::uint32 hero_equip_upgrade::_slot() const {
  return _slot_;
}
inline void hero_equip_upgrade::set__slot(::google::protobuf::uint32 value) {
  set_has__slot();
  _slot_ = value;
}

// repeated uint32 _materials = 4;
inline int hero_equip_upgrade::_materials_size() const {
  return _materials_.size();
}
inline void hero_equip_upgrade::clear__materials() {
  _materials_.Clear();
}
inline ::google::protobuf::uint32 hero_equip_upgrade::_materials(int index) const {
  return _materials_.Get(index);
}
inline void hero_equip_upgrade::set__materials(int index, ::google::protobuf::uint32 value) {
  _materials_.Set(index, value);
}
inline void hero_equip_upgrade::add__materials(::google::protobuf::uint32 value) {
  _materials_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
hero_equip_upgrade::_materials() const {
  return _materials_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
hero_equip_upgrade::mutable__materials() {
  return &_materials_;
}

// -------------------------------------------------------------------

// hero_equip

// required uint32 _index = 1;
inline bool hero_equip::has__index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_equip::set_has__index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_equip::clear_has__index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_equip::clear__index() {
  _index_ = 0u;
  clear_has__index();
}
inline ::google::protobuf::uint32 hero_equip::_index() const {
  return _index_;
}
inline void hero_equip::set__index(::google::protobuf::uint32 value) {
  set_has__index();
  _index_ = value;
}

// required uint32 _item_id = 2;
inline bool hero_equip::has__item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_equip::set_has__item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_equip::clear_has__item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_equip::clear__item_id() {
  _item_id_ = 0u;
  clear_has__item_id();
}
inline ::google::protobuf::uint32 hero_equip::_item_id() const {
  return _item_id_;
}
inline void hero_equip::set__item_id(::google::protobuf::uint32 value) {
  set_has__item_id();
  _item_id_ = value;
}

// required uint32 _exp = 3;
inline bool hero_equip::has__exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero_equip::set_has__exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero_equip::clear_has__exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero_equip::clear__exp() {
  _exp_ = 0u;
  clear_has__exp();
}
inline ::google::protobuf::uint32 hero_equip::_exp() const {
  return _exp_;
}
inline void hero_equip::set__exp(::google::protobuf::uint32 value) {
  set_has__exp();
  _exp_ = value;
}

// -------------------------------------------------------------------

// hero

// required uint32 _tid = 1;
inline bool hero::has__tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero::set_has__tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero::clear_has__tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero::clear__tid() {
  _tid_ = 0u;
  clear_has__tid();
}
inline ::google::protobuf::uint32 hero::_tid() const {
  return _tid_;
}
inline void hero::set__tid(::google::protobuf::uint32 value) {
  set_has__tid();
  _tid_ = value;
}

// optional uint32 _rank = 2;
inline bool hero::has__rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero::set_has__rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero::clear_has__rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero::clear__rank() {
  _rank_ = 0u;
  clear_has__rank();
}
inline ::google::protobuf::uint32 hero::_rank() const {
  return _rank_;
}
inline void hero::set__rank(::google::protobuf::uint32 value) {
  set_has__rank();
  _rank_ = value;
}

// required uint32 _level = 3;
inline bool hero::has__level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero::set_has__level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero::clear_has__level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero::clear__level() {
  _level_ = 0u;
  clear_has__level();
}
inline ::google::protobuf::uint32 hero::_level() const {
  return _level_;
}
inline void hero::set__level(::google::protobuf::uint32 value) {
  set_has__level();
  _level_ = value;
}

// required uint32 _stars = 4;
inline bool hero::has__stars() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void hero::set_has__stars() {
  _has_bits_[0] |= 0x00000008u;
}
inline void hero::clear_has__stars() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void hero::clear__stars() {
  _stars_ = 0u;
  clear_has__stars();
}
inline ::google::protobuf::uint32 hero::_stars() const {
  return _stars_;
}
inline void hero::set__stars(::google::protobuf::uint32 value) {
  set_has__stars();
  _stars_ = value;
}

// required uint32 _exp = 5;
inline bool hero::has__exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void hero::set_has__exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void hero::clear_has__exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void hero::clear__exp() {
  _exp_ = 0u;
  clear_has__exp();
}
inline ::google::protobuf::uint32 hero::_exp() const {
  return _exp_;
}
inline void hero::set__exp(::google::protobuf::uint32 value) {
  set_has__exp();
  _exp_ = value;
}

// required uint32 _gs = 6;
inline bool hero::has__gs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void hero::set_has__gs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void hero::clear_has__gs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void hero::clear__gs() {
  _gs_ = 0u;
  clear_has__gs();
}
inline ::google::protobuf::uint32 hero::_gs() const {
  return _gs_;
}
inline void hero::set__gs(::google::protobuf::uint32 value) {
  set_has__gs();
  _gs_ = value;
}

// required .up.hero_status _state = 7;
inline bool hero::has__state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void hero::set_has__state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void hero::clear_has__state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void hero::clear__state() {
  _state_ = 0;
  clear_has__state();
}
inline ::up::hero_status hero::_state() const {
  return static_cast< ::up::hero_status >(_state_);
}
inline void hero::set__state(::up::hero_status value) {
  assert(::up::hero_status_IsValid(value));
  set_has__state();
  _state_ = value;
}

// repeated uint32 _skill_levels = 8;
inline int hero::_skill_levels_size() const {
  return _skill_levels_.size();
}
inline void hero::clear__skill_levels() {
  _skill_levels_.Clear();
}
inline ::google::protobuf::uint32 hero::_skill_levels(int index) const {
  return _skill_levels_.Get(index);
}
inline void hero::set__skill_levels(int index, ::google::protobuf::uint32 value) {
  _skill_levels_.Set(index, value);
}
inline void hero::add__skill_levels(::google::protobuf::uint32 value) {
  _skill_levels_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
hero::_skill_levels() const {
  return _skill_levels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
hero::mutable__skill_levels() {
  return &_skill_levels_;
}

// repeated .up.hero_equip _items = 9;
inline int hero::_items_size() const {
  return _items_.size();
}
inline void hero::clear__items() {
  _items_.Clear();
}
inline const ::up::hero_equip& hero::_items(int index) const {
  return _items_.Get(index);
}
inline ::up::hero_equip* hero::mutable__items(int index) {
  return _items_.Mutable(index);
}
inline ::up::hero_equip* hero::add__items() {
  return _items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::up::hero_equip >&
hero::_items() const {
  return _items_;
}
inline ::google::protobuf::RepeatedPtrField< ::up::hero_equip >*
hero::mutable__items() {
  return &_items_;
}

// optional .up.hero_arousal _arousal = 10;
inline bool hero::has__arousal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void hero::set_has__arousal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void hero::clear_has__arousal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void hero::clear__arousal() {
  if (_arousal_ != NULL) _arousal_->::up::hero_arousal::Clear();
  clear_has__arousal();
}
inline const ::up::hero_arousal& hero::_arousal() const {
  return _arousal_ != NULL ? *_arousal_ : *default_instance_->_arousal_;
}
inline ::up::hero_arousal* hero::mutable__arousal() {
  set_has__arousal();
  if (_arousal_ == NULL) _arousal_ = new ::up::hero_arousal;
  return _arousal_;
}
inline ::up::hero_arousal* hero::release__arousal() {
  clear_has__arousal();
  ::up::hero_arousal* temp = _arousal_;
  _arousal_ = NULL;
  return temp;
}
inline void hero::set_allocated__arousal(::up::hero_arousal* _arousal) {
  delete _arousal_;
  _arousal_ = _arousal;
  if (_arousal) {
    set_has__arousal();
  } else {
    clear_has__arousal();
  }
}

// -------------------------------------------------------------------

// hero_arousal

// required uint32 _status = 1;
inline bool hero_arousal::has__status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_arousal::set_has__status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_arousal::clear_has__status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_arousal::clear__status() {
  _status_ = 0u;
  clear_has__status();
}
inline ::google::protobuf::uint32 hero_arousal::_status() const {
  return _status_;
}
inline void hero_arousal::set__status(::google::protobuf::uint32 value) {
  set_has__status();
  _status_ = value;
}

// required uint32 _str = 2;
inline bool hero_arousal::has__str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_arousal::set_has__str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_arousal::clear_has__str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_arousal::clear__str() {
  _str_ = 0u;
  clear_has__str();
}
inline ::google::protobuf::uint32 hero_arousal::_str() const {
  return _str_;
}
inline void hero_arousal::set__str(::google::protobuf::uint32 value) {
  set_has__str();
  _str_ = value;
}

// required uint32 _agi = 3;
inline bool hero_arousal::has__agi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero_arousal::set_has__agi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero_arousal::clear_has__agi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero_arousal::clear__agi() {
  _agi_ = 0u;
  clear_has__agi();
}
inline ::google::protobuf::uint32 hero_arousal::_agi() const {
  return _agi_;
}
inline void hero_arousal::set__agi(::google::protobuf::uint32 value) {
  set_has__agi();
  _agi_ = value;
}

// required uint32 _int = 4;
inline bool hero_arousal::has__int() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void hero_arousal::set_has__int() {
  _has_bits_[0] |= 0x00000008u;
}
inline void hero_arousal::clear_has__int() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void hero_arousal::clear__int() {
  _int_ = 0u;
  clear_has__int();
}
inline ::google::protobuf::uint32 hero_arousal::_int() const {
  return _int_;
}
inline void hero_arousal::set__int(::google::protobuf::uint32 value) {
  set_has__int();
  _int_ = value;
}

// required int32 _str_var = 5;
inline bool hero_arousal::has__str_var() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void hero_arousal::set_has__str_var() {
  _has_bits_[0] |= 0x00000010u;
}
inline void hero_arousal::clear_has__str_var() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void hero_arousal::clear__str_var() {
  _str_var_ = 0;
  clear_has__str_var();
}
inline ::google::protobuf::int32 hero_arousal::_str_var() const {
  return _str_var_;
}
inline void hero_arousal::set__str_var(::google::protobuf::int32 value) {
  set_has__str_var();
  _str_var_ = value;
}

// required int32 _agi_var = 6;
inline bool hero_arousal::has__agi_var() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void hero_arousal::set_has__agi_var() {
  _has_bits_[0] |= 0x00000020u;
}
inline void hero_arousal::clear_has__agi_var() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void hero_arousal::clear__agi_var() {
  _agi_var_ = 0;
  clear_has__agi_var();
}
inline ::google::protobuf::int32 hero_arousal::_agi_var() const {
  return _agi_var_;
}
inline void hero_arousal::set__agi_var(::google::protobuf::int32 value) {
  set_has__agi_var();
  _agi_var_ = value;
}

// required int32 _int_var = 7;
inline bool hero_arousal::has__int_var() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void hero_arousal::set_has__int_var() {
  _has_bits_[0] |= 0x00000040u;
}
inline void hero_arousal::clear_has__int_var() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void hero_arousal::clear__int_var() {
  _int_var_ = 0;
  clear_has__int_var();
}
inline ::google::protobuf::int32 hero_arousal::_int_var() const {
  return _int_var_;
}
inline void hero_arousal::set__int_var(::google::protobuf::int32 value) {
  set_has__int_var();
  _int_var_ = value;
}

// required uint32 _cost_gold = 8;
inline bool hero_arousal::has__cost_gold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void hero_arousal::set_has__cost_gold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void hero_arousal::clear_has__cost_gold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void hero_arousal::clear__cost_gold() {
  _cost_gold_ = 0u;
  clear_has__cost_gold();
}
inline ::google::protobuf::uint32 hero_arousal::_cost_gold() const {
  return _cost_gold_;
}
inline void hero_arousal::set__cost_gold(::google::protobuf::uint32 value) {
  set_has__cost_gold();
  _cost_gold_ = value;
}

// required uint32 _cost_diamond = 9;
inline bool hero_arousal::has__cost_diamond() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void hero_arousal::set_has__cost_diamond() {
  _has_bits_[0] |= 0x00000100u;
}
inline void hero_arousal::clear_has__cost_diamond() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void hero_arousal::clear__cost_diamond() {
  _cost_diamond_ = 0u;
  clear_has__cost_diamond();
}
inline ::google::protobuf::uint32 hero_arousal::_cost_diamond() const {
  return _cost_diamond_;
}
inline void hero_arousal::set__cost_diamond(::google::protobuf::uint32 value) {
  set_has__cost_diamond();
  _cost_diamond_ = value;
}

// required uint32 _aro_exp = 10;
inline bool hero_arousal::has__aro_exp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void hero_arousal::set_has__aro_exp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void hero_arousal::clear_has__aro_exp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void hero_arousal::clear__aro_exp() {
  _aro_exp_ = 0u;
  clear_has__aro_exp();
}
inline ::google::protobuf::uint32 hero_arousal::_aro_exp() const {
  return _aro_exp_;
}
inline void hero_arousal::set__aro_exp(::google::protobuf::uint32 value) {
  set_has__aro_exp();
  _aro_exp_ = value;
}

// -------------------------------------------------------------------

// tutorial

// repeated uint32 _record = 1;
inline int tutorial::_record_size() const {
  return _record_.size();
}
inline void tutorial::clear__record() {
  _record_.Clear();
}
inline ::google::protobuf::uint32 tutorial::_record(int index) const {
  return _record_.Get(index);
}
inline void tutorial::set__record(int index, ::google::protobuf::uint32 value) {
  _record_.Set(index, value);
}
inline void tutorial::add__record(::google::protobuf::uint32 value) {
  _record_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
tutorial::_record() const {
  return _record_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
tutorial::mutable__record() {
  return &_record_;
}

// -------------------------------------------------------------------

// trigger_task

// repeated uint32 _task = 1;
inline int trigger_task::_task_size() const {
  return _task_.size();
}
inline void trigger_task::clear__task() {
  _task_.Clear();
}
inline ::google::protobuf::uint32 trigger_task::_task(int index) const {
  return _task_.Get(index);
}
inline void trigger_task::set__task(int index, ::google::protobuf::uint32 value) {
  _task_.Set(index, value);
}
inline void trigger_task::add__task(::google::protobuf::uint32 value) {
  _task_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
trigger_task::_task() const {
  return _task_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
trigger_task::mutable__task() {
  return &_task_;
}

// -------------------------------------------------------------------

// require_rewards

// required uint32 _line = 1;
inline bool require_rewards::has__line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void require_rewards::set_has__line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void require_rewards::clear_has__line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void require_rewards::clear__line() {
  _line_ = 0u;
  clear_has__line();
}
inline ::google::protobuf::uint32 require_rewards::_line() const {
  return _line_;
}
inline void require_rewards::set__line(::google::protobuf::uint32 value) {
  set_has__line();
  _line_ = value;
}

// required uint32 _id = 2;
inline bool require_rewards::has__id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void require_rewards::set_has__id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void require_rewards::clear_has__id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void require_rewards::clear__id() {
  _id_ = 0u;
  clear_has__id();
}
inline ::google::protobuf::uint32 require_rewards::_id() const {
  return _id_;
}
inline void require_rewards::set__id(::google::protobuf::uint32 value) {
  set_has__id();
  _id_ = value;
}

// -------------------------------------------------------------------

// change_task_status

// required uint32 _line = 1;
inline bool change_task_status::has__line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void change_task_status::set_has__line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void change_task_status::clear_has__line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void change_task_status::clear__line() {
  _line_ = 0u;
  clear_has__line();
}
inline ::google::protobuf::uint32 change_task_status::_line() const {
  return _line_;
}
inline void change_task_status::set__line(::google::protobuf::uint32 value) {
  set_has__line();
  _line_ = value;
}

// required uint32 _id = 2;
inline bool change_task_status::has__id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void change_task_status::set_has__id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void change_task_status::clear_has__id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void change_task_status::clear__id() {
  _id_ = 0u;
  clear_has__id();
}
inline ::google::protobuf::uint32 change_task_status::_id() const {
  return _id_;
}
inline void change_task_status::set__id(::google::protobuf::uint32 value) {
  set_has__id();
  _id_ = value;
}

// required uint32 _operation = 3;
inline bool change_task_status::has__operation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void change_task_status::set_has__operation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void change_task_status::clear_has__operation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void change_task_status::clear__operation() {
  _operation_ = 0u;
  clear_has__operation();
}
inline ::google::protobuf::uint32 change_task_status::_operation() const {
  return _operation_;
}
inline void change_task_status::set__operation(::google::protobuf::uint32 value) {
  set_has__operation();
  _operation_ = value;
}

// -------------------------------------------------------------------

// trigger_job

// repeated uint32 _jobs = 1;
inline int trigger_job::_jobs_size() const {
  return _jobs_.size();
}
inline void trigger_job::clear__jobs() {
  _jobs_.Clear();
}
inline ::google::protobuf::uint32 trigger_job::_jobs(int index) const {
  return _jobs_.Get(index);
}
inline void trigger_job::set__jobs(int index, ::google::protobuf::uint32 value) {
  _jobs_.Set(index, value);
}
inline void trigger_job::add__jobs(::google::protobuf::uint32 value) {
  _jobs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
trigger_job::_jobs() const {
  return _jobs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
trigger_job::mutable__jobs() {
  return &_jobs_;
}

// -------------------------------------------------------------------

// job_rewards

// required uint32 _job = 1;
inline bool job_rewards::has__job() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void job_rewards::set_has__job() {
  _has_bits_[0] |= 0x00000001u;
}
inline void job_rewards::clear_has__job() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void job_rewards::clear__job() {
  _job_ = 0u;
  clear_has__job();
}
inline ::google::protobuf::uint32 job_rewards::_job() const {
  return _job_;
}
inline void job_rewards::set__job(::google::protobuf::uint32 value) {
  set_has__job();
  _job_ = value;
}

// -------------------------------------------------------------------

// suspend_report

// required uint32 _gametime = 1;
inline bool suspend_report::has__gametime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void suspend_report::set_has__gametime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void suspend_report::clear_has__gametime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void suspend_report::clear__gametime() {
  _gametime_ = 0u;
  clear_has__gametime();
}
inline ::google::protobuf::uint32 suspend_report::_gametime() const {
  return _gametime_;
}
inline void suspend_report::set__gametime(::google::protobuf::uint32 value) {
  set_has__gametime();
  _gametime_ = value;
}

// -------------------------------------------------------------------

// reset_elite

// required .up.reset_elite.rtype _type = 1 [default = daily_free];
inline bool reset_elite::has__type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reset_elite::set_has__type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reset_elite::clear_has__type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reset_elite::clear__type() {
  _type_ = 0;
  clear_has__type();
}
inline ::up::reset_elite_rtype reset_elite::_type() const {
  return static_cast< ::up::reset_elite_rtype >(_type_);
}
inline void reset_elite::set__type(::up::reset_elite_rtype value) {
  assert(::up::reset_elite_rtype_IsValid(value));
  set_has__type();
  _type_ = value;
}

// optional uint32 _stageid = 2;
inline bool reset_elite::has__stageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void reset_elite::set_has__stageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void reset_elite::clear_has__stageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void reset_elite::clear__stageid() {
  _stageid_ = 0u;
  clear_has__stageid();
}
inline ::google::protobuf::uint32 reset_elite::_stageid() const {
  return _stageid_;
}
inline void reset_elite::set__stageid(::google::protobuf::uint32 value) {
  set_has__stageid();
  _stageid_ = value;
}

// -------------------------------------------------------------------

// sweep_stage

// required .up.sweep_stage.rtype _type = 1;
inline bool sweep_stage::has__type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sweep_stage::set_has__type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sweep_stage::clear_has__type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sweep_stage::clear__type() {
  _type_ = 0;
  clear_has__type();
}
inline ::up::sweep_stage_rtype sweep_stage::_type() const {
  return static_cast< ::up::sweep_stage_rtype >(_type_);
}
inline void sweep_stage::set__type(::up::sweep_stage_rtype value) {
  assert(::up::sweep_stage_rtype_IsValid(value));
  set_has__type();
  _type_ = value;
}

// required uint32 _stageid = 2;
inline bool sweep_stage::has__stageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sweep_stage::set_has__stageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sweep_stage::clear_has__stageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sweep_stage::clear__stageid() {
  _stageid_ = 0u;
  clear_has__stageid();
}
inline ::google::protobuf::uint32 sweep_stage::_stageid() const {
  return _stageid_;
}
inline void sweep_stage::set__stageid(::google::protobuf::uint32 value) {
  set_has__stageid();
  _stageid_ = value;
}

// optional uint32 _times = 3;
inline bool sweep_stage::has__times() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sweep_stage::set_has__times() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sweep_stage::clear_has__times() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sweep_stage::clear__times() {
  _times_ = 0u;
  clear_has__times();
}
inline ::google::protobuf::uint32 sweep_stage::_times() const {
  return _times_;
}
inline void sweep_stage::set__times(::google::protobuf::uint32 value) {
  set_has__times();
  _times_ = value;
}

// -------------------------------------------------------------------

// buy_skill_stren_point

// -------------------------------------------------------------------

// ask_magicsoul

// -------------------------------------------------------------------

// tavern_draw

// required .up.tavern_draw.draw_type _draw_type = 1 [default = single];
inline bool tavern_draw::has__draw_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tavern_draw::set_has__draw_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tavern_draw::clear_has__draw_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tavern_draw::clear__draw_type() {
  _draw_type_ = 0;
  clear_has__draw_type();
}
inline ::up::tavern_draw_draw_type tavern_draw::_draw_type() const {
  return static_cast< ::up::tavern_draw_draw_type >(_draw_type_);
}
inline void tavern_draw::set__draw_type(::up::tavern_draw_draw_type value) {
  assert(::up::tavern_draw_draw_type_IsValid(value));
  set_has__draw_type();
  _draw_type_ = value;
}

// required .up.tavern_draw.box_type _box_type = 2 [default = green];
inline bool tavern_draw::has__box_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tavern_draw::set_has__box_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tavern_draw::clear_has__box_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tavern_draw::clear__box_type() {
  _box_type_ = 1;
  clear_has__box_type();
}
inline ::up::tavern_draw_box_type tavern_draw::_box_type() const {
  return static_cast< ::up::tavern_draw_box_type >(_box_type_);
}
inline void tavern_draw::set__box_type(::up::tavern_draw_box_type value) {
  assert(::up::tavern_draw_box_type_IsValid(value));
  set_has__box_type();
  _box_type_ = value;
}

// -------------------------------------------------------------------

// hero_evolve

// required uint32 _heroid = 1;
inline bool hero_evolve::has__heroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_evolve::set_has__heroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_evolve::clear_has__heroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_evolve::clear__heroid() {
  _heroid_ = 0u;
  clear_has__heroid();
}
inline ::google::protobuf::uint32 hero_evolve::_heroid() const {
  return _heroid_;
}
inline void hero_evolve::set__heroid(::google::protobuf::uint32 value) {
  set_has__heroid();
  _heroid_ = value;
}

// -------------------------------------------------------------------

// enter_act_stage

// required uint32 _stage_group = 1;
inline bool enter_act_stage::has__stage_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void enter_act_stage::set_has__stage_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void enter_act_stage::clear_has__stage_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void enter_act_stage::clear__stage_group() {
  _stage_group_ = 0u;
  clear_has__stage_group();
}
inline ::google::protobuf::uint32 enter_act_stage::_stage_group() const {
  return _stage_group_;
}
inline void enter_act_stage::set__stage_group(::google::protobuf::uint32 value) {
  set_has__stage_group();
  _stage_group_ = value;
}

// required uint32 _stage = 2;
inline bool enter_act_stage::has__stage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void enter_act_stage::set_has__stage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void enter_act_stage::clear_has__stage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void enter_act_stage::clear__stage() {
  _stage_ = 0u;
  clear_has__stage();
}
inline ::google::protobuf::uint32 enter_act_stage::_stage() const {
  return _stage_;
}
inline void enter_act_stage::set__stage(::google::protobuf::uint32 value) {
  set_has__stage();
  _stage_ = value;
}

// -------------------------------------------------------------------

// ladder

// optional .up.open_panel _open_panel = 1;
inline bool ladder::has__open_panel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ladder::set_has__open_panel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ladder::clear_has__open_panel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ladder::clear__open_panel() {
  if (_open_panel_ != NULL) _open_panel_->::up::open_panel::Clear();
  clear_has__open_panel();
}
inline const ::up::open_panel& ladder::_open_panel() const {
  return _open_panel_ != NULL ? *_open_panel_ : *default_instance_->_open_panel_;
}
inline ::up::open_panel* ladder::mutable__open_panel() {
  set_has__open_panel();
  if (_open_panel_ == NULL) _open_panel_ = new ::up::open_panel;
  return _open_panel_;
}
inline ::up::open_panel* ladder::release__open_panel() {
  clear_has__open_panel();
  ::up::open_panel* temp = _open_panel_;
  _open_panel_ = NULL;
  return temp;
}
inline void ladder::set_allocated__open_panel(::up::open_panel* _open_panel) {
  delete _open_panel_;
  _open_panel_ = _open_panel;
  if (_open_panel) {
    set_has__open_panel();
  } else {
    clear_has__open_panel();
  }
}

// optional .up.apply_opponent _apply_opponent = 2;
inline bool ladder::has__apply_opponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ladder::set_has__apply_opponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ladder::clear_has__apply_opponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ladder::clear__apply_opponent() {
  if (_apply_opponent_ != NULL) _apply_opponent_->::up::apply_opponent::Clear();
  clear_has__apply_opponent();
}
inline const ::up::apply_opponent& ladder::_apply_opponent() const {
  return _apply_opponent_ != NULL ? *_apply_opponent_ : *default_instance_->_apply_opponent_;
}
inline ::up::apply_opponent* ladder::mutable__apply_opponent() {
  set_has__apply_opponent();
  if (_apply_opponent_ == NULL) _apply_opponent_ = new ::up::apply_opponent;
  return _apply_opponent_;
}
inline ::up::apply_opponent* ladder::release__apply_opponent() {
  clear_has__apply_opponent();
  ::up::apply_opponent* temp = _apply_opponent_;
  _apply_opponent_ = NULL;
  return temp;
}
inline void ladder::set_allocated__apply_opponent(::up::apply_opponent* _apply_opponent) {
  delete _apply_opponent_;
  _apply_opponent_ = _apply_opponent;
  if (_apply_opponent) {
    set_has__apply_opponent();
  } else {
    clear_has__apply_opponent();
  }
}

// optional .up.start_battle _start_battle = 3;
inline bool ladder::has__start_battle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ladder::set_has__start_battle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ladder::clear_has__start_battle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ladder::clear__start_battle() {
  if (_start_battle_ != NULL) _start_battle_->::up::start_battle::Clear();
  clear_has__start_battle();
}
inline const ::up::start_battle& ladder::_start_battle() const {
  return _start_battle_ != NULL ? *_start_battle_ : *default_instance_->_start_battle_;
}
inline ::up::start_battle* ladder::mutable__start_battle() {
  set_has__start_battle();
  if (_start_battle_ == NULL) _start_battle_ = new ::up::start_battle;
  return _start_battle_;
}
inline ::up::start_battle* ladder::release__start_battle() {
  clear_has__start_battle();
  ::up::start_battle* temp = _start_battle_;
  _start_battle_ = NULL;
  return temp;
}
inline void ladder::set_allocated__start_battle(::up::start_battle* _start_battle) {
  delete _start_battle_;
  _start_battle_ = _start_battle;
  if (_start_battle) {
    set_has__start_battle();
  } else {
    clear_has__start_battle();
  }
}

// optional .up.end_battle _end_battle = 4;
inline bool ladder::has__end_battle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ladder::set_has__end_battle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ladder::clear_has__end_battle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ladder::clear__end_battle() {
  if (_end_battle_ != NULL) _end_battle_->::up::end_battle::Clear();
  clear_has__end_battle();
}
inline const ::up::end_battle& ladder::_end_battle() const {
  return _end_battle_ != NULL ? *_end_battle_ : *default_instance_->_end_battle_;
}
inline ::up::end_battle* ladder::mutable__end_battle() {
  set_has__end_battle();
  if (_end_battle_ == NULL) _end_battle_ = new ::up::end_battle;
  return _end_battle_;
}
inline ::up::end_battle* ladder::release__end_battle() {
  clear_has__end_battle();
  ::up::end_battle* temp = _end_battle_;
  _end_battle_ = NULL;
  return temp;
}
inline void ladder::set_allocated__end_battle(::up::end_battle* _end_battle) {
  delete _end_battle_;
  _end_battle_ = _end_battle;
  if (_end_battle) {
    set_has__end_battle();
  } else {
    clear_has__end_battle();
  }
}

// optional .up.set_lineup _set_lineup = 5;
inline bool ladder::has__set_lineup() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ladder::set_has__set_lineup() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ladder::clear_has__set_lineup() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ladder::clear__set_lineup() {
  if (_set_lineup_ != NULL) _set_lineup_->::up::set_lineup::Clear();
  clear_has__set_lineup();
}
inline const ::up::set_lineup& ladder::_set_lineup() const {
  return _set_lineup_ != NULL ? *_set_lineup_ : *default_instance_->_set_lineup_;
}
inline ::up::set_lineup* ladder::mutable__set_lineup() {
  set_has__set_lineup();
  if (_set_lineup_ == NULL) _set_lineup_ = new ::up::set_lineup;
  return _set_lineup_;
}
inline ::up::set_lineup* ladder::release__set_lineup() {
  clear_has__set_lineup();
  ::up::set_lineup* temp = _set_lineup_;
  _set_lineup_ = NULL;
  return temp;
}
inline void ladder::set_allocated__set_lineup(::up::set_lineup* _set_lineup) {
  delete _set_lineup_;
  _set_lineup_ = _set_lineup;
  if (_set_lineup) {
    set_has__set_lineup();
  } else {
    clear_has__set_lineup();
  }
}

// optional .up.query_records _query_records = 6;
inline bool ladder::has__query_records() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ladder::set_has__query_records() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ladder::clear_has__query_records() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ladder::clear__query_records() {
  if (_query_records_ != NULL) _query_records_->::up::query_records::Clear();
  clear_has__query_records();
}
inline const ::up::query_records& ladder::_query_records() const {
  return _query_records_ != NULL ? *_query_records_ : *default_instance_->_query_records_;
}
inline ::up::query_records* ladder::mutable__query_records() {
  set_has__query_records();
  if (_query_records_ == NULL) _query_records_ = new ::up::query_records;
  return _query_records_;
}
inline ::up::query_records* ladder::release__query_records() {
  clear_has__query_records();
  ::up::query_records* temp = _query_records_;
  _query_records_ = NULL;
  return temp;
}
inline void ladder::set_allocated__query_records(::up::query_records* _query_records) {
  delete _query_records_;
  _query_records_ = _query_records;
  if (_query_records) {
    set_has__query_records();
  } else {
    clear_has__query_records();
  }
}

// optional .up.query_replay _query_replay = 7;
inline bool ladder::has__query_replay() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ladder::set_has__query_replay() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ladder::clear_has__query_replay() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ladder::clear__query_replay() {
  if (_query_replay_ != NULL) _query_replay_->::up::query_replay::Clear();
  clear_has__query_replay();
}
inline const ::up::query_replay& ladder::_query_replay() const {
  return _query_replay_ != NULL ? *_query_replay_ : *default_instance_->_query_replay_;
}
inline ::up::query_replay* ladder::mutable__query_replay() {
  set_has__query_replay();
  if (_query_replay_ == NULL) _query_replay_ = new ::up::query_replay;
  return _query_replay_;
}
inline ::up::query_replay* ladder::release__query_replay() {
  clear_has__query_replay();
  ::up::query_replay* temp = _query_replay_;
  _query_replay_ = NULL;
  return temp;
}
inline void ladder::set_allocated__query_replay(::up::query_replay* _query_replay) {
  delete _query_replay_;
  _query_replay_ = _query_replay;
  if (_query_replay) {
    set_has__query_replay();
  } else {
    clear_has__query_replay();
  }
}

// optional .up.query_rankboard _query_rankboard = 8;
inline bool ladder::has__query_rankboard() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ladder::set_has__query_rankboard() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ladder::clear_has__query_rankboard() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ladder::clear__query_rankboard() {
  if (_query_rankboard_ != NULL) _query_rankboard_->::up::query_rankboard::Clear();
  clear_has__query_rankboard();
}
inline const ::up::query_rankboard& ladder::_query_rankboard() const {
  return _query_rankboard_ != NULL ? *_query_rankboard_ : *default_instance_->_query_rankboard_;
}
inline ::up::query_rankboard* ladder::mutable__query_rankboard() {
  set_has__query_rankboard();
  if (_query_rankboard_ == NULL) _query_rankboard_ = new ::up::query_rankboard;
  return _query_rankboard_;
}
inline ::up::query_rankboard* ladder::release__query_rankboard() {
  clear_has__query_rankboard();
  ::up::query_rankboard* temp = _query_rankboard_;
  _query_rankboard_ = NULL;
  return temp;
}
inline void ladder::set_allocated__query_rankboard(::up::query_rankboard* _query_rankboard) {
  delete _query_rankboard_;
  _query_rankboard_ = _query_rankboard;
  if (_query_rankboard) {
    set_has__query_rankboard();
  } else {
    clear_has__query_rankboard();
  }
}

// optional .up.query_oppo_info _query_oppo = 9;
inline bool ladder::has__query_oppo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ladder::set_has__query_oppo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ladder::clear_has__query_oppo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ladder::clear__query_oppo() {
  if (_query_oppo_ != NULL) _query_oppo_->::up::query_oppo_info::Clear();
  clear_has__query_oppo();
}
inline const ::up::query_oppo_info& ladder::_query_oppo() const {
  return _query_oppo_ != NULL ? *_query_oppo_ : *default_instance_->_query_oppo_;
}
inline ::up::query_oppo_info* ladder::mutable__query_oppo() {
  set_has__query_oppo();
  if (_query_oppo_ == NULL) _query_oppo_ = new ::up::query_oppo_info;
  return _query_oppo_;
}
inline ::up::query_oppo_info* ladder::release__query_oppo() {
  clear_has__query_oppo();
  ::up::query_oppo_info* temp = _query_oppo_;
  _query_oppo_ = NULL;
  return temp;
}
inline void ladder::set_allocated__query_oppo(::up::query_oppo_info* _query_oppo) {
  delete _query_oppo_;
  _query_oppo_ = _query_oppo;
  if (_query_oppo) {
    set_has__query_oppo();
  } else {
    clear_has__query_oppo();
  }
}

// optional .up.clear_battle_cd _clear_battle_cd = 10;
inline bool ladder::has__clear_battle_cd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ladder::set_has__clear_battle_cd() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ladder::clear_has__clear_battle_cd() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ladder::clear__clear_battle_cd() {
  if (_clear_battle_cd_ != NULL) _clear_battle_cd_->::up::clear_battle_cd::Clear();
  clear_has__clear_battle_cd();
}
inline const ::up::clear_battle_cd& ladder::_clear_battle_cd() const {
  return _clear_battle_cd_ != NULL ? *_clear_battle_cd_ : *default_instance_->_clear_battle_cd_;
}
inline ::up::clear_battle_cd* ladder::mutable__clear_battle_cd() {
  set_has__clear_battle_cd();
  if (_clear_battle_cd_ == NULL) _clear_battle_cd_ = new ::up::clear_battle_cd;
  return _clear_battle_cd_;
}
inline ::up::clear_battle_cd* ladder::release__clear_battle_cd() {
  clear_has__clear_battle_cd();
  ::up::clear_battle_cd* temp = _clear_battle_cd_;
  _clear_battle_cd_ = NULL;
  return temp;
}
inline void ladder::set_allocated__clear_battle_cd(::up::clear_battle_cd* _clear_battle_cd) {
  delete _clear_battle_cd_;
  _clear_battle_cd_ = _clear_battle_cd;
  if (_clear_battle_cd) {
    set_has__clear_battle_cd();
  } else {
    clear_has__clear_battle_cd();
  }
}

// optional .up.draw_rank_reward _draw_rank_reward = 11;
inline bool ladder::has__draw_rank_reward() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ladder::set_has__draw_rank_reward() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ladder::clear_has__draw_rank_reward() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ladder::clear__draw_rank_reward() {
  if (_draw_rank_reward_ != NULL) _draw_rank_reward_->::up::draw_rank_reward::Clear();
  clear_has__draw_rank_reward();
}
inline const ::up::draw_rank_reward& ladder::_draw_rank_reward() const {
  return _draw_rank_reward_ != NULL ? *_draw_rank_reward_ : *default_instance_->_draw_rank_reward_;
}
inline ::up::draw_rank_reward* ladder::mutable__draw_rank_reward() {
  set_has__draw_rank_reward();
  if (_draw_rank_reward_ == NULL) _draw_rank_reward_ = new ::up::draw_rank_reward;
  return _draw_rank_reward_;
}
inline ::up::draw_rank_reward* ladder::release__draw_rank_reward() {
  clear_has__draw_rank_reward();
  ::up::draw_rank_reward* temp = _draw_rank_reward_;
  _draw_rank_reward_ = NULL;
  return temp;
}
inline void ladder::set_allocated__draw_rank_reward(::up::draw_rank_reward* _draw_rank_reward) {
  delete _draw_rank_reward_;
  _draw_rank_reward_ = _draw_rank_reward;
  if (_draw_rank_reward) {
    set_has__draw_rank_reward();
  } else {
    clear_has__draw_rank_reward();
  }
}

// optional .up.buy_battle_chance _buy_battle_chance = 12;
inline bool ladder::has__buy_battle_chance() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ladder::set_has__buy_battle_chance() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ladder::clear_has__buy_battle_chance() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ladder::clear__buy_battle_chance() {
  if (_buy_battle_chance_ != NULL) _buy_battle_chance_->::up::buy_battle_chance::Clear();
  clear_has__buy_battle_chance();
}
inline const ::up::buy_battle_chance& ladder::_buy_battle_chance() const {
  return _buy_battle_chance_ != NULL ? *_buy_battle_chance_ : *default_instance_->_buy_battle_chance_;
}
inline ::up::buy_battle_chance* ladder::mutable__buy_battle_chance() {
  set_has__buy_battle_chance();
  if (_buy_battle_chance_ == NULL) _buy_battle_chance_ = new ::up::buy_battle_chance;
  return _buy_battle_chance_;
}
inline ::up::buy_battle_chance* ladder::release__buy_battle_chance() {
  clear_has__buy_battle_chance();
  ::up::buy_battle_chance* temp = _buy_battle_chance_;
  _buy_battle_chance_ = NULL;
  return temp;
}
inline void ladder::set_allocated__buy_battle_chance(::up::buy_battle_chance* _buy_battle_chance) {
  delete _buy_battle_chance_;
  _buy_battle_chance_ = _buy_battle_chance;
  if (_buy_battle_chance) {
    set_has__buy_battle_chance();
  } else {
    clear_has__buy_battle_chance();
  }
}

// -------------------------------------------------------------------

// open_panel

// -------------------------------------------------------------------

// apply_opponent

// -------------------------------------------------------------------

// start_battle

// required uint32 _oppo_user_id = 1;
inline bool start_battle::has__oppo_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void start_battle::set_has__oppo_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void start_battle::clear_has__oppo_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void start_battle::clear__oppo_user_id() {
  _oppo_user_id_ = 0u;
  clear_has__oppo_user_id();
}
inline ::google::protobuf::uint32 start_battle::_oppo_user_id() const {
  return _oppo_user_id_;
}
inline void start_battle::set__oppo_user_id(::google::protobuf::uint32 value) {
  set_has__oppo_user_id();
  _oppo_user_id_ = value;
}

// repeated uint32 _attack_lineup = 2;
inline int start_battle::_attack_lineup_size() const {
  return _attack_lineup_.size();
}
inline void start_battle::clear__attack_lineup() {
  _attack_lineup_.Clear();
}
inline ::google::protobuf::uint32 start_battle::_attack_lineup(int index) const {
  return _attack_lineup_.Get(index);
}
inline void start_battle::set__attack_lineup(int index, ::google::protobuf::uint32 value) {
  _attack_lineup_.Set(index, value);
}
inline void start_battle::add__attack_lineup(::google::protobuf::uint32 value) {
  _attack_lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
start_battle::_attack_lineup() const {
  return _attack_lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
start_battle::mutable__attack_lineup() {
  return &_attack_lineup_;
}

// -------------------------------------------------------------------

// end_battle

// required .up.battle_result _result = 1;
inline bool end_battle::has__result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void end_battle::set_has__result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void end_battle::clear_has__result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void end_battle::clear__result() {
  _result_ = 0;
  clear_has__result();
}
inline ::up::battle_result end_battle::_result() const {
  return static_cast< ::up::battle_result >(_result_);
}
inline void end_battle::set__result(::up::battle_result value) {
  assert(::up::battle_result_IsValid(value));
  set_has__result();
  _result_ = value;
}

// -------------------------------------------------------------------

// set_lineup

// repeated uint32 _lineup = 1;
inline int set_lineup::_lineup_size() const {
  return _lineup_.size();
}
inline void set_lineup::clear__lineup() {
  _lineup_.Clear();
}
inline ::google::protobuf::uint32 set_lineup::_lineup(int index) const {
  return _lineup_.Get(index);
}
inline void set_lineup::set__lineup(int index, ::google::protobuf::uint32 value) {
  _lineup_.Set(index, value);
}
inline void set_lineup::add__lineup(::google::protobuf::uint32 value) {
  _lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
set_lineup::_lineup() const {
  return _lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
set_lineup::mutable__lineup() {
  return &_lineup_;
}

// -------------------------------------------------------------------

// query_records

// -------------------------------------------------------------------

// query_replay

// required uint32 _record_index = 1;
inline bool query_replay::has__record_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_replay::set_has__record_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_replay::clear_has__record_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_replay::clear__record_index() {
  _record_index_ = 0u;
  clear_has__record_index();
}
inline ::google::protobuf::uint32 query_replay::_record_index() const {
  return _record_index_;
}
inline void query_replay::set__record_index(::google::protobuf::uint32 value) {
  set_has__record_index();
  _record_index_ = value;
}

// optional uint32 _record_svrid = 2;
inline bool query_replay::has__record_svrid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_replay::set_has__record_svrid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_replay::clear_has__record_svrid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_replay::clear__record_svrid() {
  _record_svrid_ = 0u;
  clear_has__record_svrid();
}
inline ::google::protobuf::uint32 query_replay::_record_svrid() const {
  return _record_svrid_;
}
inline void query_replay::set__record_svrid(::google::protobuf::uint32 value) {
  set_has__record_svrid();
  _record_svrid_ = value;
}

// -------------------------------------------------------------------

// sync_skill_stren

// -------------------------------------------------------------------

// query_rankboard

// required .up.query_rankboard.rankboard_type _type = 1;
inline bool query_rankboard::has__type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_rankboard::set_has__type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_rankboard::clear_has__type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_rankboard::clear__type() {
  _type_ = 0;
  clear_has__type();
}
inline ::up::query_rankboard_rankboard_type query_rankboard::_type() const {
  return static_cast< ::up::query_rankboard_rankboard_type >(_type_);
}
inline void query_rankboard::set__type(::up::query_rankboard_rankboard_type value) {
  assert(::up::query_rankboard_rankboard_type_IsValid(value));
  set_has__type();
  _type_ = value;
}

// -------------------------------------------------------------------

// query_oppo_info

// required uint32 _oppo_user_id = 1;
inline bool query_oppo_info::has__oppo_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_oppo_info::set_has__oppo_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_oppo_info::clear_has__oppo_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_oppo_info::clear__oppo_user_id() {
  _oppo_user_id_ = 0u;
  clear_has__oppo_user_id();
}
inline ::google::protobuf::uint32 query_oppo_info::_oppo_user_id() const {
  return _oppo_user_id_;
}
inline void query_oppo_info::set__oppo_user_id(::google::protobuf::uint32 value) {
  set_has__oppo_user_id();
  _oppo_user_id_ = value;
}

// -------------------------------------------------------------------

// clear_battle_cd

// -------------------------------------------------------------------

// draw_rank_reward

// -------------------------------------------------------------------

// buy_battle_chance

// -------------------------------------------------------------------

// set_name

// required .up.set_name.set_type _type = 1;
inline bool set_name::has__type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void set_name::set_has__type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void set_name::clear_has__type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void set_name::clear__type() {
  _type_ = 0;
  clear_has__type();
}
inline ::up::set_name_set_type set_name::_type() const {
  return static_cast< ::up::set_name_set_type >(_type_);
}
inline void set_name::set__type(::up::set_name_set_type value) {
  assert(::up::set_name_set_type_IsValid(value));
  set_has__type();
  _type_ = value;
}

// required string _name = 2;
inline bool set_name::has__name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void set_name::set_has__name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void set_name::clear_has__name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void set_name::clear__name() {
  if (_name_ != &::google::protobuf::internal::kEmptyString) {
    _name_->clear();
  }
  clear_has__name();
}
inline const ::std::string& set_name::_name() const {
  return *_name_;
}
inline void set_name::set__name(const ::std::string& value) {
  set_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    _name_ = new ::std::string;
  }
  _name_->assign(value);
}
inline void set_name::set__name(const char* value) {
  set_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    _name_ = new ::std::string;
  }
  _name_->assign(value);
}
inline void set_name::set__name(const char* value, size_t size) {
  set_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    _name_ = new ::std::string;
  }
  _name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* set_name::mutable__name() {
  set_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    _name_ = new ::std::string;
  }
  return _name_;
}
inline ::std::string* set_name::release__name() {
  clear_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _name_;
    _name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void set_name::set_allocated__name(::std::string* _name) {
  if (_name_ != &::google::protobuf::internal::kEmptyString) {
    delete _name_;
  }
  if (_name) {
    set_has__name();
    _name_ = _name;
  } else {
    clear_has__name();
    _name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// set_avatar

// required uint32 _avatar = 1;
inline bool set_avatar::has__avatar() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void set_avatar::set_has__avatar() {
  _has_bits_[0] |= 0x00000001u;
}
inline void set_avatar::clear_has__avatar() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void set_avatar::clear__avatar() {
  _avatar_ = 0u;
  clear_has__avatar();
}
inline ::google::protobuf::uint32 set_avatar::_avatar() const {
  return _avatar_;
}
inline void set_avatar::set__avatar(::google::protobuf::uint32 value) {
  set_has__avatar();
  _avatar_ = value;
}

// -------------------------------------------------------------------

// query_data

// repeated .up.query_data.query_type _type = 1;
inline int query_data::_type_size() const {
  return _type_.size();
}
inline void query_data::clear__type() {
  _type_.Clear();
}
inline ::up::query_data_query_type query_data::_type(int index) const {
  return static_cast< ::up::query_data_query_type >(_type_.Get(index));
}
inline void query_data::set__type(int index, ::up::query_data_query_type value) {
  assert(::up::query_data_query_type_IsValid(value));
  _type_.Set(index, value);
}
inline void query_data::add__type(::up::query_data_query_type value) {
  assert(::up::query_data_query_type_IsValid(value));
  _type_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
query_data::_type() const {
  return _type_;
}
inline ::google::protobuf::RepeatedField<int>*
query_data::mutable__type() {
  return &_type_;
}

// repeated uint32 _query_heroes = 2;
inline int query_data::_query_heroes_size() const {
  return _query_heroes_.size();
}
inline void query_data::clear__query_heroes() {
  _query_heroes_.Clear();
}
inline ::google::protobuf::uint32 query_data::_query_heroes(int index) const {
  return _query_heroes_.Get(index);
}
inline void query_data::set__query_heroes(int index, ::google::protobuf::uint32 value) {
  _query_heroes_.Set(index, value);
}
inline void query_data::add__query_heroes(::google::protobuf::uint32 value) {
  _query_heroes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
query_data::_query_heroes() const {
  return _query_heroes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
query_data::mutable__query_heroes() {
  return &_query_heroes_;
}

// repeated uint32 _month_card_id = 3;
inline int query_data::_month_card_id_size() const {
  return _month_card_id_.size();
}
inline void query_data::clear__month_card_id() {
  _month_card_id_.Clear();
}
inline ::google::protobuf::uint32 query_data::_month_card_id(int index) const {
  return _month_card_id_.Get(index);
}
inline void query_data::set__month_card_id(int index, ::google::protobuf::uint32 value) {
  _month_card_id_.Set(index, value);
}
inline void query_data::add__month_card_id(::google::protobuf::uint32 value) {
  _month_card_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
query_data::_month_card_id() const {
  return _month_card_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
query_data::mutable__month_card_id() {
  return &_month_card_id_;
}

// -------------------------------------------------------------------

// midas

// required uint32 _times = 1;
inline bool midas::has__times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void midas::set_has__times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void midas::clear_has__times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void midas::clear__times() {
  _times_ = 0u;
  clear_has__times();
}
inline ::google::protobuf::uint32 midas::_times() const {
  return _times_;
}
inline void midas::set__times(::google::protobuf::uint32 value) {
  set_has__times();
  _times_ = value;
}

// -------------------------------------------------------------------

// open_shop

// required uint32 _shopid = 1;
inline bool open_shop::has__shopid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void open_shop::set_has__shopid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void open_shop::clear_has__shopid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void open_shop::clear__shopid() {
  _shopid_ = 0u;
  clear_has__shopid();
}
inline ::google::protobuf::uint32 open_shop::_shopid() const {
  return _shopid_;
}
inline void open_shop::set__shopid(::google::protobuf::uint32 value) {
  set_has__shopid();
  _shopid_ = value;
}

// -------------------------------------------------------------------

// charge

// required .up.platform_type _platid = 1 [default = self];
inline bool charge::has__platid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void charge::set_has__platid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void charge::clear_has__platid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void charge::clear__platid() {
  _platid_ = 0;
  clear_has__platid();
}
inline ::up::platform_type charge::_platid() const {
  return static_cast< ::up::platform_type >(_platid_);
}
inline void charge::set__platid(::up::platform_type value) {
  assert(::up::platform_type_IsValid(value));
  set_has__platid();
  _platid_ = value;
}

// required uint32 _chargeid = 2;
inline bool charge::has__chargeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void charge::set_has__chargeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void charge::clear_has__chargeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void charge::clear__chargeid() {
  _chargeid_ = 0u;
  clear_has__chargeid();
}
inline ::google::protobuf::uint32 charge::_chargeid() const {
  return _chargeid_;
}
inline void charge::set__chargeid(::google::protobuf::uint32 value) {
  set_has__chargeid();
  _chargeid_ = value;
}

// optional string _extradata = 3;
inline bool charge::has__extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void charge::set_has__extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void charge::clear_has__extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void charge::clear__extradata() {
  if (_extradata_ != &::google::protobuf::internal::kEmptyString) {
    _extradata_->clear();
  }
  clear_has__extradata();
}
inline const ::std::string& charge::_extradata() const {
  return *_extradata_;
}
inline void charge::set__extradata(const ::std::string& value) {
  set_has__extradata();
  if (_extradata_ == &::google::protobuf::internal::kEmptyString) {
    _extradata_ = new ::std::string;
  }
  _extradata_->assign(value);
}
inline void charge::set__extradata(const char* value) {
  set_has__extradata();
  if (_extradata_ == &::google::protobuf::internal::kEmptyString) {
    _extradata_ = new ::std::string;
  }
  _extradata_->assign(value);
}
inline void charge::set__extradata(const char* value, size_t size) {
  set_has__extradata();
  if (_extradata_ == &::google::protobuf::internal::kEmptyString) {
    _extradata_ = new ::std::string;
  }
  _extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* charge::mutable__extradata() {
  set_has__extradata();
  if (_extradata_ == &::google::protobuf::internal::kEmptyString) {
    _extradata_ = new ::std::string;
  }
  return _extradata_;
}
inline ::std::string* charge::release__extradata() {
  clear_has__extradata();
  if (_extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _extradata_;
    _extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void charge::set_allocated__extradata(::std::string* _extradata) {
  if (_extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete _extradata_;
  }
  if (_extradata) {
    set_has__extradata();
    _extradata_ = _extradata;
  } else {
    clear_has__extradata();
    _extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ask_daily_login

// required .up.ask_daily_login.status _status = 1;
inline bool ask_daily_login::has__status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ask_daily_login::set_has__status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ask_daily_login::clear_has__status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ask_daily_login::clear__status() {
  _status_ = 1;
  clear_has__status();
}
inline ::up::ask_daily_login_status ask_daily_login::_status() const {
  return static_cast< ::up::ask_daily_login_status >(_status_);
}
inline void ask_daily_login::set__status(::up::ask_daily_login_status value) {
  assert(::up::ask_daily_login_status_IsValid(value));
  set_has__status();
  _status_ = value;
}

// -------------------------------------------------------------------

// tbc

// optional .up.tbc_open_panel _open_panel = 1;
inline bool tbc::has__open_panel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tbc::set_has__open_panel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tbc::clear_has__open_panel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tbc::clear__open_panel() {
  if (_open_panel_ != NULL) _open_panel_->::up::tbc_open_panel::Clear();
  clear_has__open_panel();
}
inline const ::up::tbc_open_panel& tbc::_open_panel() const {
  return _open_panel_ != NULL ? *_open_panel_ : *default_instance_->_open_panel_;
}
inline ::up::tbc_open_panel* tbc::mutable__open_panel() {
  set_has__open_panel();
  if (_open_panel_ == NULL) _open_panel_ = new ::up::tbc_open_panel;
  return _open_panel_;
}
inline ::up::tbc_open_panel* tbc::release__open_panel() {
  clear_has__open_panel();
  ::up::tbc_open_panel* temp = _open_panel_;
  _open_panel_ = NULL;
  return temp;
}
inline void tbc::set_allocated__open_panel(::up::tbc_open_panel* _open_panel) {
  delete _open_panel_;
  _open_panel_ = _open_panel;
  if (_open_panel) {
    set_has__open_panel();
  } else {
    clear_has__open_panel();
  }
}

// optional .up.tbc_query_oppo _query_oppo = 2;
inline bool tbc::has__query_oppo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tbc::set_has__query_oppo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tbc::clear_has__query_oppo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tbc::clear__query_oppo() {
  if (_query_oppo_ != NULL) _query_oppo_->::up::tbc_query_oppo::Clear();
  clear_has__query_oppo();
}
inline const ::up::tbc_query_oppo& tbc::_query_oppo() const {
  return _query_oppo_ != NULL ? *_query_oppo_ : *default_instance_->_query_oppo_;
}
inline ::up::tbc_query_oppo* tbc::mutable__query_oppo() {
  set_has__query_oppo();
  if (_query_oppo_ == NULL) _query_oppo_ = new ::up::tbc_query_oppo;
  return _query_oppo_;
}
inline ::up::tbc_query_oppo* tbc::release__query_oppo() {
  clear_has__query_oppo();
  ::up::tbc_query_oppo* temp = _query_oppo_;
  _query_oppo_ = NULL;
  return temp;
}
inline void tbc::set_allocated__query_oppo(::up::tbc_query_oppo* _query_oppo) {
  delete _query_oppo_;
  _query_oppo_ = _query_oppo;
  if (_query_oppo) {
    set_has__query_oppo();
  } else {
    clear_has__query_oppo();
  }
}

// optional .up.tbc_start_battle _start_bat = 3;
inline bool tbc::has__start_bat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tbc::set_has__start_bat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tbc::clear_has__start_bat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tbc::clear__start_bat() {
  if (_start_bat_ != NULL) _start_bat_->::up::tbc_start_battle::Clear();
  clear_has__start_bat();
}
inline const ::up::tbc_start_battle& tbc::_start_bat() const {
  return _start_bat_ != NULL ? *_start_bat_ : *default_instance_->_start_bat_;
}
inline ::up::tbc_start_battle* tbc::mutable__start_bat() {
  set_has__start_bat();
  if (_start_bat_ == NULL) _start_bat_ = new ::up::tbc_start_battle;
  return _start_bat_;
}
inline ::up::tbc_start_battle* tbc::release__start_bat() {
  clear_has__start_bat();
  ::up::tbc_start_battle* temp = _start_bat_;
  _start_bat_ = NULL;
  return temp;
}
inline void tbc::set_allocated__start_bat(::up::tbc_start_battle* _start_bat) {
  delete _start_bat_;
  _start_bat_ = _start_bat;
  if (_start_bat) {
    set_has__start_bat();
  } else {
    clear_has__start_bat();
  }
}

// optional .up.tbc_end_battle _end_bat = 4;
inline bool tbc::has__end_bat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tbc::set_has__end_bat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tbc::clear_has__end_bat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tbc::clear__end_bat() {
  if (_end_bat_ != NULL) _end_bat_->::up::tbc_end_battle::Clear();
  clear_has__end_bat();
}
inline const ::up::tbc_end_battle& tbc::_end_bat() const {
  return _end_bat_ != NULL ? *_end_bat_ : *default_instance_->_end_bat_;
}
inline ::up::tbc_end_battle* tbc::mutable__end_bat() {
  set_has__end_bat();
  if (_end_bat_ == NULL) _end_bat_ = new ::up::tbc_end_battle;
  return _end_bat_;
}
inline ::up::tbc_end_battle* tbc::release__end_bat() {
  clear_has__end_bat();
  ::up::tbc_end_battle* temp = _end_bat_;
  _end_bat_ = NULL;
  return temp;
}
inline void tbc::set_allocated__end_bat(::up::tbc_end_battle* _end_bat) {
  delete _end_bat_;
  _end_bat_ = _end_bat;
  if (_end_bat) {
    set_has__end_bat();
  } else {
    clear_has__end_bat();
  }
}

// optional .up.tbc_reset _reset = 5;
inline bool tbc::has__reset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void tbc::set_has__reset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void tbc::clear_has__reset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void tbc::clear__reset() {
  if (_reset_ != NULL) _reset_->::up::tbc_reset::Clear();
  clear_has__reset();
}
inline const ::up::tbc_reset& tbc::_reset() const {
  return _reset_ != NULL ? *_reset_ : *default_instance_->_reset_;
}
inline ::up::tbc_reset* tbc::mutable__reset() {
  set_has__reset();
  if (_reset_ == NULL) _reset_ = new ::up::tbc_reset;
  return _reset_;
}
inline ::up::tbc_reset* tbc::release__reset() {
  clear_has__reset();
  ::up::tbc_reset* temp = _reset_;
  _reset_ = NULL;
  return temp;
}
inline void tbc::set_allocated__reset(::up::tbc_reset* _reset) {
  delete _reset_;
  _reset_ = _reset;
  if (_reset) {
    set_has__reset();
  } else {
    clear_has__reset();
  }
}

// optional .up.tbc_draw_reward _draw_reward = 6;
inline bool tbc::has__draw_reward() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void tbc::set_has__draw_reward() {
  _has_bits_[0] |= 0x00000020u;
}
inline void tbc::clear_has__draw_reward() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void tbc::clear__draw_reward() {
  if (_draw_reward_ != NULL) _draw_reward_->::up::tbc_draw_reward::Clear();
  clear_has__draw_reward();
}
inline const ::up::tbc_draw_reward& tbc::_draw_reward() const {
  return _draw_reward_ != NULL ? *_draw_reward_ : *default_instance_->_draw_reward_;
}
inline ::up::tbc_draw_reward* tbc::mutable__draw_reward() {
  set_has__draw_reward();
  if (_draw_reward_ == NULL) _draw_reward_ = new ::up::tbc_draw_reward;
  return _draw_reward_;
}
inline ::up::tbc_draw_reward* tbc::release__draw_reward() {
  clear_has__draw_reward();
  ::up::tbc_draw_reward* temp = _draw_reward_;
  _draw_reward_ = NULL;
  return temp;
}
inline void tbc::set_allocated__draw_reward(::up::tbc_draw_reward* _draw_reward) {
  delete _draw_reward_;
  _draw_reward_ = _draw_reward;
  if (_draw_reward) {
    set_has__draw_reward();
  } else {
    clear_has__draw_reward();
  }
}

// -------------------------------------------------------------------

// tbc_open_panel

// -------------------------------------------------------------------

// tbc_query_oppo

// required uint32 _stage_id = 1;
inline bool tbc_query_oppo::has__stage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tbc_query_oppo::set_has__stage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tbc_query_oppo::clear_has__stage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tbc_query_oppo::clear__stage_id() {
  _stage_id_ = 0u;
  clear_has__stage_id();
}
inline ::google::protobuf::uint32 tbc_query_oppo::_stage_id() const {
  return _stage_id_;
}
inline void tbc_query_oppo::set__stage_id(::google::protobuf::uint32 value) {
  set_has__stage_id();
  _stage_id_ = value;
}

// -------------------------------------------------------------------

// tbc_start_battle

// repeated uint32 _heroids = 1;
inline int tbc_start_battle::_heroids_size() const {
  return _heroids_.size();
}
inline void tbc_start_battle::clear__heroids() {
  _heroids_.Clear();
}
inline ::google::protobuf::uint32 tbc_start_battle::_heroids(int index) const {
  return _heroids_.Get(index);
}
inline void tbc_start_battle::set__heroids(int index, ::google::protobuf::uint32 value) {
  _heroids_.Set(index, value);
}
inline void tbc_start_battle::add__heroids(::google::protobuf::uint32 value) {
  _heroids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
tbc_start_battle::_heroids() const {
  return _heroids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
tbc_start_battle::mutable__heroids() {
  return &_heroids_;
}

// optional uint32 _use_hire = 2;
inline bool tbc_start_battle::has__use_hire() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tbc_start_battle::set_has__use_hire() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tbc_start_battle::clear_has__use_hire() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tbc_start_battle::clear__use_hire() {
  _use_hire_ = 0u;
  clear_has__use_hire();
}
inline ::google::protobuf::uint32 tbc_start_battle::_use_hire() const {
  return _use_hire_;
}
inline void tbc_start_battle::set__use_hire(::google::protobuf::uint32 value) {
  set_has__use_hire();
  _use_hire_ = value;
}

// -------------------------------------------------------------------

// tbc_hero

// required uint32 _heroid = 1;
inline bool tbc_hero::has__heroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tbc_hero::set_has__heroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tbc_hero::clear_has__heroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tbc_hero::clear__heroid() {
  _heroid_ = 0u;
  clear_has__heroid();
}
inline ::google::protobuf::uint32 tbc_hero::_heroid() const {
  return _heroid_;
}
inline void tbc_hero::set__heroid(::google::protobuf::uint32 value) {
  set_has__heroid();
  _heroid_ = value;
}

// required uint32 _hp_perc = 2;
inline bool tbc_hero::has__hp_perc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tbc_hero::set_has__hp_perc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tbc_hero::clear_has__hp_perc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tbc_hero::clear__hp_perc() {
  _hp_perc_ = 0u;
  clear_has__hp_perc();
}
inline ::google::protobuf::uint32 tbc_hero::_hp_perc() const {
  return _hp_perc_;
}
inline void tbc_hero::set__hp_perc(::google::protobuf::uint32 value) {
  set_has__hp_perc();
  _hp_perc_ = value;
}

// required uint32 _mp_perc = 3;
inline bool tbc_hero::has__mp_perc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tbc_hero::set_has__mp_perc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tbc_hero::clear_has__mp_perc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tbc_hero::clear__mp_perc() {
  _mp_perc_ = 0u;
  clear_has__mp_perc();
}
inline ::google::protobuf::uint32 tbc_hero::_mp_perc() const {
  return _mp_perc_;
}
inline void tbc_hero::set__mp_perc(::google::protobuf::uint32 value) {
  set_has__mp_perc();
  _mp_perc_ = value;
}

// optional uint32 _custom_data = 4;
inline bool tbc_hero::has__custom_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tbc_hero::set_has__custom_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tbc_hero::clear_has__custom_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tbc_hero::clear__custom_data() {
  _custom_data_ = 0u;
  clear_has__custom_data();
}
inline ::google::protobuf::uint32 tbc_hero::_custom_data() const {
  return _custom_data_;
}
inline void tbc_hero::set__custom_data(::google::protobuf::uint32 value) {
  set_has__custom_data();
  _custom_data_ = value;
}

// -------------------------------------------------------------------

// tbc_end_battle

// required .up.battle_result _result = 1 [default = victory];
inline bool tbc_end_battle::has__result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tbc_end_battle::set_has__result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tbc_end_battle::clear_has__result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tbc_end_battle::clear__result() {
  _result_ = 0;
  clear_has__result();
}
inline ::up::battle_result tbc_end_battle::_result() const {
  return static_cast< ::up::battle_result >(_result_);
}
inline void tbc_end_battle::set__result(::up::battle_result value) {
  assert(::up::battle_result_IsValid(value));
  set_has__result();
  _result_ = value;
}

// repeated .up.tbc_hero _self_heroes = 2;
inline int tbc_end_battle::_self_heroes_size() const {
  return _self_heroes_.size();
}
inline void tbc_end_battle::clear__self_heroes() {
  _self_heroes_.Clear();
}
inline const ::up::tbc_hero& tbc_end_battle::_self_heroes(int index) const {
  return _self_heroes_.Get(index);
}
inline ::up::tbc_hero* tbc_end_battle::mutable__self_heroes(int index) {
  return _self_heroes_.Mutable(index);
}
inline ::up::tbc_hero* tbc_end_battle::add__self_heroes() {
  return _self_heroes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::up::tbc_hero >&
tbc_end_battle::_self_heroes() const {
  return _self_heroes_;
}
inline ::google::protobuf::RepeatedPtrField< ::up::tbc_hero >*
tbc_end_battle::mutable__self_heroes() {
  return &_self_heroes_;
}

// repeated .up.tbc_hero _oppo_heroes = 3;
inline int tbc_end_battle::_oppo_heroes_size() const {
  return _oppo_heroes_.size();
}
inline void tbc_end_battle::clear__oppo_heroes() {
  _oppo_heroes_.Clear();
}
inline const ::up::tbc_hero& tbc_end_battle::_oppo_heroes(int index) const {
  return _oppo_heroes_.Get(index);
}
inline ::up::tbc_hero* tbc_end_battle::mutable__oppo_heroes(int index) {
  return _oppo_heroes_.Mutable(index);
}
inline ::up::tbc_hero* tbc_end_battle::add__oppo_heroes() {
  return _oppo_heroes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::up::tbc_hero >&
tbc_end_battle::_oppo_heroes() const {
  return _oppo_heroes_;
}
inline ::google::protobuf::RepeatedPtrField< ::up::tbc_hero >*
tbc_end_battle::mutable__oppo_heroes() {
  return &_oppo_heroes_;
}

// repeated uint32 _oprations = 4;
inline int tbc_end_battle::_oprations_size() const {
  return _oprations_.size();
}
inline void tbc_end_battle::clear__oprations() {
  _oprations_.Clear();
}
inline ::google::protobuf::uint32 tbc_end_battle::_oprations(int index) const {
  return _oprations_.Get(index);
}
inline void tbc_end_battle::set__oprations(int index, ::google::protobuf::uint32 value) {
  _oprations_.Set(index, value);
}
inline void tbc_end_battle::add__oprations(::google::protobuf::uint32 value) {
  _oprations_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
tbc_end_battle::_oprations() const {
  return _oprations_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
tbc_end_battle::mutable__oprations() {
  return &_oprations_;
}

// -------------------------------------------------------------------

// tbc_reset

// -------------------------------------------------------------------

// tbc_draw_reward

// required uint32 _stage_id = 1;
inline bool tbc_draw_reward::has__stage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tbc_draw_reward::set_has__stage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tbc_draw_reward::clear_has__stage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tbc_draw_reward::clear__stage_id() {
  _stage_id_ = 0u;
  clear_has__stage_id();
}
inline ::google::protobuf::uint32 tbc_draw_reward::_stage_id() const {
  return _stage_id_;
}
inline void tbc_draw_reward::set__stage_id(::google::protobuf::uint32 value) {
  set_has__stage_id();
  _stage_id_ = value;
}

// -------------------------------------------------------------------

// get_maillist

// -------------------------------------------------------------------

// read_mail

// required uint32 _id = 1;
inline bool read_mail::has__id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void read_mail::set_has__id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void read_mail::clear_has__id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void read_mail::clear__id() {
  _id_ = 0u;
  clear_has__id();
}
inline ::google::protobuf::uint32 read_mail::_id() const {
  return _id_;
}
inline void read_mail::set__id(::google::protobuf::uint32 value) {
  set_has__id();
  _id_ = value;
}

// -------------------------------------------------------------------

// get_svr_time

// -------------------------------------------------------------------

// get_vip_gift

// required uint32 _vip = 1;
inline bool get_vip_gift::has__vip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_vip_gift::set_has__vip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_vip_gift::clear_has__vip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_vip_gift::clear__vip() {
  _vip_ = 0u;
  clear_has__vip();
}
inline ::google::protobuf::uint32 get_vip_gift::_vip() const {
  return _vip_;
}
inline void get_vip_gift::set__vip(::google::protobuf::uint32 value) {
  set_has__vip();
  _vip_ = value;
}

// -------------------------------------------------------------------

// chat

// optional .up.chat_say _say = 1;
inline bool chat::has__say() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat::set_has__say() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat::clear_has__say() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat::clear__say() {
  if (_say_ != NULL) _say_->::up::chat_say::Clear();
  clear_has__say();
}
inline const ::up::chat_say& chat::_say() const {
  return _say_ != NULL ? *_say_ : *default_instance_->_say_;
}
inline ::up::chat_say* chat::mutable__say() {
  set_has__say();
  if (_say_ == NULL) _say_ = new ::up::chat_say;
  return _say_;
}
inline ::up::chat_say* chat::release__say() {
  clear_has__say();
  ::up::chat_say* temp = _say_;
  _say_ = NULL;
  return temp;
}
inline void chat::set_allocated__say(::up::chat_say* _say) {
  delete _say_;
  _say_ = _say;
  if (_say) {
    set_has__say();
  } else {
    clear_has__say();
  }
}

// optional .up.chat_fresh _fresh = 2;
inline bool chat::has__fresh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chat::set_has__fresh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chat::clear_has__fresh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chat::clear__fresh() {
  if (_fresh_ != NULL) _fresh_->::up::chat_fresh::Clear();
  clear_has__fresh();
}
inline const ::up::chat_fresh& chat::_fresh() const {
  return _fresh_ != NULL ? *_fresh_ : *default_instance_->_fresh_;
}
inline ::up::chat_fresh* chat::mutable__fresh() {
  set_has__fresh();
  if (_fresh_ == NULL) _fresh_ = new ::up::chat_fresh;
  return _fresh_;
}
inline ::up::chat_fresh* chat::release__fresh() {
  clear_has__fresh();
  ::up::chat_fresh* temp = _fresh_;
  _fresh_ = NULL;
  return temp;
}
inline void chat::set_allocated__fresh(::up::chat_fresh* _fresh) {
  delete _fresh_;
  _fresh_ = _fresh;
  if (_fresh) {
    set_has__fresh();
  } else {
    clear_has__fresh();
  }
}

// optional .up.chat_fetch _fetch = 3;
inline bool chat::has__fetch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void chat::set_has__fetch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void chat::clear_has__fetch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void chat::clear__fetch() {
  if (_fetch_ != NULL) _fetch_->::up::chat_fetch::Clear();
  clear_has__fetch();
}
inline const ::up::chat_fetch& chat::_fetch() const {
  return _fetch_ != NULL ? *_fetch_ : *default_instance_->_fetch_;
}
inline ::up::chat_fetch* chat::mutable__fetch() {
  set_has__fetch();
  if (_fetch_ == NULL) _fetch_ = new ::up::chat_fetch;
  return _fetch_;
}
inline ::up::chat_fetch* chat::release__fetch() {
  clear_has__fetch();
  ::up::chat_fetch* temp = _fetch_;
  _fetch_ = NULL;
  return temp;
}
inline void chat::set_allocated__fetch(::up::chat_fetch* _fetch) {
  delete _fetch_;
  _fetch_ = _fetch;
  if (_fetch) {
    set_has__fetch();
  } else {
    clear_has__fetch();
  }
}

// optional .up.chat_add_bl _chat_add_bl = 4;
inline bool chat::has__chat_add_bl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void chat::set_has__chat_add_bl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void chat::clear_has__chat_add_bl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void chat::clear__chat_add_bl() {
  if (_chat_add_bl_ != NULL) _chat_add_bl_->::up::chat_add_bl::Clear();
  clear_has__chat_add_bl();
}
inline const ::up::chat_add_bl& chat::_chat_add_bl() const {
  return _chat_add_bl_ != NULL ? *_chat_add_bl_ : *default_instance_->_chat_add_bl_;
}
inline ::up::chat_add_bl* chat::mutable__chat_add_bl() {
  set_has__chat_add_bl();
  if (_chat_add_bl_ == NULL) _chat_add_bl_ = new ::up::chat_add_bl;
  return _chat_add_bl_;
}
inline ::up::chat_add_bl* chat::release__chat_add_bl() {
  clear_has__chat_add_bl();
  ::up::chat_add_bl* temp = _chat_add_bl_;
  _chat_add_bl_ = NULL;
  return temp;
}
inline void chat::set_allocated__chat_add_bl(::up::chat_add_bl* _chat_add_bl) {
  delete _chat_add_bl_;
  _chat_add_bl_ = _chat_add_bl;
  if (_chat_add_bl) {
    set_has__chat_add_bl();
  } else {
    clear_has__chat_add_bl();
  }
}

// optional .up.chat_del_bl _chat_del_bl = 5;
inline bool chat::has__chat_del_bl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void chat::set_has__chat_del_bl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void chat::clear_has__chat_del_bl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void chat::clear__chat_del_bl() {
  if (_chat_del_bl_ != NULL) _chat_del_bl_->::up::chat_del_bl::Clear();
  clear_has__chat_del_bl();
}
inline const ::up::chat_del_bl& chat::_chat_del_bl() const {
  return _chat_del_bl_ != NULL ? *_chat_del_bl_ : *default_instance_->_chat_del_bl_;
}
inline ::up::chat_del_bl* chat::mutable__chat_del_bl() {
  set_has__chat_del_bl();
  if (_chat_del_bl_ == NULL) _chat_del_bl_ = new ::up::chat_del_bl;
  return _chat_del_bl_;
}
inline ::up::chat_del_bl* chat::release__chat_del_bl() {
  clear_has__chat_del_bl();
  ::up::chat_del_bl* temp = _chat_del_bl_;
  _chat_del_bl_ = NULL;
  return temp;
}
inline void chat::set_allocated__chat_del_bl(::up::chat_del_bl* _chat_del_bl) {
  delete _chat_del_bl_;
  _chat_del_bl_ = _chat_del_bl;
  if (_chat_del_bl) {
    set_has__chat_del_bl();
  } else {
    clear_has__chat_del_bl();
  }
}

// optional .up.chat_fetch_bl _chat_fetch_bl = 6;
inline bool chat::has__chat_fetch_bl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void chat::set_has__chat_fetch_bl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void chat::clear_has__chat_fetch_bl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void chat::clear__chat_fetch_bl() {
  if (_chat_fetch_bl_ != NULL) _chat_fetch_bl_->::up::chat_fetch_bl::Clear();
  clear_has__chat_fetch_bl();
}
inline const ::up::chat_fetch_bl& chat::_chat_fetch_bl() const {
  return _chat_fetch_bl_ != NULL ? *_chat_fetch_bl_ : *default_instance_->_chat_fetch_bl_;
}
inline ::up::chat_fetch_bl* chat::mutable__chat_fetch_bl() {
  set_has__chat_fetch_bl();
  if (_chat_fetch_bl_ == NULL) _chat_fetch_bl_ = new ::up::chat_fetch_bl;
  return _chat_fetch_bl_;
}
inline ::up::chat_fetch_bl* chat::release__chat_fetch_bl() {
  clear_has__chat_fetch_bl();
  ::up::chat_fetch_bl* temp = _chat_fetch_bl_;
  _chat_fetch_bl_ = NULL;
  return temp;
}
inline void chat::set_allocated__chat_fetch_bl(::up::chat_fetch_bl* _chat_fetch_bl) {
  delete _chat_fetch_bl_;
  _chat_fetch_bl_ = _chat_fetch_bl;
  if (_chat_fetch_bl) {
    set_has__chat_fetch_bl();
  } else {
    clear_has__chat_fetch_bl();
  }
}

// optional .up.chat_broad_say _chat_broad_say = 7;
inline bool chat::has__chat_broad_say() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void chat::set_has__chat_broad_say() {
  _has_bits_[0] |= 0x00000040u;
}
inline void chat::clear_has__chat_broad_say() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void chat::clear__chat_broad_say() {
  if (_chat_broad_say_ != NULL) _chat_broad_say_->::up::chat_broad_say::Clear();
  clear_has__chat_broad_say();
}
inline const ::up::chat_broad_say& chat::_chat_broad_say() const {
  return _chat_broad_say_ != NULL ? *_chat_broad_say_ : *default_instance_->_chat_broad_say_;
}
inline ::up::chat_broad_say* chat::mutable__chat_broad_say() {
  set_has__chat_broad_say();
  if (_chat_broad_say_ == NULL) _chat_broad_say_ = new ::up::chat_broad_say;
  return _chat_broad_say_;
}
inline ::up::chat_broad_say* chat::release__chat_broad_say() {
  clear_has__chat_broad_say();
  ::up::chat_broad_say* temp = _chat_broad_say_;
  _chat_broad_say_ = NULL;
  return temp;
}
inline void chat::set_allocated__chat_broad_say(::up::chat_broad_say* _chat_broad_say) {
  delete _chat_broad_say_;
  _chat_broad_say_ = _chat_broad_say;
  if (_chat_broad_say) {
    set_has__chat_broad_say();
  } else {
    clear_has__chat_broad_say();
  }
}

// -------------------------------------------------------------------

// chat_broad_say

// optional .up.chat_channel _channel = 1;
inline bool chat_broad_say::has__channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_broad_say::set_has__channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_broad_say::clear_has__channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_broad_say::clear__channel() {
  _channel_ = 1;
  clear_has__channel();
}
inline ::up::chat_channel chat_broad_say::_channel() const {
  return static_cast< ::up::chat_channel >(_channel_);
}
inline void chat_broad_say::set__channel(::up::chat_channel value) {
  assert(::up::chat_channel_IsValid(value));
  set_has__channel();
  _channel_ = value;
}

// repeated uint32 _target_ids = 2;
inline int chat_broad_say::_target_ids_size() const {
  return _target_ids_.size();
}
inline void chat_broad_say::clear__target_ids() {
  _target_ids_.Clear();
}
inline ::google::protobuf::uint32 chat_broad_say::_target_ids(int index) const {
  return _target_ids_.Get(index);
}
inline void chat_broad_say::set__target_ids(int index, ::google::protobuf::uint32 value) {
  _target_ids_.Set(index, value);
}
inline void chat_broad_say::add__target_ids(::google::protobuf::uint32 value) {
  _target_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
chat_broad_say::_target_ids() const {
  return _target_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
chat_broad_say::mutable__target_ids() {
  return &_target_ids_;
}

// optional uint32 _content_type = 3;
inline bool chat_broad_say::has__content_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void chat_broad_say::set_has__content_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void chat_broad_say::clear_has__content_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void chat_broad_say::clear__content_type() {
  _content_type_ = 0u;
  clear_has__content_type();
}
inline ::google::protobuf::uint32 chat_broad_say::_content_type() const {
  return _content_type_;
}
inline void chat_broad_say::set__content_type(::google::protobuf::uint32 value) {
  set_has__content_type();
  _content_type_ = value;
}

// optional string _content = 4;
inline bool chat_broad_say::has__content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void chat_broad_say::set_has__content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void chat_broad_say::clear_has__content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void chat_broad_say::clear__content() {
  if (_content_ != &::google::protobuf::internal::kEmptyString) {
    _content_->clear();
  }
  clear_has__content();
}
inline const ::std::string& chat_broad_say::_content() const {
  return *_content_;
}
inline void chat_broad_say::set__content(const ::std::string& value) {
  set_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    _content_ = new ::std::string;
  }
  _content_->assign(value);
}
inline void chat_broad_say::set__content(const char* value) {
  set_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    _content_ = new ::std::string;
  }
  _content_->assign(value);
}
inline void chat_broad_say::set__content(const char* value, size_t size) {
  set_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    _content_ = new ::std::string;
  }
  _content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_broad_say::mutable__content() {
  set_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    _content_ = new ::std::string;
  }
  return _content_;
}
inline ::std::string* chat_broad_say::release__content() {
  clear_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _content_;
    _content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_broad_say::set_allocated__content(::std::string* _content) {
  if (_content_ != &::google::protobuf::internal::kEmptyString) {
    delete _content_;
  }
  if (_content) {
    set_has__content();
    _content_ = _content;
  } else {
    clear_has__content();
    _content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .up.chat_acc _accessory = 5;
inline bool chat_broad_say::has__accessory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void chat_broad_say::set_has__accessory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void chat_broad_say::clear_has__accessory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void chat_broad_say::clear__accessory() {
  if (_accessory_ != NULL) _accessory_->::up::chat_acc::Clear();
  clear_has__accessory();
}
inline const ::up::chat_acc& chat_broad_say::_accessory() const {
  return _accessory_ != NULL ? *_accessory_ : *default_instance_->_accessory_;
}
inline ::up::chat_acc* chat_broad_say::mutable__accessory() {
  set_has__accessory();
  if (_accessory_ == NULL) _accessory_ = new ::up::chat_acc;
  return _accessory_;
}
inline ::up::chat_acc* chat_broad_say::release__accessory() {
  clear_has__accessory();
  ::up::chat_acc* temp = _accessory_;
  _accessory_ = NULL;
  return temp;
}
inline void chat_broad_say::set_allocated__accessory(::up::chat_acc* _accessory) {
  delete _accessory_;
  _accessory_ = _accessory;
  if (_accessory) {
    set_has__accessory();
  } else {
    clear_has__accessory();
  }
}

// -------------------------------------------------------------------

// chat_fetch_bl

// -------------------------------------------------------------------

// chat_say

// required .up.chat_channel _channel = 1 [default = world_channel];
inline bool chat_say::has__channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_say::set_has__channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_say::clear_has__channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_say::clear__channel() {
  _channel_ = 1;
  clear_has__channel();
}
inline ::up::chat_channel chat_say::_channel() const {
  return static_cast< ::up::chat_channel >(_channel_);
}
inline void chat_say::set__channel(::up::chat_channel value) {
  assert(::up::chat_channel_IsValid(value));
  set_has__channel();
  _channel_ = value;
}

// optional uint32 _target_id = 2;
inline bool chat_say::has__target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chat_say::set_has__target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chat_say::clear_has__target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chat_say::clear__target_id() {
  _target_id_ = 0u;
  clear_has__target_id();
}
inline ::google::protobuf::uint32 chat_say::_target_id() const {
  return _target_id_;
}
inline void chat_say::set__target_id(::google::protobuf::uint32 value) {
  set_has__target_id();
  _target_id_ = value;
}

// required uint32 _content_type = 3;
inline bool chat_say::has__content_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void chat_say::set_has__content_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void chat_say::clear_has__content_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void chat_say::clear__content_type() {
  _content_type_ = 0u;
  clear_has__content_type();
}
inline ::google::protobuf::uint32 chat_say::_content_type() const {
  return _content_type_;
}
inline void chat_say::set__content_type(::google::protobuf::uint32 value) {
  set_has__content_type();
  _content_type_ = value;
}

// required string _content = 4;
inline bool chat_say::has__content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void chat_say::set_has__content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void chat_say::clear_has__content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void chat_say::clear__content() {
  if (_content_ != &::google::protobuf::internal::kEmptyString) {
    _content_->clear();
  }
  clear_has__content();
}
inline const ::std::string& chat_say::_content() const {
  return *_content_;
}
inline void chat_say::set__content(const ::std::string& value) {
  set_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    _content_ = new ::std::string;
  }
  _content_->assign(value);
}
inline void chat_say::set__content(const char* value) {
  set_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    _content_ = new ::std::string;
  }
  _content_->assign(value);
}
inline void chat_say::set__content(const char* value, size_t size) {
  set_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    _content_ = new ::std::string;
  }
  _content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_say::mutable__content() {
  set_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    _content_ = new ::std::string;
  }
  return _content_;
}
inline ::std::string* chat_say::release__content() {
  clear_has__content();
  if (_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _content_;
    _content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_say::set_allocated__content(::std::string* _content) {
  if (_content_ != &::google::protobuf::internal::kEmptyString) {
    delete _content_;
  }
  if (_content) {
    set_has__content();
    _content_ = _content;
  } else {
    clear_has__content();
    _content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .up.chat_acc _accessory = 5;
inline bool chat_say::has__accessory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void chat_say::set_has__accessory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void chat_say::clear_has__accessory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void chat_say::clear__accessory() {
  if (_accessory_ != NULL) _accessory_->::up::chat_acc::Clear();
  clear_has__accessory();
}
inline const ::up::chat_acc& chat_say::_accessory() const {
  return _accessory_ != NULL ? *_accessory_ : *default_instance_->_accessory_;
}
inline ::up::chat_acc* chat_say::mutable__accessory() {
  set_has__accessory();
  if (_accessory_ == NULL) _accessory_ = new ::up::chat_acc;
  return _accessory_;
}
inline ::up::chat_acc* chat_say::release__accessory() {
  clear_has__accessory();
  ::up::chat_acc* temp = _accessory_;
  _accessory_ = NULL;
  return temp;
}
inline void chat_say::set_allocated__accessory(::up::chat_acc* _accessory) {
  delete _accessory_;
  _accessory_ = _accessory;
  if (_accessory) {
    set_has__accessory();
  } else {
    clear_has__accessory();
  }
}

// -------------------------------------------------------------------

// chat_acc

// required .up.chat_acc.chat_acc_t _type = 1 [default = binary];
inline bool chat_acc::has__type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_acc::set_has__type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_acc::clear_has__type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_acc::clear__type() {
  _type_ = 1;
  clear_has__type();
}
inline ::up::chat_acc_chat_acc_t chat_acc::_type() const {
  return static_cast< ::up::chat_acc_chat_acc_t >(_type_);
}
inline void chat_acc::set__type(::up::chat_acc_chat_acc_t value) {
  assert(::up::chat_acc_chat_acc_t_IsValid(value));
  set_has__type();
  _type_ = value;
}

// optional string _binary = 2;
inline bool chat_acc::has__binary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chat_acc::set_has__binary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chat_acc::clear_has__binary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chat_acc::clear__binary() {
  if (_binary_ != &::google::protobuf::internal::kEmptyString) {
    _binary_->clear();
  }
  clear_has__binary();
}
inline const ::std::string& chat_acc::_binary() const {
  return *_binary_;
}
inline void chat_acc::set__binary(const ::std::string& value) {
  set_has__binary();
  if (_binary_ == &::google::protobuf::internal::kEmptyString) {
    _binary_ = new ::std::string;
  }
  _binary_->assign(value);
}
inline void chat_acc::set__binary(const char* value) {
  set_has__binary();
  if (_binary_ == &::google::protobuf::internal::kEmptyString) {
    _binary_ = new ::std::string;
  }
  _binary_->assign(value);
}
inline void chat_acc::set__binary(const char* value, size_t size) {
  set_has__binary();
  if (_binary_ == &::google::protobuf::internal::kEmptyString) {
    _binary_ = new ::std::string;
  }
  _binary_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_acc::mutable__binary() {
  set_has__binary();
  if (_binary_ == &::google::protobuf::internal::kEmptyString) {
    _binary_ = new ::std::string;
  }
  return _binary_;
}
inline ::std::string* chat_acc::release__binary() {
  clear_has__binary();
  if (_binary_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _binary_;
    _binary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_acc::set_allocated__binary(::std::string* _binary) {
  if (_binary_ != &::google::protobuf::internal::kEmptyString) {
    delete _binary_;
  }
  if (_binary) {
    set_has__binary();
    _binary_ = _binary;
  } else {
    clear_has__binary();
    _binary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 _record_id = 3;
inline bool chat_acc::has__record_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void chat_acc::set_has__record_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void chat_acc::clear_has__record_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void chat_acc::clear__record_id() {
  _record_id_ = 0u;
  clear_has__record_id();
}
inline ::google::protobuf::uint32 chat_acc::_record_id() const {
  return _record_id_;
}
inline void chat_acc::set__record_id(::google::protobuf::uint32 value) {
  set_has__record_id();
  _record_id_ = value;
}

// -------------------------------------------------------------------

// chat_fresh

// required .up.chat_channel _channel = 1 [default = world_channel];
inline bool chat_fresh::has__channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_fresh::set_has__channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_fresh::clear_has__channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_fresh::clear__channel() {
  _channel_ = 1;
  clear_has__channel();
}
inline ::up::chat_channel chat_fresh::_channel() const {
  return static_cast< ::up::chat_channel >(_channel_);
}
inline void chat_fresh::set__channel(::up::chat_channel value) {
  assert(::up::chat_channel_IsValid(value));
  set_has__channel();
  _channel_ = value;
}

// -------------------------------------------------------------------

// chat_fetch

// required .up.chat_channel _channel = 1 [default = world_channel];
inline bool chat_fetch::has__channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_fetch::set_has__channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_fetch::clear_has__channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_fetch::clear__channel() {
  _channel_ = 1;
  clear_has__channel();
}
inline ::up::chat_channel chat_fetch::_channel() const {
  return static_cast< ::up::chat_channel >(_channel_);
}
inline void chat_fetch::set__channel(::up::chat_channel value) {
  assert(::up::chat_channel_IsValid(value));
  set_has__channel();
  _channel_ = value;
}

// required uint32 _chat_id = 2;
inline bool chat_fetch::has__chat_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chat_fetch::set_has__chat_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chat_fetch::clear_has__chat_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chat_fetch::clear__chat_id() {
  _chat_id_ = 0u;
  clear_has__chat_id();
}
inline ::google::protobuf::uint32 chat_fetch::_chat_id() const {
  return _chat_id_;
}
inline void chat_fetch::set__chat_id(::google::protobuf::uint32 value) {
  set_has__chat_id();
  _chat_id_ = value;
}

// -------------------------------------------------------------------

// chat_add_bl

// required uint32 _uid = 1;
inline bool chat_add_bl::has__uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_add_bl::set_has__uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_add_bl::clear_has__uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_add_bl::clear__uid() {
  _uid_ = 0u;
  clear_has__uid();
}
inline ::google::protobuf::uint32 chat_add_bl::_uid() const {
  return _uid_;
}
inline void chat_add_bl::set__uid(::google::protobuf::uint32 value) {
  set_has__uid();
  _uid_ = value;
}

// -------------------------------------------------------------------

// chat_del_bl

// required uint32 _uid = 1;
inline bool chat_del_bl::has__uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_del_bl::set_has__uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_del_bl::clear_has__uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_del_bl::clear__uid() {
  _uid_ = 0u;
  clear_has__uid();
}
inline ::google::protobuf::uint32 chat_del_bl::_uid() const {
  return _uid_;
}
inline void chat_del_bl::set__uid(::google::protobuf::uint32 value) {
  set_has__uid();
  _uid_ = value;
}

// -------------------------------------------------------------------

// guild

// optional .up.guild_create _create = 1;
inline bool guild::has__create() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild::set_has__create() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild::clear_has__create() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild::clear__create() {
  if (_create_ != NULL) _create_->::up::guild_create::Clear();
  clear_has__create();
}
inline const ::up::guild_create& guild::_create() const {
  return _create_ != NULL ? *_create_ : *default_instance_->_create_;
}
inline ::up::guild_create* guild::mutable__create() {
  set_has__create();
  if (_create_ == NULL) _create_ = new ::up::guild_create;
  return _create_;
}
inline ::up::guild_create* guild::release__create() {
  clear_has__create();
  ::up::guild_create* temp = _create_;
  _create_ = NULL;
  return temp;
}
inline void guild::set_allocated__create(::up::guild_create* _create) {
  delete _create_;
  _create_ = _create;
  if (_create) {
    set_has__create();
  } else {
    clear_has__create();
  }
}

// optional .up.guild_dismiss _dismiss = 2;
inline bool guild::has__dismiss() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild::set_has__dismiss() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild::clear_has__dismiss() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild::clear__dismiss() {
  if (_dismiss_ != NULL) _dismiss_->::up::guild_dismiss::Clear();
  clear_has__dismiss();
}
inline const ::up::guild_dismiss& guild::_dismiss() const {
  return _dismiss_ != NULL ? *_dismiss_ : *default_instance_->_dismiss_;
}
inline ::up::guild_dismiss* guild::mutable__dismiss() {
  set_has__dismiss();
  if (_dismiss_ == NULL) _dismiss_ = new ::up::guild_dismiss;
  return _dismiss_;
}
inline ::up::guild_dismiss* guild::release__dismiss() {
  clear_has__dismiss();
  ::up::guild_dismiss* temp = _dismiss_;
  _dismiss_ = NULL;
  return temp;
}
inline void guild::set_allocated__dismiss(::up::guild_dismiss* _dismiss) {
  delete _dismiss_;
  _dismiss_ = _dismiss;
  if (_dismiss) {
    set_has__dismiss();
  } else {
    clear_has__dismiss();
  }
}

// optional .up.guild_list _list = 3;
inline bool guild::has__list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void guild::set_has__list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void guild::clear_has__list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void guild::clear__list() {
  if (_list_ != NULL) _list_->::up::guild_list::Clear();
  clear_has__list();
}
inline const ::up::guild_list& guild::_list() const {
  return _list_ != NULL ? *_list_ : *default_instance_->_list_;
}
inline ::up::guild_list* guild::mutable__list() {
  set_has__list();
  if (_list_ == NULL) _list_ = new ::up::guild_list;
  return _list_;
}
inline ::up::guild_list* guild::release__list() {
  clear_has__list();
  ::up::guild_list* temp = _list_;
  _list_ = NULL;
  return temp;
}
inline void guild::set_allocated__list(::up::guild_list* _list) {
  delete _list_;
  _list_ = _list;
  if (_list) {
    set_has__list();
  } else {
    clear_has__list();
  }
}

// optional .up.guild_search _search = 4;
inline bool guild::has__search() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void guild::set_has__search() {
  _has_bits_[0] |= 0x00000008u;
}
inline void guild::clear_has__search() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void guild::clear__search() {
  if (_search_ != NULL) _search_->::up::guild_search::Clear();
  clear_has__search();
}
inline const ::up::guild_search& guild::_search() const {
  return _search_ != NULL ? *_search_ : *default_instance_->_search_;
}
inline ::up::guild_search* guild::mutable__search() {
  set_has__search();
  if (_search_ == NULL) _search_ = new ::up::guild_search;
  return _search_;
}
inline ::up::guild_search* guild::release__search() {
  clear_has__search();
  ::up::guild_search* temp = _search_;
  _search_ = NULL;
  return temp;
}
inline void guild::set_allocated__search(::up::guild_search* _search) {
  delete _search_;
  _search_ = _search;
  if (_search) {
    set_has__search();
  } else {
    clear_has__search();
  }
}

// optional .up.guild_join _join = 5;
inline bool guild::has__join() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void guild::set_has__join() {
  _has_bits_[0] |= 0x00000010u;
}
inline void guild::clear_has__join() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void guild::clear__join() {
  if (_join_ != NULL) _join_->::up::guild_join::Clear();
  clear_has__join();
}
inline const ::up::guild_join& guild::_join() const {
  return _join_ != NULL ? *_join_ : *default_instance_->_join_;
}
inline ::up::guild_join* guild::mutable__join() {
  set_has__join();
  if (_join_ == NULL) _join_ = new ::up::guild_join;
  return _join_;
}
inline ::up::guild_join* guild::release__join() {
  clear_has__join();
  ::up::guild_join* temp = _join_;
  _join_ = NULL;
  return temp;
}
inline void guild::set_allocated__join(::up::guild_join* _join) {
  delete _join_;
  _join_ = _join;
  if (_join) {
    set_has__join();
  } else {
    clear_has__join();
  }
}

// optional .up.guild_join_confirm _join_confirm = 6;
inline bool guild::has__join_confirm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void guild::set_has__join_confirm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void guild::clear_has__join_confirm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void guild::clear__join_confirm() {
  if (_join_confirm_ != NULL) _join_confirm_->::up::guild_join_confirm::Clear();
  clear_has__join_confirm();
}
inline const ::up::guild_join_confirm& guild::_join_confirm() const {
  return _join_confirm_ != NULL ? *_join_confirm_ : *default_instance_->_join_confirm_;
}
inline ::up::guild_join_confirm* guild::mutable__join_confirm() {
  set_has__join_confirm();
  if (_join_confirm_ == NULL) _join_confirm_ = new ::up::guild_join_confirm;
  return _join_confirm_;
}
inline ::up::guild_join_confirm* guild::release__join_confirm() {
  clear_has__join_confirm();
  ::up::guild_join_confirm* temp = _join_confirm_;
  _join_confirm_ = NULL;
  return temp;
}
inline void guild::set_allocated__join_confirm(::up::guild_join_confirm* _join_confirm) {
  delete _join_confirm_;
  _join_confirm_ = _join_confirm;
  if (_join_confirm) {
    set_has__join_confirm();
  } else {
    clear_has__join_confirm();
  }
}

// optional .up.guild_leave _guild_leave = 7;
inline bool guild::has__guild_leave() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void guild::set_has__guild_leave() {
  _has_bits_[0] |= 0x00000040u;
}
inline void guild::clear_has__guild_leave() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void guild::clear__guild_leave() {
  if (_guild_leave_ != NULL) _guild_leave_->::up::guild_leave::Clear();
  clear_has__guild_leave();
}
inline const ::up::guild_leave& guild::_guild_leave() const {
  return _guild_leave_ != NULL ? *_guild_leave_ : *default_instance_->_guild_leave_;
}
inline ::up::guild_leave* guild::mutable__guild_leave() {
  set_has__guild_leave();
  if (_guild_leave_ == NULL) _guild_leave_ = new ::up::guild_leave;
  return _guild_leave_;
}
inline ::up::guild_leave* guild::release__guild_leave() {
  clear_has__guild_leave();
  ::up::guild_leave* temp = _guild_leave_;
  _guild_leave_ = NULL;
  return temp;
}
inline void guild::set_allocated__guild_leave(::up::guild_leave* _guild_leave) {
  delete _guild_leave_;
  _guild_leave_ = _guild_leave;
  if (_guild_leave) {
    set_has__guild_leave();
  } else {
    clear_has__guild_leave();
  }
}

// optional .up.guild_kick _kick = 8;
inline bool guild::has__kick() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void guild::set_has__kick() {
  _has_bits_[0] |= 0x00000080u;
}
inline void guild::clear_has__kick() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void guild::clear__kick() {
  if (_kick_ != NULL) _kick_->::up::guild_kick::Clear();
  clear_has__kick();
}
inline const ::up::guild_kick& guild::_kick() const {
  return _kick_ != NULL ? *_kick_ : *default_instance_->_kick_;
}
inline ::up::guild_kick* guild::mutable__kick() {
  set_has__kick();
  if (_kick_ == NULL) _kick_ = new ::up::guild_kick;
  return _kick_;
}
inline ::up::guild_kick* guild::release__kick() {
  clear_has__kick();
  ::up::guild_kick* temp = _kick_;
  _kick_ = NULL;
  return temp;
}
inline void guild::set_allocated__kick(::up::guild_kick* _kick) {
  delete _kick_;
  _kick_ = _kick;
  if (_kick) {
    set_has__kick();
  } else {
    clear_has__kick();
  }
}

// optional .up.guild_set _set = 9;
inline bool guild::has__set() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void guild::set_has__set() {
  _has_bits_[0] |= 0x00000100u;
}
inline void guild::clear_has__set() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void guild::clear__set() {
  if (_set_ != NULL) _set_->::up::guild_set::Clear();
  clear_has__set();
}
inline const ::up::guild_set& guild::_set() const {
  return _set_ != NULL ? *_set_ : *default_instance_->_set_;
}
inline ::up::guild_set* guild::mutable__set() {
  set_has__set();
  if (_set_ == NULL) _set_ = new ::up::guild_set;
  return _set_;
}
inline ::up::guild_set* guild::release__set() {
  clear_has__set();
  ::up::guild_set* temp = _set_;
  _set_ = NULL;
  return temp;
}
inline void guild::set_allocated__set(::up::guild_set* _set) {
  delete _set_;
  _set_ = _set;
  if (_set) {
    set_has__set();
  } else {
    clear_has__set();
  }
}

// optional .up.guild_query _query = 10;
inline bool guild::has__query() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void guild::set_has__query() {
  _has_bits_[0] |= 0x00000200u;
}
inline void guild::clear_has__query() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void guild::clear__query() {
  if (_query_ != NULL) _query_->::up::guild_query::Clear();
  clear_has__query();
}
inline const ::up::guild_query& guild::_query() const {
  return _query_ != NULL ? *_query_ : *default_instance_->_query_;
}
inline ::up::guild_query* guild::mutable__query() {
  set_has__query();
  if (_query_ == NULL) _query_ = new ::up::guild_query;
  return _query_;
}
inline ::up::guild_query* guild::release__query() {
  clear_has__query();
  ::up::guild_query* temp = _query_;
  _query_ = NULL;
  return temp;
}
inline void guild::set_allocated__query(::up::guild_query* _query) {
  delete _query_;
  _query_ = _query;
  if (_query) {
    set_has__query();
  } else {
    clear_has__query();
  }
}

// optional .up.guild_open_pannel _open_pannel = 11;
inline bool guild::has__open_pannel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void guild::set_has__open_pannel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void guild::clear_has__open_pannel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void guild::clear__open_pannel() {
  if (_open_pannel_ != NULL) _open_pannel_->::up::guild_open_pannel::Clear();
  clear_has__open_pannel();
}
inline const ::up::guild_open_pannel& guild::_open_pannel() const {
  return _open_pannel_ != NULL ? *_open_pannel_ : *default_instance_->_open_pannel_;
}
inline ::up::guild_open_pannel* guild::mutable__open_pannel() {
  set_has__open_pannel();
  if (_open_pannel_ == NULL) _open_pannel_ = new ::up::guild_open_pannel;
  return _open_pannel_;
}
inline ::up::guild_open_pannel* guild::release__open_pannel() {
  clear_has__open_pannel();
  ::up::guild_open_pannel* temp = _open_pannel_;
  _open_pannel_ = NULL;
  return temp;
}
inline void guild::set_allocated__open_pannel(::up::guild_open_pannel* _open_pannel) {
  delete _open_pannel_;
  _open_pannel_ = _open_pannel;
  if (_open_pannel) {
    set_has__open_pannel();
  } else {
    clear_has__open_pannel();
  }
}

// optional .up.guild_set_job _set_job = 12;
inline bool guild::has__set_job() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void guild::set_has__set_job() {
  _has_bits_[0] |= 0x00000800u;
}
inline void guild::clear_has__set_job() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void guild::clear__set_job() {
  if (_set_job_ != NULL) _set_job_->::up::guild_set_job::Clear();
  clear_has__set_job();
}
inline const ::up::guild_set_job& guild::_set_job() const {
  return _set_job_ != NULL ? *_set_job_ : *default_instance_->_set_job_;
}
inline ::up::guild_set_job* guild::mutable__set_job() {
  set_has__set_job();
  if (_set_job_ == NULL) _set_job_ = new ::up::guild_set_job;
  return _set_job_;
}
inline ::up::guild_set_job* guild::release__set_job() {
  clear_has__set_job();
  ::up::guild_set_job* temp = _set_job_;
  _set_job_ = NULL;
  return temp;
}
inline void guild::set_allocated__set_job(::up::guild_set_job* _set_job) {
  delete _set_job_;
  _set_job_ = _set_job;
  if (_set_job) {
    set_has__set_job();
  } else {
    clear_has__set_job();
  }
}

// optional .up.guild_add_hire _add_hire = 13;
inline bool guild::has__add_hire() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void guild::set_has__add_hire() {
  _has_bits_[0] |= 0x00001000u;
}
inline void guild::clear_has__add_hire() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void guild::clear__add_hire() {
  if (_add_hire_ != NULL) _add_hire_->::up::guild_add_hire::Clear();
  clear_has__add_hire();
}
inline const ::up::guild_add_hire& guild::_add_hire() const {
  return _add_hire_ != NULL ? *_add_hire_ : *default_instance_->_add_hire_;
}
inline ::up::guild_add_hire* guild::mutable__add_hire() {
  set_has__add_hire();
  if (_add_hire_ == NULL) _add_hire_ = new ::up::guild_add_hire;
  return _add_hire_;
}
inline ::up::guild_add_hire* guild::release__add_hire() {
  clear_has__add_hire();
  ::up::guild_add_hire* temp = _add_hire_;
  _add_hire_ = NULL;
  return temp;
}
inline void guild::set_allocated__add_hire(::up::guild_add_hire* _add_hire) {
  delete _add_hire_;
  _add_hire_ = _add_hire;
  if (_add_hire) {
    set_has__add_hire();
  } else {
    clear_has__add_hire();
  }
}

// optional .up.guild_del_hire _del_hire = 14;
inline bool guild::has__del_hire() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void guild::set_has__del_hire() {
  _has_bits_[0] |= 0x00002000u;
}
inline void guild::clear_has__del_hire() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void guild::clear__del_hire() {
  if (_del_hire_ != NULL) _del_hire_->::up::guild_del_hire::Clear();
  clear_has__del_hire();
}
inline const ::up::guild_del_hire& guild::_del_hire() const {
  return _del_hire_ != NULL ? *_del_hire_ : *default_instance_->_del_hire_;
}
inline ::up::guild_del_hire* guild::mutable__del_hire() {
  set_has__del_hire();
  if (_del_hire_ == NULL) _del_hire_ = new ::up::guild_del_hire;
  return _del_hire_;
}
inline ::up::guild_del_hire* guild::release__del_hire() {
  clear_has__del_hire();
  ::up::guild_del_hire* temp = _del_hire_;
  _del_hire_ = NULL;
  return temp;
}
inline void guild::set_allocated__del_hire(::up::guild_del_hire* _del_hire) {
  delete _del_hire_;
  _del_hire_ = _del_hire;
  if (_del_hire) {
    set_has__del_hire();
  } else {
    clear_has__del_hire();
  }
}

// optional .up.guild_query_hires _query_hires = 15;
inline bool guild::has__query_hires() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void guild::set_has__query_hires() {
  _has_bits_[0] |= 0x00004000u;
}
inline void guild::clear_has__query_hires() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void guild::clear__query_hires() {
  if (_query_hires_ != NULL) _query_hires_->::up::guild_query_hires::Clear();
  clear_has__query_hires();
}
inline const ::up::guild_query_hires& guild::_query_hires() const {
  return _query_hires_ != NULL ? *_query_hires_ : *default_instance_->_query_hires_;
}
inline ::up::guild_query_hires* guild::mutable__query_hires() {
  set_has__query_hires();
  if (_query_hires_ == NULL) _query_hires_ = new ::up::guild_query_hires;
  return _query_hires_;
}
inline ::up::guild_query_hires* guild::release__query_hires() {
  clear_has__query_hires();
  ::up::guild_query_hires* temp = _query_hires_;
  _query_hires_ = NULL;
  return temp;
}
inline void guild::set_allocated__query_hires(::up::guild_query_hires* _query_hires) {
  delete _query_hires_;
  _query_hires_ = _query_hires;
  if (_query_hires) {
    set_has__query_hires();
  } else {
    clear_has__query_hires();
  }
}

// optional .up.guild_hire_hero _hire_hero = 16;
inline bool guild::has__hire_hero() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void guild::set_has__hire_hero() {
  _has_bits_[0] |= 0x00008000u;
}
inline void guild::clear_has__hire_hero() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void guild::clear__hire_hero() {
  if (_hire_hero_ != NULL) _hire_hero_->::up::guild_hire_hero::Clear();
  clear_has__hire_hero();
}
inline const ::up::guild_hire_hero& guild::_hire_hero() const {
  return _hire_hero_ != NULL ? *_hire_hero_ : *default_instance_->_hire_hero_;
}
inline ::up::guild_hire_hero* guild::mutable__hire_hero() {
  set_has__hire_hero();
  if (_hire_hero_ == NULL) _hire_hero_ = new ::up::guild_hire_hero;
  return _hire_hero_;
}
inline ::up::guild_hire_hero* guild::release__hire_hero() {
  clear_has__hire_hero();
  ::up::guild_hire_hero* temp = _hire_hero_;
  _hire_hero_ = NULL;
  return temp;
}
inline void guild::set_allocated__hire_hero(::up::guild_hire_hero* _hire_hero) {
  delete _hire_hero_;
  _hire_hero_ = _hire_hero;
  if (_hire_hero) {
    set_has__hire_hero();
  } else {
    clear_has__hire_hero();
  }
}

// optional .up.guild_worship_req _worship_req = 17;
inline bool guild::has__worship_req() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void guild::set_has__worship_req() {
  _has_bits_[0] |= 0x00010000u;
}
inline void guild::clear_has__worship_req() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void guild::clear__worship_req() {
  if (_worship_req_ != NULL) _worship_req_->::up::guild_worship_req::Clear();
  clear_has__worship_req();
}
inline const ::up::guild_worship_req& guild::_worship_req() const {
  return _worship_req_ != NULL ? *_worship_req_ : *default_instance_->_worship_req_;
}
inline ::up::guild_worship_req* guild::mutable__worship_req() {
  set_has__worship_req();
  if (_worship_req_ == NULL) _worship_req_ = new ::up::guild_worship_req;
  return _worship_req_;
}
inline ::up::guild_worship_req* guild::release__worship_req() {
  clear_has__worship_req();
  ::up::guild_worship_req* temp = _worship_req_;
  _worship_req_ = NULL;
  return temp;
}
inline void guild::set_allocated__worship_req(::up::guild_worship_req* _worship_req) {
  delete _worship_req_;
  _worship_req_ = _worship_req;
  if (_worship_req) {
    set_has__worship_req();
  } else {
    clear_has__worship_req();
  }
}

// optional .up.guild_worship_withdraw _worship_withdraw = 18;
inline bool guild::has__worship_withdraw() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void guild::set_has__worship_withdraw() {
  _has_bits_[0] |= 0x00020000u;
}
inline void guild::clear_has__worship_withdraw() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void guild::clear__worship_withdraw() {
  if (_worship_withdraw_ != NULL) _worship_withdraw_->::up::guild_worship_withdraw::Clear();
  clear_has__worship_withdraw();
}
inline const ::up::guild_worship_withdraw& guild::_worship_withdraw() const {
  return _worship_withdraw_ != NULL ? *_worship_withdraw_ : *default_instance_->_worship_withdraw_;
}
inline ::up::guild_worship_withdraw* guild::mutable__worship_withdraw() {
  set_has__worship_withdraw();
  if (_worship_withdraw_ == NULL) _worship_withdraw_ = new ::up::guild_worship_withdraw;
  return _worship_withdraw_;
}
inline ::up::guild_worship_withdraw* guild::release__worship_withdraw() {
  clear_has__worship_withdraw();
  ::up::guild_worship_withdraw* temp = _worship_withdraw_;
  _worship_withdraw_ = NULL;
  return temp;
}
inline void guild::set_allocated__worship_withdraw(::up::guild_worship_withdraw* _worship_withdraw) {
  delete _worship_withdraw_;
  _worship_withdraw_ = _worship_withdraw;
  if (_worship_withdraw) {
    set_has__worship_withdraw();
  } else {
    clear_has__worship_withdraw();
  }
}

// optional .up.guild_qurey_hh_detail _query_hh_detail = 19;
inline bool guild::has__query_hh_detail() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void guild::set_has__query_hh_detail() {
  _has_bits_[0] |= 0x00040000u;
}
inline void guild::clear_has__query_hh_detail() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void guild::clear__query_hh_detail() {
  if (_query_hh_detail_ != NULL) _query_hh_detail_->::up::guild_qurey_hh_detail::Clear();
  clear_has__query_hh_detail();
}
inline const ::up::guild_qurey_hh_detail& guild::_query_hh_detail() const {
  return _query_hh_detail_ != NULL ? *_query_hh_detail_ : *default_instance_->_query_hh_detail_;
}
inline ::up::guild_qurey_hh_detail* guild::mutable__query_hh_detail() {
  set_has__query_hh_detail();
  if (_query_hh_detail_ == NULL) _query_hh_detail_ = new ::up::guild_qurey_hh_detail;
  return _query_hh_detail_;
}
inline ::up::guild_qurey_hh_detail* guild::release__query_hh_detail() {
  clear_has__query_hh_detail();
  ::up::guild_qurey_hh_detail* temp = _query_hh_detail_;
  _query_hh_detail_ = NULL;
  return temp;
}
inline void guild::set_allocated__query_hh_detail(::up::guild_qurey_hh_detail* _query_hh_detail) {
  delete _query_hh_detail_;
  _query_hh_detail_ = _query_hh_detail;
  if (_query_hh_detail) {
    set_has__query_hh_detail();
  } else {
    clear_has__query_hh_detail();
  }
}

// optional .up.guild_instance_query _instance_query = 20;
inline bool guild::has__instance_query() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void guild::set_has__instance_query() {
  _has_bits_[0] |= 0x00080000u;
}
inline void guild::clear_has__instance_query() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void guild::clear__instance_query() {
  if (_instance_query_ != NULL) _instance_query_->::up::guild_instance_query::Clear();
  clear_has__instance_query();
}
inline const ::up::guild_instance_query& guild::_instance_query() const {
  return _instance_query_ != NULL ? *_instance_query_ : *default_instance_->_instance_query_;
}
inline ::up::guild_instance_query* guild::mutable__instance_query() {
  set_has__instance_query();
  if (_instance_query_ == NULL) _instance_query_ = new ::up::guild_instance_query;
  return _instance_query_;
}
inline ::up::guild_instance_query* guild::release__instance_query() {
  clear_has__instance_query();
  ::up::guild_instance_query* temp = _instance_query_;
  _instance_query_ = NULL;
  return temp;
}
inline void guild::set_allocated__instance_query(::up::guild_instance_query* _instance_query) {
  delete _instance_query_;
  _instance_query_ = _instance_query;
  if (_instance_query) {
    set_has__instance_query();
  } else {
    clear_has__instance_query();
  }
}

// optional .up.guild_instance_detail _instance_detail = 21;
inline bool guild::has__instance_detail() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void guild::set_has__instance_detail() {
  _has_bits_[0] |= 0x00100000u;
}
inline void guild::clear_has__instance_detail() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void guild::clear__instance_detail() {
  if (_instance_detail_ != NULL) _instance_detail_->::up::guild_instance_detail::Clear();
  clear_has__instance_detail();
}
inline const ::up::guild_instance_detail& guild::_instance_detail() const {
  return _instance_detail_ != NULL ? *_instance_detail_ : *default_instance_->_instance_detail_;
}
inline ::up::guild_instance_detail* guild::mutable__instance_detail() {
  set_has__instance_detail();
  if (_instance_detail_ == NULL) _instance_detail_ = new ::up::guild_instance_detail;
  return _instance_detail_;
}
inline ::up::guild_instance_detail* guild::release__instance_detail() {
  clear_has__instance_detail();
  ::up::guild_instance_detail* temp = _instance_detail_;
  _instance_detail_ = NULL;
  return temp;
}
inline void guild::set_allocated__instance_detail(::up::guild_instance_detail* _instance_detail) {
  delete _instance_detail_;
  _instance_detail_ = _instance_detail;
  if (_instance_detail) {
    set_has__instance_detail();
  } else {
    clear_has__instance_detail();
  }
}

// optional .up.guild_instance_start _instance_start = 22;
inline bool guild::has__instance_start() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void guild::set_has__instance_start() {
  _has_bits_[0] |= 0x00200000u;
}
inline void guild::clear_has__instance_start() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void guild::clear__instance_start() {
  if (_instance_start_ != NULL) _instance_start_->::up::guild_instance_start::Clear();
  clear_has__instance_start();
}
inline const ::up::guild_instance_start& guild::_instance_start() const {
  return _instance_start_ != NULL ? *_instance_start_ : *default_instance_->_instance_start_;
}
inline ::up::guild_instance_start* guild::mutable__instance_start() {
  set_has__instance_start();
  if (_instance_start_ == NULL) _instance_start_ = new ::up::guild_instance_start;
  return _instance_start_;
}
inline ::up::guild_instance_start* guild::release__instance_start() {
  clear_has__instance_start();
  ::up::guild_instance_start* temp = _instance_start_;
  _instance_start_ = NULL;
  return temp;
}
inline void guild::set_allocated__instance_start(::up::guild_instance_start* _instance_start) {
  delete _instance_start_;
  _instance_start_ = _instance_start;
  if (_instance_start) {
    set_has__instance_start();
  } else {
    clear_has__instance_start();
  }
}

// optional .up.guild_instance_end _instance_end = 23;
inline bool guild::has__instance_end() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void guild::set_has__instance_end() {
  _has_bits_[0] |= 0x00400000u;
}
inline void guild::clear_has__instance_end() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void guild::clear__instance_end() {
  if (_instance_end_ != NULL) _instance_end_->::up::guild_instance_end::Clear();
  clear_has__instance_end();
}
inline const ::up::guild_instance_end& guild::_instance_end() const {
  return _instance_end_ != NULL ? *_instance_end_ : *default_instance_->_instance_end_;
}
inline ::up::guild_instance_end* guild::mutable__instance_end() {
  set_has__instance_end();
  if (_instance_end_ == NULL) _instance_end_ = new ::up::guild_instance_end;
  return _instance_end_;
}
inline ::up::guild_instance_end* guild::release__instance_end() {
  clear_has__instance_end();
  ::up::guild_instance_end* temp = _instance_end_;
  _instance_end_ = NULL;
  return temp;
}
inline void guild::set_allocated__instance_end(::up::guild_instance_end* _instance_end) {
  delete _instance_end_;
  _instance_end_ = _instance_end;
  if (_instance_end) {
    set_has__instance_end();
  } else {
    clear_has__instance_end();
  }
}

// optional .up.guild_instance_drop _instance_drop = 24;
inline bool guild::has__instance_drop() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void guild::set_has__instance_drop() {
  _has_bits_[0] |= 0x00800000u;
}
inline void guild::clear_has__instance_drop() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void guild::clear__instance_drop() {
  if (_instance_drop_ != NULL) _instance_drop_->::up::guild_instance_drop::Clear();
  clear_has__instance_drop();
}
inline const ::up::guild_instance_drop& guild::_instance_drop() const {
  return _instance_drop_ != NULL ? *_instance_drop_ : *default_instance_->_instance_drop_;
}
inline ::up::guild_instance_drop* guild::mutable__instance_drop() {
  set_has__instance_drop();
  if (_instance_drop_ == NULL) _instance_drop_ = new ::up::guild_instance_drop;
  return _instance_drop_;
}
inline ::up::guild_instance_drop* guild::release__instance_drop() {
  clear_has__instance_drop();
  ::up::guild_instance_drop* temp = _instance_drop_;
  _instance_drop_ = NULL;
  return temp;
}
inline void guild::set_allocated__instance_drop(::up::guild_instance_drop* _instance_drop) {
  delete _instance_drop_;
  _instance_drop_ = _instance_drop;
  if (_instance_drop) {
    set_has__instance_drop();
  } else {
    clear_has__instance_drop();
  }
}

// optional .up.guild_instance_open _instance_open = 25;
inline bool guild::has__instance_open() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void guild::set_has__instance_open() {
  _has_bits_[0] |= 0x01000000u;
}
inline void guild::clear_has__instance_open() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void guild::clear__instance_open() {
  if (_instance_open_ != NULL) _instance_open_->::up::guild_instance_open::Clear();
  clear_has__instance_open();
}
inline const ::up::guild_instance_open& guild::_instance_open() const {
  return _instance_open_ != NULL ? *_instance_open_ : *default_instance_->_instance_open_;
}
inline ::up::guild_instance_open* guild::mutable__instance_open() {
  set_has__instance_open();
  if (_instance_open_ == NULL) _instance_open_ = new ::up::guild_instance_open;
  return _instance_open_;
}
inline ::up::guild_instance_open* guild::release__instance_open() {
  clear_has__instance_open();
  ::up::guild_instance_open* temp = _instance_open_;
  _instance_open_ = NULL;
  return temp;
}
inline void guild::set_allocated__instance_open(::up::guild_instance_open* _instance_open) {
  delete _instance_open_;
  _instance_open_ = _instance_open;
  if (_instance_open) {
    set_has__instance_open();
  } else {
    clear_has__instance_open();
  }
}

// optional .up.guild_instance_apply _instance_apply = 26;
inline bool guild::has__instance_apply() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void guild::set_has__instance_apply() {
  _has_bits_[0] |= 0x02000000u;
}
inline void guild::clear_has__instance_apply() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void guild::clear__instance_apply() {
  if (_instance_apply_ != NULL) _instance_apply_->::up::guild_instance_apply::Clear();
  clear_has__instance_apply();
}
inline const ::up::guild_instance_apply& guild::_instance_apply() const {
  return _instance_apply_ != NULL ? *_instance_apply_ : *default_instance_->_instance_apply_;
}
inline ::up::guild_instance_apply* guild::mutable__instance_apply() {
  set_has__instance_apply();
  if (_instance_apply_ == NULL) _instance_apply_ = new ::up::guild_instance_apply;
  return _instance_apply_;
}
inline ::up::guild_instance_apply* guild::release__instance_apply() {
  clear_has__instance_apply();
  ::up::guild_instance_apply* temp = _instance_apply_;
  _instance_apply_ = NULL;
  return temp;
}
inline void guild::set_allocated__instance_apply(::up::guild_instance_apply* _instance_apply) {
  delete _instance_apply_;
  _instance_apply_ = _instance_apply;
  if (_instance_apply) {
    set_has__instance_apply();
  } else {
    clear_has__instance_apply();
  }
}

// optional .up.guild_drop_info _drop_info = 27;
inline bool guild::has__drop_info() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void guild::set_has__drop_info() {
  _has_bits_[0] |= 0x04000000u;
}
inline void guild::clear_has__drop_info() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void guild::clear__drop_info() {
  if (_drop_info_ != NULL) _drop_info_->::up::guild_drop_info::Clear();
  clear_has__drop_info();
}
inline const ::up::guild_drop_info& guild::_drop_info() const {
  return _drop_info_ != NULL ? *_drop_info_ : *default_instance_->_drop_info_;
}
inline ::up::guild_drop_info* guild::mutable__drop_info() {
  set_has__drop_info();
  if (_drop_info_ == NULL) _drop_info_ = new ::up::guild_drop_info;
  return _drop_info_;
}
inline ::up::guild_drop_info* guild::release__drop_info() {
  clear_has__drop_info();
  ::up::guild_drop_info* temp = _drop_info_;
  _drop_info_ = NULL;
  return temp;
}
inline void guild::set_allocated__drop_info(::up::guild_drop_info* _drop_info) {
  delete _drop_info_;
  _drop_info_ = _drop_info;
  if (_drop_info) {
    set_has__drop_info();
  } else {
    clear_has__drop_info();
  }
}

// optional .up.guild_drop_give _drop_give = 28;
inline bool guild::has__drop_give() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void guild::set_has__drop_give() {
  _has_bits_[0] |= 0x08000000u;
}
inline void guild::clear_has__drop_give() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void guild::clear__drop_give() {
  if (_drop_give_ != NULL) _drop_give_->::up::guild_drop_give::Clear();
  clear_has__drop_give();
}
inline const ::up::guild_drop_give& guild::_drop_give() const {
  return _drop_give_ != NULL ? *_drop_give_ : *default_instance_->_drop_give_;
}
inline ::up::guild_drop_give* guild::mutable__drop_give() {
  set_has__drop_give();
  if (_drop_give_ == NULL) _drop_give_ = new ::up::guild_drop_give;
  return _drop_give_;
}
inline ::up::guild_drop_give* guild::release__drop_give() {
  clear_has__drop_give();
  ::up::guild_drop_give* temp = _drop_give_;
  _drop_give_ = NULL;
  return temp;
}
inline void guild::set_allocated__drop_give(::up::guild_drop_give* _drop_give) {
  delete _drop_give_;
  _drop_give_ = _drop_give;
  if (_drop_give) {
    set_has__drop_give();
  } else {
    clear_has__drop_give();
  }
}

// optional .up.guild_instance_damage _instance_damage = 29;
inline bool guild::has__instance_damage() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void guild::set_has__instance_damage() {
  _has_bits_[0] |= 0x10000000u;
}
inline void guild::clear_has__instance_damage() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void guild::clear__instance_damage() {
  if (_instance_damage_ != NULL) _instance_damage_->::up::guild_instance_damage::Clear();
  clear_has__instance_damage();
}
inline const ::up::guild_instance_damage& guild::_instance_damage() const {
  return _instance_damage_ != NULL ? *_instance_damage_ : *default_instance_->_instance_damage_;
}
inline ::up::guild_instance_damage* guild::mutable__instance_damage() {
  set_has__instance_damage();
  if (_instance_damage_ == NULL) _instance_damage_ = new ::up::guild_instance_damage;
  return _instance_damage_;
}
inline ::up::guild_instance_damage* guild::release__instance_damage() {
  clear_has__instance_damage();
  ::up::guild_instance_damage* temp = _instance_damage_;
  _instance_damage_ = NULL;
  return temp;
}
inline void guild::set_allocated__instance_damage(::up::guild_instance_damage* _instance_damage) {
  delete _instance_damage_;
  _instance_damage_ = _instance_damage;
  if (_instance_damage) {
    set_has__instance_damage();
  } else {
    clear_has__instance_damage();
  }
}

// optional .up.guild_items_history _items_history = 30;
inline bool guild::has__items_history() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void guild::set_has__items_history() {
  _has_bits_[0] |= 0x20000000u;
}
inline void guild::clear_has__items_history() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void guild::clear__items_history() {
  if (_items_history_ != NULL) _items_history_->::up::guild_items_history::Clear();
  clear_has__items_history();
}
inline const ::up::guild_items_history& guild::_items_history() const {
  return _items_history_ != NULL ? *_items_history_ : *default_instance_->_items_history_;
}
inline ::up::guild_items_history* guild::mutable__items_history() {
  set_has__items_history();
  if (_items_history_ == NULL) _items_history_ = new ::up::guild_items_history;
  return _items_history_;
}
inline ::up::guild_items_history* guild::release__items_history() {
  clear_has__items_history();
  ::up::guild_items_history* temp = _items_history_;
  _items_history_ = NULL;
  return temp;
}
inline void guild::set_allocated__items_history(::up::guild_items_history* _items_history) {
  delete _items_history_;
  _items_history_ = _items_history;
  if (_items_history) {
    set_has__items_history();
  } else {
    clear_has__items_history();
  }
}

// optional .up.guild_jump _guild_jump = 31;
inline bool guild::has__guild_jump() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void guild::set_has__guild_jump() {
  _has_bits_[0] |= 0x40000000u;
}
inline void guild::clear_has__guild_jump() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void guild::clear__guild_jump() {
  if (_guild_jump_ != NULL) _guild_jump_->::up::guild_jump::Clear();
  clear_has__guild_jump();
}
inline const ::up::guild_jump& guild::_guild_jump() const {
  return _guild_jump_ != NULL ? *_guild_jump_ : *default_instance_->_guild_jump_;
}
inline ::up::guild_jump* guild::mutable__guild_jump() {
  set_has__guild_jump();
  if (_guild_jump_ == NULL) _guild_jump_ = new ::up::guild_jump;
  return _guild_jump_;
}
inline ::up::guild_jump* guild::release__guild_jump() {
  clear_has__guild_jump();
  ::up::guild_jump* temp = _guild_jump_;
  _guild_jump_ = NULL;
  return temp;
}
inline void guild::set_allocated__guild_jump(::up::guild_jump* _guild_jump) {
  delete _guild_jump_;
  _guild_jump_ = _guild_jump;
  if (_guild_jump) {
    set_has__guild_jump();
  } else {
    clear_has__guild_jump();
  }
}

// optional .up.guild_app_queue _guild_app_queue = 32;
inline bool guild::has__guild_app_queue() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void guild::set_has__guild_app_queue() {
  _has_bits_[0] |= 0x80000000u;
}
inline void guild::clear_has__guild_app_queue() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void guild::clear__guild_app_queue() {
  if (_guild_app_queue_ != NULL) _guild_app_queue_->::up::guild_app_queue::Clear();
  clear_has__guild_app_queue();
}
inline const ::up::guild_app_queue& guild::_guild_app_queue() const {
  return _guild_app_queue_ != NULL ? *_guild_app_queue_ : *default_instance_->_guild_app_queue_;
}
inline ::up::guild_app_queue* guild::mutable__guild_app_queue() {
  set_has__guild_app_queue();
  if (_guild_app_queue_ == NULL) _guild_app_queue_ = new ::up::guild_app_queue;
  return _guild_app_queue_;
}
inline ::up::guild_app_queue* guild::release__guild_app_queue() {
  clear_has__guild_app_queue();
  ::up::guild_app_queue* temp = _guild_app_queue_;
  _guild_app_queue_ = NULL;
  return temp;
}
inline void guild::set_allocated__guild_app_queue(::up::guild_app_queue* _guild_app_queue) {
  delete _guild_app_queue_;
  _guild_app_queue_ = _guild_app_queue;
  if (_guild_app_queue) {
    set_has__guild_app_queue();
  } else {
    clear_has__guild_app_queue();
  }
}

// optional .up.guild_prepare_instance _instance_prepare = 33;
inline bool guild::has__instance_prepare() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void guild::set_has__instance_prepare() {
  _has_bits_[1] |= 0x00000001u;
}
inline void guild::clear_has__instance_prepare() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void guild::clear__instance_prepare() {
  if (_instance_prepare_ != NULL) _instance_prepare_->::up::guild_prepare_instance::Clear();
  clear_has__instance_prepare();
}
inline const ::up::guild_prepare_instance& guild::_instance_prepare() const {
  return _instance_prepare_ != NULL ? *_instance_prepare_ : *default_instance_->_instance_prepare_;
}
inline ::up::guild_prepare_instance* guild::mutable__instance_prepare() {
  set_has__instance_prepare();
  if (_instance_prepare_ == NULL) _instance_prepare_ = new ::up::guild_prepare_instance;
  return _instance_prepare_;
}
inline ::up::guild_prepare_instance* guild::release__instance_prepare() {
  clear_has__instance_prepare();
  ::up::guild_prepare_instance* temp = _instance_prepare_;
  _instance_prepare_ = NULL;
  return temp;
}
inline void guild::set_allocated__instance_prepare(::up::guild_prepare_instance* _instance_prepare) {
  delete _instance_prepare_;
  _instance_prepare_ = _instance_prepare;
  if (_instance_prepare) {
    set_has__instance_prepare();
  } else {
    clear_has__instance_prepare();
  }
}

// optional .up.guild_query_member _guild_query_member = 34;
inline bool guild::has__guild_query_member() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void guild::set_has__guild_query_member() {
  _has_bits_[1] |= 0x00000002u;
}
inline void guild::clear_has__guild_query_member() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void guild::clear__guild_query_member() {
  if (_guild_query_member_ != NULL) _guild_query_member_->::up::guild_query_member::Clear();
  clear_has__guild_query_member();
}
inline const ::up::guild_query_member& guild::_guild_query_member() const {
  return _guild_query_member_ != NULL ? *_guild_query_member_ : *default_instance_->_guild_query_member_;
}
inline ::up::guild_query_member* guild::mutable__guild_query_member() {
  set_has__guild_query_member();
  if (_guild_query_member_ == NULL) _guild_query_member_ = new ::up::guild_query_member;
  return _guild_query_member_;
}
inline ::up::guild_query_member* guild::release__guild_query_member() {
  clear_has__guild_query_member();
  ::up::guild_query_member* temp = _guild_query_member_;
  _guild_query_member_ = NULL;
  return temp;
}
inline void guild::set_allocated__guild_query_member(::up::guild_query_member* _guild_query_member) {
  delete _guild_query_member_;
  _guild_query_member_ = _guild_query_member;
  if (_guild_query_member) {
    set_has__guild_query_member();
  } else {
    clear_has__guild_query_member();
  }
}

// optional .up.guild_stage_rank _guild_stage_rank = 35;
inline bool guild::has__guild_stage_rank() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void guild::set_has__guild_stage_rank() {
  _has_bits_[1] |= 0x00000004u;
}
inline void guild::clear_has__guild_stage_rank() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void guild::clear__guild_stage_rank() {
  if (_guild_stage_rank_ != NULL) _guild_stage_rank_->::up::guild_stage_rank::Clear();
  clear_has__guild_stage_rank();
}
inline const ::up::guild_stage_rank& guild::_guild_stage_rank() const {
  return _guild_stage_rank_ != NULL ? *_guild_stage_rank_ : *default_instance_->_guild_stage_rank_;
}
inline ::up::guild_stage_rank* guild::mutable__guild_stage_rank() {
  set_has__guild_stage_rank();
  if (_guild_stage_rank_ == NULL) _guild_stage_rank_ = new ::up::guild_stage_rank;
  return _guild_stage_rank_;
}
inline ::up::guild_stage_rank* guild::release__guild_stage_rank() {
  clear_has__guild_stage_rank();
  ::up::guild_stage_rank* temp = _guild_stage_rank_;
  _guild_stage_rank_ = NULL;
  return temp;
}
inline void guild::set_allocated__guild_stage_rank(::up::guild_stage_rank* _guild_stage_rank) {
  delete _guild_stage_rank_;
  _guild_stage_rank_ = _guild_stage_rank;
  if (_guild_stage_rank) {
    set_has__guild_stage_rank();
  } else {
    clear_has__guild_stage_rank();
  }
}

// optional .up.guild_set_jump _set_jump = 36;
inline bool guild::has__set_jump() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void guild::set_has__set_jump() {
  _has_bits_[1] |= 0x00000008u;
}
inline void guild::clear_has__set_jump() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void guild::clear__set_jump() {
  if (_set_jump_ != NULL) _set_jump_->::up::guild_set_jump::Clear();
  clear_has__set_jump();
}
inline const ::up::guild_set_jump& guild::_set_jump() const {
  return _set_jump_ != NULL ? *_set_jump_ : *default_instance_->_set_jump_;
}
inline ::up::guild_set_jump* guild::mutable__set_jump() {
  set_has__set_jump();
  if (_set_jump_ == NULL) _set_jump_ = new ::up::guild_set_jump;
  return _set_jump_;
}
inline ::up::guild_set_jump* guild::release__set_jump() {
  clear_has__set_jump();
  ::up::guild_set_jump* temp = _set_jump_;
  _set_jump_ = NULL;
  return temp;
}
inline void guild::set_allocated__set_jump(::up::guild_set_jump* _set_jump) {
  delete _set_jump_;
  _set_jump_ = _set_jump;
  if (_set_jump) {
    set_has__set_jump();
  } else {
    clear_has__set_jump();
  }
}

// -------------------------------------------------------------------

// guild_set_jump

// required .up.guild_set_jump.is_can_jump _is_can_jump = 1;
inline bool guild_set_jump::has__is_can_jump() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_set_jump::set_has__is_can_jump() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_set_jump::clear_has__is_can_jump() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_set_jump::clear__is_can_jump() {
  _is_can_jump_ = 1;
  clear_has__is_can_jump();
}
inline ::up::guild_set_jump_is_can_jump guild_set_jump::_is_can_jump() const {
  return static_cast< ::up::guild_set_jump_is_can_jump >(_is_can_jump_);
}
inline void guild_set_jump::set__is_can_jump(::up::guild_set_jump_is_can_jump value) {
  assert(::up::guild_set_jump_is_can_jump_IsValid(value));
  set_has__is_can_jump();
  _is_can_jump_ = value;
}

// -------------------------------------------------------------------

// guild_stage_rank

// required uint32 _stage_id = 1;
inline bool guild_stage_rank::has__stage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_stage_rank::set_has__stage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_stage_rank::clear_has__stage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_stage_rank::clear__stage_id() {
  _stage_id_ = 0u;
  clear_has__stage_id();
}
inline ::google::protobuf::uint32 guild_stage_rank::_stage_id() const {
  return _stage_id_;
}
inline void guild_stage_rank::set__stage_id(::google::protobuf::uint32 value) {
  set_has__stage_id();
  _stage_id_ = value;
}

// -------------------------------------------------------------------

// guild_query_member

// -------------------------------------------------------------------

// guild_prepare_instance

// required uint32 _stage_id = 1;
inline bool guild_prepare_instance::has__stage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_prepare_instance::set_has__stage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_prepare_instance::clear_has__stage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_prepare_instance::clear__stage_id() {
  _stage_id_ = 0u;
  clear_has__stage_id();
}
inline ::google::protobuf::uint32 guild_prepare_instance::_stage_id() const {
  return _stage_id_;
}
inline void guild_prepare_instance::set__stage_id(::google::protobuf::uint32 value) {
  set_has__stage_id();
  _stage_id_ = value;
}

// -------------------------------------------------------------------

// guild_app_queue

// required uint32 _item_id = 1;
inline bool guild_app_queue::has__item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_app_queue::set_has__item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_app_queue::clear_has__item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_app_queue::clear__item_id() {
  _item_id_ = 0u;
  clear_has__item_id();
}
inline ::google::protobuf::uint32 guild_app_queue::_item_id() const {
  return _item_id_;
}
inline void guild_app_queue::set__item_id(::google::protobuf::uint32 value) {
  set_has__item_id();
  _item_id_ = value;
}

// -------------------------------------------------------------------

// guild_jump

// -------------------------------------------------------------------

// guild_items_history

// -------------------------------------------------------------------

// guild_drop_give

// required uint32 _item_id = 1;
inline bool guild_drop_give::has__item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_drop_give::set_has__item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_drop_give::clear_has__item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_drop_give::clear__item_id() {
  _item_id_ = 0u;
  clear_has__item_id();
}
inline ::google::protobuf::uint32 guild_drop_give::_item_id() const {
  return _item_id_;
}
inline void guild_drop_give::set__item_id(::google::protobuf::uint32 value) {
  set_has__item_id();
  _item_id_ = value;
}

// required uint32 _raid_id = 2;
inline bool guild_drop_give::has__raid_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild_drop_give::set_has__raid_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild_drop_give::clear_has__raid_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild_drop_give::clear__raid_id() {
  _raid_id_ = 0u;
  clear_has__raid_id();
}
inline ::google::protobuf::uint32 guild_drop_give::_raid_id() const {
  return _raid_id_;
}
inline void guild_drop_give::set__raid_id(::google::protobuf::uint32 value) {
  set_has__raid_id();
  _raid_id_ = value;
}

// required uint32 _user_id = 3;
inline bool guild_drop_give::has__user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void guild_drop_give::set_has__user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void guild_drop_give::clear_has__user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void guild_drop_give::clear__user_id() {
  _user_id_ = 0u;
  clear_has__user_id();
}
inline ::google::protobuf::uint32 guild_drop_give::_user_id() const {
  return _user_id_;
}
inline void guild_drop_give::set__user_id(::google::protobuf::uint32 value) {
  set_has__user_id();
  _user_id_ = value;
}

// required uint32 _time_out_end = 4;
inline bool guild_drop_give::has__time_out_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void guild_drop_give::set_has__time_out_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void guild_drop_give::clear_has__time_out_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void guild_drop_give::clear__time_out_end() {
  _time_out_end_ = 0u;
  clear_has__time_out_end();
}
inline ::google::protobuf::uint32 guild_drop_give::_time_out_end() const {
  return _time_out_end_;
}
inline void guild_drop_give::set__time_out_end(::google::protobuf::uint32 value) {
  set_has__time_out_end();
  _time_out_end_ = value;
}

// -------------------------------------------------------------------

// guild_instance_damage

// required uint32 _raid_id = 1;
inline bool guild_instance_damage::has__raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_instance_damage::set_has__raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_instance_damage::clear_has__raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_instance_damage::clear__raid_id() {
  _raid_id_ = 0u;
  clear_has__raid_id();
}
inline ::google::protobuf::uint32 guild_instance_damage::_raid_id() const {
  return _raid_id_;
}
inline void guild_instance_damage::set__raid_id(::google::protobuf::uint32 value) {
  set_has__raid_id();
  _raid_id_ = value;
}

// -------------------------------------------------------------------

// guild_drop_info

// -------------------------------------------------------------------

// guild_instance_apply

// required uint32 _raid_id = 1;
inline bool guild_instance_apply::has__raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_instance_apply::set_has__raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_instance_apply::clear_has__raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_instance_apply::clear__raid_id() {
  _raid_id_ = 0u;
  clear_has__raid_id();
}
inline ::google::protobuf::uint32 guild_instance_apply::_raid_id() const {
  return _raid_id_;
}
inline void guild_instance_apply::set__raid_id(::google::protobuf::uint32 value) {
  set_has__raid_id();
  _raid_id_ = value;
}

// required uint32 _item_id = 2;
inline bool guild_instance_apply::has__item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild_instance_apply::set_has__item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild_instance_apply::clear_has__item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild_instance_apply::clear__item_id() {
  _item_id_ = 0u;
  clear_has__item_id();
}
inline ::google::protobuf::uint32 guild_instance_apply::_item_id() const {
  return _item_id_;
}
inline void guild_instance_apply::set__item_id(::google::protobuf::uint32 value) {
  set_has__item_id();
  _item_id_ = value;
}

// -------------------------------------------------------------------

// guild_instance_start

// required uint32 _stage_id = 1;
inline bool guild_instance_start::has__stage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_instance_start::set_has__stage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_instance_start::clear_has__stage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_instance_start::clear__stage_id() {
  _stage_id_ = 0u;
  clear_has__stage_id();
}
inline ::google::protobuf::uint32 guild_instance_start::_stage_id() const {
  return _stage_id_;
}
inline void guild_instance_start::set__stage_id(::google::protobuf::uint32 value) {
  set_has__stage_id();
  _stage_id_ = value;
}

// -------------------------------------------------------------------

// guild_instance_end

// required .up.battle_result _result = 1;
inline bool guild_instance_end::has__result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_instance_end::set_has__result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_instance_end::clear_has__result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_instance_end::clear__result() {
  _result_ = 0;
  clear_has__result();
}
inline ::up::battle_result guild_instance_end::_result() const {
  return static_cast< ::up::battle_result >(_result_);
}
inline void guild_instance_end::set__result(::up::battle_result value) {
  assert(::up::battle_result_IsValid(value));
  set_has__result();
  _result_ = value;
}

// repeated uint32 _hp_info = 2;
inline int guild_instance_end::_hp_info_size() const {
  return _hp_info_.size();
}
inline void guild_instance_end::clear__hp_info() {
  _hp_info_.Clear();
}
inline ::google::protobuf::uint32 guild_instance_end::_hp_info(int index) const {
  return _hp_info_.Get(index);
}
inline void guild_instance_end::set__hp_info(int index, ::google::protobuf::uint32 value) {
  _hp_info_.Set(index, value);
}
inline void guild_instance_end::add__hp_info(::google::protobuf::uint32 value) {
  _hp_info_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
guild_instance_end::_hp_info() const {
  return _hp_info_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
guild_instance_end::mutable__hp_info() {
  return &_hp_info_;
}

// required uint32 _wave = 3;
inline bool guild_instance_end::has__wave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void guild_instance_end::set_has__wave() {
  _has_bits_[0] |= 0x00000004u;
}
inline void guild_instance_end::clear_has__wave() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void guild_instance_end::clear__wave() {
  _wave_ = 0u;
  clear_has__wave();
}
inline ::google::protobuf::uint32 guild_instance_end::_wave() const {
  return _wave_;
}
inline void guild_instance_end::set__wave(::google::protobuf::uint32 value) {
  set_has__wave();
  _wave_ = value;
}

// required uint32 _damage = 4;
inline bool guild_instance_end::has__damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void guild_instance_end::set_has__damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void guild_instance_end::clear_has__damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void guild_instance_end::clear__damage() {
  _damage_ = 0u;
  clear_has__damage();
}
inline ::google::protobuf::uint32 guild_instance_end::_damage() const {
  return _damage_;
}
inline void guild_instance_end::set__damage(::google::protobuf::uint32 value) {
  set_has__damage();
  _damage_ = value;
}

// required uint32 _progress = 5;
inline bool guild_instance_end::has__progress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void guild_instance_end::set_has__progress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void guild_instance_end::clear_has__progress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void guild_instance_end::clear__progress() {
  _progress_ = 0u;
  clear_has__progress();
}
inline ::google::protobuf::uint32 guild_instance_end::_progress() const {
  return _progress_;
}
inline void guild_instance_end::set__progress(::google::protobuf::uint32 value) {
  set_has__progress();
  _progress_ = value;
}

// required uint32 _stage_progress = 6;
inline bool guild_instance_end::has__stage_progress() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void guild_instance_end::set_has__stage_progress() {
  _has_bits_[0] |= 0x00000020u;
}
inline void guild_instance_end::clear_has__stage_progress() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void guild_instance_end::clear__stage_progress() {
  _stage_progress_ = 0u;
  clear_has__stage_progress();
}
inline ::google::protobuf::uint32 guild_instance_end::_stage_progress() const {
  return _stage_progress_;
}
inline void guild_instance_end::set__stage_progress(::google::protobuf::uint32 value) {
  set_has__stage_progress();
  _stage_progress_ = value;
}

// repeated uint32 _oprations = 7;
inline int guild_instance_end::_oprations_size() const {
  return _oprations_.size();
}
inline void guild_instance_end::clear__oprations() {
  _oprations_.Clear();
}
inline ::google::protobuf::uint32 guild_instance_end::_oprations(int index) const {
  return _oprations_.Get(index);
}
inline void guild_instance_end::set__oprations(int index, ::google::protobuf::uint32 value) {
  _oprations_.Set(index, value);
}
inline void guild_instance_end::add__oprations(::google::protobuf::uint32 value) {
  _oprations_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
guild_instance_end::_oprations() const {
  return _oprations_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
guild_instance_end::mutable__oprations() {
  return &_oprations_;
}

// repeated uint32 _heroes = 8;
inline int guild_instance_end::_heroes_size() const {
  return _heroes_.size();
}
inline void guild_instance_end::clear__heroes() {
  _heroes_.Clear();
}
inline ::google::protobuf::uint32 guild_instance_end::_heroes(int index) const {
  return _heroes_.Get(index);
}
inline void guild_instance_end::set__heroes(int index, ::google::protobuf::uint32 value) {
  _heroes_.Set(index, value);
}
inline void guild_instance_end::add__heroes(::google::protobuf::uint32 value) {
  _heroes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
guild_instance_end::_heroes() const {
  return _heroes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
guild_instance_end::mutable__heroes() {
  return &_heroes_;
}

// -------------------------------------------------------------------

// guild_instance_drop

// required uint32 _raid_id = 1;
inline bool guild_instance_drop::has__raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_instance_drop::set_has__raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_instance_drop::clear_has__raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_instance_drop::clear__raid_id() {
  _raid_id_ = 0u;
  clear_has__raid_id();
}
inline ::google::protobuf::uint32 guild_instance_drop::_raid_id() const {
  return _raid_id_;
}
inline void guild_instance_drop::set__raid_id(::google::protobuf::uint32 value) {
  set_has__raid_id();
  _raid_id_ = value;
}

// -------------------------------------------------------------------

// guild_instance_open

// required uint32 _raid_id = 1;
inline bool guild_instance_open::has__raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_instance_open::set_has__raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_instance_open::clear_has__raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_instance_open::clear__raid_id() {
  _raid_id_ = 0u;
  clear_has__raid_id();
}
inline ::google::protobuf::uint32 guild_instance_open::_raid_id() const {
  return _raid_id_;
}
inline void guild_instance_open::set__raid_id(::google::protobuf::uint32 value) {
  set_has__raid_id();
  _raid_id_ = value;
}

// -------------------------------------------------------------------

// guild_instance_query

// -------------------------------------------------------------------

// guild_instance_detail

// required uint32 _stage_id = 1;
inline bool guild_instance_detail::has__stage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_instance_detail::set_has__stage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_instance_detail::clear_has__stage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_instance_detail::clear__stage_id() {
  _stage_id_ = 0u;
  clear_has__stage_id();
}
inline ::google::protobuf::uint32 guild_instance_detail::_stage_id() const {
  return _stage_id_;
}
inline void guild_instance_detail::set__stage_id(::google::protobuf::uint32 value) {
  set_has__stage_id();
  _stage_id_ = value;
}

// -------------------------------------------------------------------

// guild_create

// required string _name = 1;
inline bool guild_create::has__name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_create::set_has__name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_create::clear_has__name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_create::clear__name() {
  if (_name_ != &::google::protobuf::internal::kEmptyString) {
    _name_->clear();
  }
  clear_has__name();
}
inline const ::std::string& guild_create::_name() const {
  return *_name_;
}
inline void guild_create::set__name(const ::std::string& value) {
  set_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    _name_ = new ::std::string;
  }
  _name_->assign(value);
}
inline void guild_create::set__name(const char* value) {
  set_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    _name_ = new ::std::string;
  }
  _name_->assign(value);
}
inline void guild_create::set__name(const char* value, size_t size) {
  set_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    _name_ = new ::std::string;
  }
  _name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* guild_create::mutable__name() {
  set_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    _name_ = new ::std::string;
  }
  return _name_;
}
inline ::std::string* guild_create::release__name() {
  clear_has__name();
  if (_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _name_;
    _name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void guild_create::set_allocated__name(::std::string* _name) {
  if (_name_ != &::google::protobuf::internal::kEmptyString) {
    delete _name_;
  }
  if (_name) {
    set_has__name();
    _name_ = _name;
  } else {
    clear_has__name();
    _name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 _avatar = 2;
inline bool guild_create::has__avatar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild_create::set_has__avatar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild_create::clear_has__avatar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild_create::clear__avatar() {
  _avatar_ = 0u;
  clear_has__avatar();
}
inline ::google::protobuf::uint32 guild_create::_avatar() const {
  return _avatar_;
}
inline void guild_create::set__avatar(::google::protobuf::uint32 value) {
  set_has__avatar();
  _avatar_ = value;
}

// -------------------------------------------------------------------

// guild_dismiss

// -------------------------------------------------------------------

// guild_list

// -------------------------------------------------------------------

// guild_search

// required uint32 _guild_id = 1;
inline bool guild_search::has__guild_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_search::set_has__guild_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_search::clear_has__guild_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_search::clear__guild_id() {
  _guild_id_ = 0u;
  clear_has__guild_id();
}
inline ::google::protobuf::uint32 guild_search::_guild_id() const {
  return _guild_id_;
}
inline void guild_search::set__guild_id(::google::protobuf::uint32 value) {
  set_has__guild_id();
  _guild_id_ = value;
}

// -------------------------------------------------------------------

// guild_join

// required uint32 _guild_id = 1;
inline bool guild_join::has__guild_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_join::set_has__guild_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_join::clear_has__guild_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_join::clear__guild_id() {
  _guild_id_ = 0u;
  clear_has__guild_id();
}
inline ::google::protobuf::uint32 guild_join::_guild_id() const {
  return _guild_id_;
}
inline void guild_join::set__guild_id(::google::protobuf::uint32 value) {
  set_has__guild_id();
  _guild_id_ = value;
}

// -------------------------------------------------------------------

// guild_join_confirm

// required uint32 _uid = 1;
inline bool guild_join_confirm::has__uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_join_confirm::set_has__uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_join_confirm::clear_has__uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_join_confirm::clear__uid() {
  _uid_ = 0u;
  clear_has__uid();
}
inline ::google::protobuf::uint32 guild_join_confirm::_uid() const {
  return _uid_;
}
inline void guild_join_confirm::set__uid(::google::protobuf::uint32 value) {
  set_has__uid();
  _uid_ = value;
}

// required .up.guild_join_confirm.confirm_type _type = 2 [default = accept];
inline bool guild_join_confirm::has__type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild_join_confirm::set_has__type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild_join_confirm::clear_has__type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild_join_confirm::clear__type() {
  _type_ = 1;
  clear_has__type();
}
inline ::up::guild_join_confirm_confirm_type guild_join_confirm::_type() const {
  return static_cast< ::up::guild_join_confirm_confirm_type >(_type_);
}
inline void guild_join_confirm::set__type(::up::guild_join_confirm_confirm_type value) {
  assert(::up::guild_join_confirm_confirm_type_IsValid(value));
  set_has__type();
  _type_ = value;
}

// -------------------------------------------------------------------

// guild_leave

// -------------------------------------------------------------------

// guild_kick

// required uint32 _uid = 1;
inline bool guild_kick::has__uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_kick::set_has__uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_kick::clear_has__uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_kick::clear__uid() {
  _uid_ = 0u;
  clear_has__uid();
}
inline ::google::protobuf::uint32 guild_kick::_uid() const {
  return _uid_;
}
inline void guild_kick::set__uid(::google::protobuf::uint32 value) {
  set_has__uid();
  _uid_ = value;
}

// -------------------------------------------------------------------

// guild_set

// optional uint32 _avatar = 1;
inline bool guild_set::has__avatar() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_set::set_has__avatar() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_set::clear_has__avatar() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_set::clear__avatar() {
  _avatar_ = 0u;
  clear_has__avatar();
}
inline ::google::protobuf::uint32 guild_set::_avatar() const {
  return _avatar_;
}
inline void guild_set::set__avatar(::google::protobuf::uint32 value) {
  set_has__avatar();
  _avatar_ = value;
}

// optional .up.guild_set.guild_join_t _join_type = 2;
inline bool guild_set::has__join_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild_set::set_has__join_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild_set::clear_has__join_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild_set::clear__join_type() {
  _join_type_ = 1;
  clear_has__join_type();
}
inline ::up::guild_set_guild_join_t guild_set::_join_type() const {
  return static_cast< ::up::guild_set_guild_join_t >(_join_type_);
}
inline void guild_set::set__join_type(::up::guild_set_guild_join_t value) {
  assert(::up::guild_set_guild_join_t_IsValid(value));
  set_has__join_type();
  _join_type_ = value;
}

// optional uint32 _join_limit = 3;
inline bool guild_set::has__join_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void guild_set::set_has__join_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void guild_set::clear_has__join_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void guild_set::clear__join_limit() {
  _join_limit_ = 0u;
  clear_has__join_limit();
}
inline ::google::protobuf::uint32 guild_set::_join_limit() const {
  return _join_limit_;
}
inline void guild_set::set__join_limit(::google::protobuf::uint32 value) {
  set_has__join_limit();
  _join_limit_ = value;
}

// optional string _slogan = 4;
inline bool guild_set::has__slogan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void guild_set::set_has__slogan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void guild_set::clear_has__slogan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void guild_set::clear__slogan() {
  if (_slogan_ != &::google::protobuf::internal::kEmptyString) {
    _slogan_->clear();
  }
  clear_has__slogan();
}
inline const ::std::string& guild_set::_slogan() const {
  return *_slogan_;
}
inline void guild_set::set__slogan(const ::std::string& value) {
  set_has__slogan();
  if (_slogan_ == &::google::protobuf::internal::kEmptyString) {
    _slogan_ = new ::std::string;
  }
  _slogan_->assign(value);
}
inline void guild_set::set__slogan(const char* value) {
  set_has__slogan();
  if (_slogan_ == &::google::protobuf::internal::kEmptyString) {
    _slogan_ = new ::std::string;
  }
  _slogan_->assign(value);
}
inline void guild_set::set__slogan(const char* value, size_t size) {
  set_has__slogan();
  if (_slogan_ == &::google::protobuf::internal::kEmptyString) {
    _slogan_ = new ::std::string;
  }
  _slogan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* guild_set::mutable__slogan() {
  set_has__slogan();
  if (_slogan_ == &::google::protobuf::internal::kEmptyString) {
    _slogan_ = new ::std::string;
  }
  return _slogan_;
}
inline ::std::string* guild_set::release__slogan() {
  clear_has__slogan();
  if (_slogan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _slogan_;
    _slogan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void guild_set::set_allocated__slogan(::std::string* _slogan) {
  if (_slogan_ != &::google::protobuf::internal::kEmptyString) {
    delete _slogan_;
  }
  if (_slogan) {
    set_has__slogan();
    _slogan_ = _slogan;
  } else {
    clear_has__slogan();
    _slogan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 _can_jump = 5;
inline bool guild_set::has__can_jump() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void guild_set::set_has__can_jump() {
  _has_bits_[0] |= 0x00000010u;
}
inline void guild_set::clear_has__can_jump() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void guild_set::clear__can_jump() {
  _can_jump_ = 0u;
  clear_has__can_jump();
}
inline ::google::protobuf::uint32 guild_set::_can_jump() const {
  return _can_jump_;
}
inline void guild_set::set__can_jump(::google::protobuf::uint32 value) {
  set_has__can_jump();
  _can_jump_ = value;
}

// -------------------------------------------------------------------

// guild_query

// -------------------------------------------------------------------

// guild_open_pannel

// -------------------------------------------------------------------

// guild_set_job

// required uint32 _uid = 1;
inline bool guild_set_job::has__uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_set_job::set_has__uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_set_job::clear_has__uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_set_job::clear__uid() {
  _uid_ = 0u;
  clear_has__uid();
}
inline ::google::protobuf::uint32 guild_set_job::_uid() const {
  return _uid_;
}
inline void guild_set_job::set__uid(::google::protobuf::uint32 value) {
  set_has__uid();
  _uid_ = value;
}

// required .up.guild_job_t _job = 2;
inline bool guild_set_job::has__job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild_set_job::set_has__job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild_set_job::clear_has__job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild_set_job::clear__job() {
  _job_ = 1;
  clear_has__job();
}
inline ::up::guild_job_t guild_set_job::_job() const {
  return static_cast< ::up::guild_job_t >(_job_);
}
inline void guild_set_job::set__job(::up::guild_job_t value) {
  assert(::up::guild_job_t_IsValid(value));
  set_has__job();
  _job_ = value;
}

// -------------------------------------------------------------------

// guild_add_hire

// required uint32 _heroid = 1;
inline bool guild_add_hire::has__heroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_add_hire::set_has__heroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_add_hire::clear_has__heroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_add_hire::clear__heroid() {
  _heroid_ = 0u;
  clear_has__heroid();
}
inline ::google::protobuf::uint32 guild_add_hire::_heroid() const {
  return _heroid_;
}
inline void guild_add_hire::set__heroid(::google::protobuf::uint32 value) {
  set_has__heroid();
  _heroid_ = value;
}

// -------------------------------------------------------------------

// guild_del_hire

// required uint32 _heroid = 2;
inline bool guild_del_hire::has__heroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_del_hire::set_has__heroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_del_hire::clear_has__heroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_del_hire::clear__heroid() {
  _heroid_ = 0u;
  clear_has__heroid();
}
inline ::google::protobuf::uint32 guild_del_hire::_heroid() const {
  return _heroid_;
}
inline void guild_del_hire::set__heroid(::google::protobuf::uint32 value) {
  set_has__heroid();
  _heroid_ = value;
}

// -------------------------------------------------------------------

// guild_query_hires

// required .up.hire_from _from = 1;
inline bool guild_query_hires::has__from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_query_hires::set_has__from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_query_hires::clear_has__from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_query_hires::clear__from() {
  _from_ = 0;
  clear_has__from();
}
inline ::up::hire_from guild_query_hires::_from() const {
  return static_cast< ::up::hire_from >(_from_);
}
inline void guild_query_hires::set__from(::up::hire_from value) {
  assert(::up::hire_from_IsValid(value));
  set_has__from();
  _from_ = value;
}

// -------------------------------------------------------------------

// guild_hire_hero

// required uint32 _uid = 1;
inline bool guild_hire_hero::has__uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_hire_hero::set_has__uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_hire_hero::clear_has__uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_hire_hero::clear__uid() {
  _uid_ = 0u;
  clear_has__uid();
}
inline ::google::protobuf::uint32 guild_hire_hero::_uid() const {
  return _uid_;
}
inline void guild_hire_hero::set__uid(::google::protobuf::uint32 value) {
  set_has__uid();
  _uid_ = value;
}

// required uint32 _heroid = 2;
inline bool guild_hire_hero::has__heroid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild_hire_hero::set_has__heroid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild_hire_hero::clear_has__heroid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild_hire_hero::clear__heroid() {
  _heroid_ = 0u;
  clear_has__heroid();
}
inline ::google::protobuf::uint32 guild_hire_hero::_heroid() const {
  return _heroid_;
}
inline void guild_hire_hero::set__heroid(::google::protobuf::uint32 value) {
  set_has__heroid();
  _heroid_ = value;
}

// required .up.hire_from _from = 3;
inline bool guild_hire_hero::has__from() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void guild_hire_hero::set_has__from() {
  _has_bits_[0] |= 0x00000004u;
}
inline void guild_hire_hero::clear_has__from() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void guild_hire_hero::clear__from() {
  _from_ = 0;
  clear_has__from();
}
inline ::up::hire_from guild_hire_hero::_from() const {
  return static_cast< ::up::hire_from >(_from_);
}
inline void guild_hire_hero::set__from(::up::hire_from value) {
  assert(::up::hire_from_IsValid(value));
  set_has__from();
  _from_ = value;
}

// optional uint32 _stage_id = 4;
inline bool guild_hire_hero::has__stage_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void guild_hire_hero::set_has__stage_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void guild_hire_hero::clear_has__stage_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void guild_hire_hero::clear__stage_id() {
  _stage_id_ = 0u;
  clear_has__stage_id();
}
inline ::google::protobuf::uint32 guild_hire_hero::_stage_id() const {
  return _stage_id_;
}
inline void guild_hire_hero::set__stage_id(::google::protobuf::uint32 value) {
  set_has__stage_id();
  _stage_id_ = value;
}

// -------------------------------------------------------------------

// guild_worship_req

// required uint32 _id = 1;
inline bool guild_worship_req::has__id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_worship_req::set_has__id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_worship_req::clear_has__id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_worship_req::clear__id() {
  _id_ = 0u;
  clear_has__id();
}
inline ::google::protobuf::uint32 guild_worship_req::_id() const {
  return _id_;
}
inline void guild_worship_req::set__id(::google::protobuf::uint32 value) {
  set_has__id();
  _id_ = value;
}

// required uint32 _uid = 2;
inline bool guild_worship_req::has__uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild_worship_req::set_has__uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild_worship_req::clear_has__uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild_worship_req::clear__uid() {
  _uid_ = 0u;
  clear_has__uid();
}
inline ::google::protobuf::uint32 guild_worship_req::_uid() const {
  return _uid_;
}
inline void guild_worship_req::set__uid(::google::protobuf::uint32 value) {
  set_has__uid();
  _uid_ = value;
}

// -------------------------------------------------------------------

// guild_worship_withdraw

// -------------------------------------------------------------------

// guild_qurey_hh_detail

// required uint32 _uid = 1;
inline bool guild_qurey_hh_detail::has__uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void guild_qurey_hh_detail::set_has__uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void guild_qurey_hh_detail::clear_has__uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void guild_qurey_hh_detail::clear__uid() {
  _uid_ = 0u;
  clear_has__uid();
}
inline ::google::protobuf::uint32 guild_qurey_hh_detail::_uid() const {
  return _uid_;
}
inline void guild_qurey_hh_detail::set__uid(::google::protobuf::uint32 value) {
  set_has__uid();
  _uid_ = value;
}

// required uint32 _heroid = 2;
inline bool guild_qurey_hh_detail::has__heroid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void guild_qurey_hh_detail::set_has__heroid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void guild_qurey_hh_detail::clear_has__heroid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void guild_qurey_hh_detail::clear__heroid() {
  _heroid_ = 0u;
  clear_has__heroid();
}
inline ::google::protobuf::uint32 guild_qurey_hh_detail::_heroid() const {
  return _heroid_;
}
inline void guild_qurey_hh_detail::set__heroid(::google::protobuf::uint32 value) {
  set_has__heroid();
  _heroid_ = value;
}

// -------------------------------------------------------------------

// ask_activity_info

// -------------------------------------------------------------------

// cdkey_gift

// required string _cdkey = 1;
inline bool cdkey_gift::has__cdkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cdkey_gift::set_has__cdkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cdkey_gift::clear_has__cdkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cdkey_gift::clear__cdkey() {
  if (_cdkey_ != &::google::protobuf::internal::kEmptyString) {
    _cdkey_->clear();
  }
  clear_has__cdkey();
}
inline const ::std::string& cdkey_gift::_cdkey() const {
  return *_cdkey_;
}
inline void cdkey_gift::set__cdkey(const ::std::string& value) {
  set_has__cdkey();
  if (_cdkey_ == &::google::protobuf::internal::kEmptyString) {
    _cdkey_ = new ::std::string;
  }
  _cdkey_->assign(value);
}
inline void cdkey_gift::set__cdkey(const char* value) {
  set_has__cdkey();
  if (_cdkey_ == &::google::protobuf::internal::kEmptyString) {
    _cdkey_ = new ::std::string;
  }
  _cdkey_->assign(value);
}
inline void cdkey_gift::set__cdkey(const char* value, size_t size) {
  set_has__cdkey();
  if (_cdkey_ == &::google::protobuf::internal::kEmptyString) {
    _cdkey_ = new ::std::string;
  }
  _cdkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cdkey_gift::mutable__cdkey() {
  set_has__cdkey();
  if (_cdkey_ == &::google::protobuf::internal::kEmptyString) {
    _cdkey_ = new ::std::string;
  }
  return _cdkey_;
}
inline ::std::string* cdkey_gift::release__cdkey() {
  clear_has__cdkey();
  if (_cdkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _cdkey_;
    _cdkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cdkey_gift::set_allocated__cdkey(::std::string* _cdkey) {
  if (_cdkey_ != &::google::protobuf::internal::kEmptyString) {
    delete _cdkey_;
  }
  if (_cdkey) {
    set_has__cdkey();
    _cdkey_ = _cdkey;
  } else {
    clear_has__cdkey();
    _cdkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// excavate

// optional .up.search_excavate _search_excavate = 1;
inline bool excavate::has__search_excavate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void excavate::set_has__search_excavate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void excavate::clear_has__search_excavate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void excavate::clear__search_excavate() {
  if (_search_excavate_ != NULL) _search_excavate_->::up::search_excavate::Clear();
  clear_has__search_excavate();
}
inline const ::up::search_excavate& excavate::_search_excavate() const {
  return _search_excavate_ != NULL ? *_search_excavate_ : *default_instance_->_search_excavate_;
}
inline ::up::search_excavate* excavate::mutable__search_excavate() {
  set_has__search_excavate();
  if (_search_excavate_ == NULL) _search_excavate_ = new ::up::search_excavate;
  return _search_excavate_;
}
inline ::up::search_excavate* excavate::release__search_excavate() {
  clear_has__search_excavate();
  ::up::search_excavate* temp = _search_excavate_;
  _search_excavate_ = NULL;
  return temp;
}
inline void excavate::set_allocated__search_excavate(::up::search_excavate* _search_excavate) {
  delete _search_excavate_;
  _search_excavate_ = _search_excavate;
  if (_search_excavate) {
    set_has__search_excavate();
  } else {
    clear_has__search_excavate();
  }
}

// optional .up.query_excavate_data _query_excavate_data = 2;
inline bool excavate::has__query_excavate_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void excavate::set_has__query_excavate_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void excavate::clear_has__query_excavate_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void excavate::clear__query_excavate_data() {
  if (_query_excavate_data_ != NULL) _query_excavate_data_->::up::query_excavate_data::Clear();
  clear_has__query_excavate_data();
}
inline const ::up::query_excavate_data& excavate::_query_excavate_data() const {
  return _query_excavate_data_ != NULL ? *_query_excavate_data_ : *default_instance_->_query_excavate_data_;
}
inline ::up::query_excavate_data* excavate::mutable__query_excavate_data() {
  set_has__query_excavate_data();
  if (_query_excavate_data_ == NULL) _query_excavate_data_ = new ::up::query_excavate_data;
  return _query_excavate_data_;
}
inline ::up::query_excavate_data* excavate::release__query_excavate_data() {
  clear_has__query_excavate_data();
  ::up::query_excavate_data* temp = _query_excavate_data_;
  _query_excavate_data_ = NULL;
  return temp;
}
inline void excavate::set_allocated__query_excavate_data(::up::query_excavate_data* _query_excavate_data) {
  delete _query_excavate_data_;
  _query_excavate_data_ = _query_excavate_data;
  if (_query_excavate_data) {
    set_has__query_excavate_data();
  } else {
    clear_has__query_excavate_data();
  }
}

// optional .up.query_excavate_history _query_excavate_history = 3;
inline bool excavate::has__query_excavate_history() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void excavate::set_has__query_excavate_history() {
  _has_bits_[0] |= 0x00000004u;
}
inline void excavate::clear_has__query_excavate_history() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void excavate::clear__query_excavate_history() {
  if (_query_excavate_history_ != NULL) _query_excavate_history_->::up::query_excavate_history::Clear();
  clear_has__query_excavate_history();
}
inline const ::up::query_excavate_history& excavate::_query_excavate_history() const {
  return _query_excavate_history_ != NULL ? *_query_excavate_history_ : *default_instance_->_query_excavate_history_;
}
inline ::up::query_excavate_history* excavate::mutable__query_excavate_history() {
  set_has__query_excavate_history();
  if (_query_excavate_history_ == NULL) _query_excavate_history_ = new ::up::query_excavate_history;
  return _query_excavate_history_;
}
inline ::up::query_excavate_history* excavate::release__query_excavate_history() {
  clear_has__query_excavate_history();
  ::up::query_excavate_history* temp = _query_excavate_history_;
  _query_excavate_history_ = NULL;
  return temp;
}
inline void excavate::set_allocated__query_excavate_history(::up::query_excavate_history* _query_excavate_history) {
  delete _query_excavate_history_;
  _query_excavate_history_ = _query_excavate_history;
  if (_query_excavate_history) {
    set_has__query_excavate_history();
  } else {
    clear_has__query_excavate_history();
  }
}

// optional .up.query_excavate_battle _query_excavate_battle = 4;
inline bool excavate::has__query_excavate_battle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void excavate::set_has__query_excavate_battle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void excavate::clear_has__query_excavate_battle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void excavate::clear__query_excavate_battle() {
  if (_query_excavate_battle_ != NULL) _query_excavate_battle_->::up::query_excavate_battle::Clear();
  clear_has__query_excavate_battle();
}
inline const ::up::query_excavate_battle& excavate::_query_excavate_battle() const {
  return _query_excavate_battle_ != NULL ? *_query_excavate_battle_ : *default_instance_->_query_excavate_battle_;
}
inline ::up::query_excavate_battle* excavate::mutable__query_excavate_battle() {
  set_has__query_excavate_battle();
  if (_query_excavate_battle_ == NULL) _query_excavate_battle_ = new ::up::query_excavate_battle;
  return _query_excavate_battle_;
}
inline ::up::query_excavate_battle* excavate::release__query_excavate_battle() {
  clear_has__query_excavate_battle();
  ::up::query_excavate_battle* temp = _query_excavate_battle_;
  _query_excavate_battle_ = NULL;
  return temp;
}
inline void excavate::set_allocated__query_excavate_battle(::up::query_excavate_battle* _query_excavate_battle) {
  delete _query_excavate_battle_;
  _query_excavate_battle_ = _query_excavate_battle;
  if (_query_excavate_battle) {
    set_has__query_excavate_battle();
  } else {
    clear_has__query_excavate_battle();
  }
}

// optional .up.set_excavate_team _set_excavate_team = 5;
inline bool excavate::has__set_excavate_team() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void excavate::set_has__set_excavate_team() {
  _has_bits_[0] |= 0x00000010u;
}
inline void excavate::clear_has__set_excavate_team() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void excavate::clear__set_excavate_team() {
  if (_set_excavate_team_ != NULL) _set_excavate_team_->::up::set_excavate_team::Clear();
  clear_has__set_excavate_team();
}
inline const ::up::set_excavate_team& excavate::_set_excavate_team() const {
  return _set_excavate_team_ != NULL ? *_set_excavate_team_ : *default_instance_->_set_excavate_team_;
}
inline ::up::set_excavate_team* excavate::mutable__set_excavate_team() {
  set_has__set_excavate_team();
  if (_set_excavate_team_ == NULL) _set_excavate_team_ = new ::up::set_excavate_team;
  return _set_excavate_team_;
}
inline ::up::set_excavate_team* excavate::release__set_excavate_team() {
  clear_has__set_excavate_team();
  ::up::set_excavate_team* temp = _set_excavate_team_;
  _set_excavate_team_ = NULL;
  return temp;
}
inline void excavate::set_allocated__set_excavate_team(::up::set_excavate_team* _set_excavate_team) {
  delete _set_excavate_team_;
  _set_excavate_team_ = _set_excavate_team;
  if (_set_excavate_team) {
    set_has__set_excavate_team();
  } else {
    clear_has__set_excavate_team();
  }
}

// optional .up.excavate_start_battle _excavate_start_battle = 6;
inline bool excavate::has__excavate_start_battle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void excavate::set_has__excavate_start_battle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void excavate::clear_has__excavate_start_battle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void excavate::clear__excavate_start_battle() {
  if (_excavate_start_battle_ != NULL) _excavate_start_battle_->::up::excavate_start_battle::Clear();
  clear_has__excavate_start_battle();
}
inline const ::up::excavate_start_battle& excavate::_excavate_start_battle() const {
  return _excavate_start_battle_ != NULL ? *_excavate_start_battle_ : *default_instance_->_excavate_start_battle_;
}
inline ::up::excavate_start_battle* excavate::mutable__excavate_start_battle() {
  set_has__excavate_start_battle();
  if (_excavate_start_battle_ == NULL) _excavate_start_battle_ = new ::up::excavate_start_battle;
  return _excavate_start_battle_;
}
inline ::up::excavate_start_battle* excavate::release__excavate_start_battle() {
  clear_has__excavate_start_battle();
  ::up::excavate_start_battle* temp = _excavate_start_battle_;
  _excavate_start_battle_ = NULL;
  return temp;
}
inline void excavate::set_allocated__excavate_start_battle(::up::excavate_start_battle* _excavate_start_battle) {
  delete _excavate_start_battle_;
  _excavate_start_battle_ = _excavate_start_battle;
  if (_excavate_start_battle) {
    set_has__excavate_start_battle();
  } else {
    clear_has__excavate_start_battle();
  }
}

// optional .up.excavate_end_battle _excavate_end_battle = 7;
inline bool excavate::has__excavate_end_battle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void excavate::set_has__excavate_end_battle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void excavate::clear_has__excavate_end_battle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void excavate::clear__excavate_end_battle() {
  if (_excavate_end_battle_ != NULL) _excavate_end_battle_->::up::excavate_end_battle::Clear();
  clear_has__excavate_end_battle();
}
inline const ::up::excavate_end_battle& excavate::_excavate_end_battle() const {
  return _excavate_end_battle_ != NULL ? *_excavate_end_battle_ : *default_instance_->_excavate_end_battle_;
}
inline ::up::excavate_end_battle* excavate::mutable__excavate_end_battle() {
  set_has__excavate_end_battle();
  if (_excavate_end_battle_ == NULL) _excavate_end_battle_ = new ::up::excavate_end_battle;
  return _excavate_end_battle_;
}
inline ::up::excavate_end_battle* excavate::release__excavate_end_battle() {
  clear_has__excavate_end_battle();
  ::up::excavate_end_battle* temp = _excavate_end_battle_;
  _excavate_end_battle_ = NULL;
  return temp;
}
inline void excavate::set_allocated__excavate_end_battle(::up::excavate_end_battle* _excavate_end_battle) {
  delete _excavate_end_battle_;
  _excavate_end_battle_ = _excavate_end_battle;
  if (_excavate_end_battle) {
    set_has__excavate_end_battle();
  } else {
    clear_has__excavate_end_battle();
  }
}

// optional .up.query_excavate_def _query_excavate_def = 8;
inline bool excavate::has__query_excavate_def() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void excavate::set_has__query_excavate_def() {
  _has_bits_[0] |= 0x00000080u;
}
inline void excavate::clear_has__query_excavate_def() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void excavate::clear__query_excavate_def() {
  if (_query_excavate_def_ != NULL) _query_excavate_def_->::up::query_excavate_def::Clear();
  clear_has__query_excavate_def();
}
inline const ::up::query_excavate_def& excavate::_query_excavate_def() const {
  return _query_excavate_def_ != NULL ? *_query_excavate_def_ : *default_instance_->_query_excavate_def_;
}
inline ::up::query_excavate_def* excavate::mutable__query_excavate_def() {
  set_has__query_excavate_def();
  if (_query_excavate_def_ == NULL) _query_excavate_def_ = new ::up::query_excavate_def;
  return _query_excavate_def_;
}
inline ::up::query_excavate_def* excavate::release__query_excavate_def() {
  clear_has__query_excavate_def();
  ::up::query_excavate_def* temp = _query_excavate_def_;
  _query_excavate_def_ = NULL;
  return temp;
}
inline void excavate::set_allocated__query_excavate_def(::up::query_excavate_def* _query_excavate_def) {
  delete _query_excavate_def_;
  _query_excavate_def_ = _query_excavate_def;
  if (_query_excavate_def) {
    set_has__query_excavate_def();
  } else {
    clear_has__query_excavate_def();
  }
}

// optional .up.clear_excavate_battle _clear_excavate_battle = 9;
inline bool excavate::has__clear_excavate_battle() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void excavate::set_has__clear_excavate_battle() {
  _has_bits_[0] |= 0x00000100u;
}
inline void excavate::clear_has__clear_excavate_battle() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void excavate::clear__clear_excavate_battle() {
  if (_clear_excavate_battle_ != NULL) _clear_excavate_battle_->::up::clear_excavate_battle::Clear();
  clear_has__clear_excavate_battle();
}
inline const ::up::clear_excavate_battle& excavate::_clear_excavate_battle() const {
  return _clear_excavate_battle_ != NULL ? *_clear_excavate_battle_ : *default_instance_->_clear_excavate_battle_;
}
inline ::up::clear_excavate_battle* excavate::mutable__clear_excavate_battle() {
  set_has__clear_excavate_battle();
  if (_clear_excavate_battle_ == NULL) _clear_excavate_battle_ = new ::up::clear_excavate_battle;
  return _clear_excavate_battle_;
}
inline ::up::clear_excavate_battle* excavate::release__clear_excavate_battle() {
  clear_has__clear_excavate_battle();
  ::up::clear_excavate_battle* temp = _clear_excavate_battle_;
  _clear_excavate_battle_ = NULL;
  return temp;
}
inline void excavate::set_allocated__clear_excavate_battle(::up::clear_excavate_battle* _clear_excavate_battle) {
  delete _clear_excavate_battle_;
  _clear_excavate_battle_ = _clear_excavate_battle;
  if (_clear_excavate_battle) {
    set_has__clear_excavate_battle();
  } else {
    clear_has__clear_excavate_battle();
  }
}

// optional .up.withdraw_excavate_hero _withdraw_excavate_hero = 10;
inline bool excavate::has__withdraw_excavate_hero() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void excavate::set_has__withdraw_excavate_hero() {
  _has_bits_[0] |= 0x00000200u;
}
inline void excavate::clear_has__withdraw_excavate_hero() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void excavate::clear__withdraw_excavate_hero() {
  if (_withdraw_excavate_hero_ != NULL) _withdraw_excavate_hero_->::up::withdraw_excavate_hero::Clear();
  clear_has__withdraw_excavate_hero();
}
inline const ::up::withdraw_excavate_hero& excavate::_withdraw_excavate_hero() const {
  return _withdraw_excavate_hero_ != NULL ? *_withdraw_excavate_hero_ : *default_instance_->_withdraw_excavate_hero_;
}
inline ::up::withdraw_excavate_hero* excavate::mutable__withdraw_excavate_hero() {
  set_has__withdraw_excavate_hero();
  if (_withdraw_excavate_hero_ == NULL) _withdraw_excavate_hero_ = new ::up::withdraw_excavate_hero;
  return _withdraw_excavate_hero_;
}
inline ::up::withdraw_excavate_hero* excavate::release__withdraw_excavate_hero() {
  clear_has__withdraw_excavate_hero();
  ::up::withdraw_excavate_hero* temp = _withdraw_excavate_hero_;
  _withdraw_excavate_hero_ = NULL;
  return temp;
}
inline void excavate::set_allocated__withdraw_excavate_hero(::up::withdraw_excavate_hero* _withdraw_excavate_hero) {
  delete _withdraw_excavate_hero_;
  _withdraw_excavate_hero_ = _withdraw_excavate_hero;
  if (_withdraw_excavate_hero) {
    set_has__withdraw_excavate_hero();
  } else {
    clear_has__withdraw_excavate_hero();
  }
}

// optional .up.draw_excavate_def_rwd _draw_excavate_def_rwd = 11;
inline bool excavate::has__draw_excavate_def_rwd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void excavate::set_has__draw_excavate_def_rwd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void excavate::clear_has__draw_excavate_def_rwd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void excavate::clear__draw_excavate_def_rwd() {
  if (_draw_excavate_def_rwd_ != NULL) _draw_excavate_def_rwd_->::up::draw_excavate_def_rwd::Clear();
  clear_has__draw_excavate_def_rwd();
}
inline const ::up::draw_excavate_def_rwd& excavate::_draw_excavate_def_rwd() const {
  return _draw_excavate_def_rwd_ != NULL ? *_draw_excavate_def_rwd_ : *default_instance_->_draw_excavate_def_rwd_;
}
inline ::up::draw_excavate_def_rwd* excavate::mutable__draw_excavate_def_rwd() {
  set_has__draw_excavate_def_rwd();
  if (_draw_excavate_def_rwd_ == NULL) _draw_excavate_def_rwd_ = new ::up::draw_excavate_def_rwd;
  return _draw_excavate_def_rwd_;
}
inline ::up::draw_excavate_def_rwd* excavate::release__draw_excavate_def_rwd() {
  clear_has__draw_excavate_def_rwd();
  ::up::draw_excavate_def_rwd* temp = _draw_excavate_def_rwd_;
  _draw_excavate_def_rwd_ = NULL;
  return temp;
}
inline void excavate::set_allocated__draw_excavate_def_rwd(::up::draw_excavate_def_rwd* _draw_excavate_def_rwd) {
  delete _draw_excavate_def_rwd_;
  _draw_excavate_def_rwd_ = _draw_excavate_def_rwd;
  if (_draw_excavate_def_rwd) {
    set_has__draw_excavate_def_rwd();
  } else {
    clear_has__draw_excavate_def_rwd();
  }
}

// optional .up.drop_excavate _drop_excavate = 12;
inline bool excavate::has__drop_excavate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void excavate::set_has__drop_excavate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void excavate::clear_has__drop_excavate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void excavate::clear__drop_excavate() {
  if (_drop_excavate_ != NULL) _drop_excavate_->::up::drop_excavate::Clear();
  clear_has__drop_excavate();
}
inline const ::up::drop_excavate& excavate::_drop_excavate() const {
  return _drop_excavate_ != NULL ? *_drop_excavate_ : *default_instance_->_drop_excavate_;
}
inline ::up::drop_excavate* excavate::mutable__drop_excavate() {
  set_has__drop_excavate();
  if (_drop_excavate_ == NULL) _drop_excavate_ = new ::up::drop_excavate;
  return _drop_excavate_;
}
inline ::up::drop_excavate* excavate::release__drop_excavate() {
  clear_has__drop_excavate();
  ::up::drop_excavate* temp = _drop_excavate_;
  _drop_excavate_ = NULL;
  return temp;
}
inline void excavate::set_allocated__drop_excavate(::up::drop_excavate* _drop_excavate) {
  delete _drop_excavate_;
  _drop_excavate_ = _drop_excavate;
  if (_drop_excavate) {
    set_has__drop_excavate();
  } else {
    clear_has__drop_excavate();
  }
}

// optional .up.query_replay _query_replay = 13;
inline bool excavate::has__query_replay() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void excavate::set_has__query_replay() {
  _has_bits_[0] |= 0x00001000u;
}
inline void excavate::clear_has__query_replay() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void excavate::clear__query_replay() {
  if (_query_replay_ != NULL) _query_replay_->::up::query_replay::Clear();
  clear_has__query_replay();
}
inline const ::up::query_replay& excavate::_query_replay() const {
  return _query_replay_ != NULL ? *_query_replay_ : *default_instance_->_query_replay_;
}
inline ::up::query_replay* excavate::mutable__query_replay() {
  set_has__query_replay();
  if (_query_replay_ == NULL) _query_replay_ = new ::up::query_replay;
  return _query_replay_;
}
inline ::up::query_replay* excavate::release__query_replay() {
  clear_has__query_replay();
  ::up::query_replay* temp = _query_replay_;
  _query_replay_ = NULL;
  return temp;
}
inline void excavate::set_allocated__query_replay(::up::query_replay* _query_replay) {
  delete _query_replay_;
  _query_replay_ = _query_replay;
  if (_query_replay) {
    set_has__query_replay();
  } else {
    clear_has__query_replay();
  }
}

// -------------------------------------------------------------------

// search_excavate

// -------------------------------------------------------------------

// query_excavate_data

// -------------------------------------------------------------------

// query_excavate_history

// -------------------------------------------------------------------

// query_excavate_battle

// required string _id = 1;
inline bool query_excavate_battle::has__id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_excavate_battle::set_has__id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_excavate_battle::clear_has__id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_excavate_battle::clear__id() {
  if (_id_ != &::google::protobuf::internal::kEmptyString) {
    _id_->clear();
  }
  clear_has__id();
}
inline const ::std::string& query_excavate_battle::_id() const {
  return *_id_;
}
inline void query_excavate_battle::set__id(const ::std::string& value) {
  set_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    _id_ = new ::std::string;
  }
  _id_->assign(value);
}
inline void query_excavate_battle::set__id(const char* value) {
  set_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    _id_ = new ::std::string;
  }
  _id_->assign(value);
}
inline void query_excavate_battle::set__id(const char* value, size_t size) {
  set_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    _id_ = new ::std::string;
  }
  _id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* query_excavate_battle::mutable__id() {
  set_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    _id_ = new ::std::string;
  }
  return _id_;
}
inline ::std::string* query_excavate_battle::release__id() {
  clear_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _id_;
    _id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void query_excavate_battle::set_allocated__id(::std::string* _id) {
  if (_id_ != &::google::protobuf::internal::kEmptyString) {
    delete _id_;
  }
  if (_id) {
    set_has__id();
    _id_ = _id;
  } else {
    clear_has__id();
    _id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// set_excavate_team

// required uint32 _excavate_id = 1;
inline bool set_excavate_team::has__excavate_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void set_excavate_team::set_has__excavate_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void set_excavate_team::clear_has__excavate_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void set_excavate_team::clear__excavate_id() {
  _excavate_id_ = 0u;
  clear_has__excavate_id();
}
inline ::google::protobuf::uint32 set_excavate_team::_excavate_id() const {
  return _excavate_id_;
}
inline void set_excavate_team::set__excavate_id(::google::protobuf::uint32 value) {
  set_has__excavate_id();
  _excavate_id_ = value;
}

// repeated uint32 _tid = 2;
inline int set_excavate_team::_tid_size() const {
  return _tid_.size();
}
inline void set_excavate_team::clear__tid() {
  _tid_.Clear();
}
inline ::google::protobuf::uint32 set_excavate_team::_tid(int index) const {
  return _tid_.Get(index);
}
inline void set_excavate_team::set__tid(int index, ::google::protobuf::uint32 value) {
  _tid_.Set(index, value);
}
inline void set_excavate_team::add__tid(::google::protobuf::uint32 value) {
  _tid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
set_excavate_team::_tid() const {
  return _tid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
set_excavate_team::mutable__tid() {
  return &_tid_;
}

// -------------------------------------------------------------------

// excavate_start_battle

// repeated uint32 _heroids = 1;
inline int excavate_start_battle::_heroids_size() const {
  return _heroids_.size();
}
inline void excavate_start_battle::clear__heroids() {
  _heroids_.Clear();
}
inline ::google::protobuf::uint32 excavate_start_battle::_heroids(int index) const {
  return _heroids_.Get(index);
}
inline void excavate_start_battle::set__heroids(int index, ::google::protobuf::uint32 value) {
  _heroids_.Set(index, value);
}
inline void excavate_start_battle::add__heroids(::google::protobuf::uint32 value) {
  _heroids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
excavate_start_battle::_heroids() const {
  return _heroids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
excavate_start_battle::mutable__heroids() {
  return &_heroids_;
}

// required uint32 _excavate_id = 2;
inline bool excavate_start_battle::has__excavate_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void excavate_start_battle::set_has__excavate_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void excavate_start_battle::clear_has__excavate_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void excavate_start_battle::clear__excavate_id() {
  _excavate_id_ = 0u;
  clear_has__excavate_id();
}
inline ::google::protobuf::uint32 excavate_start_battle::_excavate_id() const {
  return _excavate_id_;
}
inline void excavate_start_battle::set__excavate_id(::google::protobuf::uint32 value) {
  set_has__excavate_id();
  _excavate_id_ = value;
}

// required uint32 _team_id = 3;
inline bool excavate_start_battle::has__team_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void excavate_start_battle::set_has__team_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void excavate_start_battle::clear_has__team_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void excavate_start_battle::clear__team_id() {
  _team_id_ = 0u;
  clear_has__team_id();
}
inline ::google::protobuf::uint32 excavate_start_battle::_team_id() const {
  return _team_id_;
}
inline void excavate_start_battle::set__team_id(::google::protobuf::uint32 value) {
  set_has__team_id();
  _team_id_ = value;
}

// optional uint32 _team_svr_id = 4;
inline bool excavate_start_battle::has__team_svr_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void excavate_start_battle::set_has__team_svr_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void excavate_start_battle::clear_has__team_svr_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void excavate_start_battle::clear__team_svr_id() {
  _team_svr_id_ = 0u;
  clear_has__team_svr_id();
}
inline ::google::protobuf::uint32 excavate_start_battle::_team_svr_id() const {
  return _team_svr_id_;
}
inline void excavate_start_battle::set__team_svr_id(::google::protobuf::uint32 value) {
  set_has__team_svr_id();
  _team_svr_id_ = value;
}

// optional uint32 _use_hire = 5;
inline bool excavate_start_battle::has__use_hire() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void excavate_start_battle::set_has__use_hire() {
  _has_bits_[0] |= 0x00000010u;
}
inline void excavate_start_battle::clear_has__use_hire() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void excavate_start_battle::clear__use_hire() {
  _use_hire_ = 0u;
  clear_has__use_hire();
}
inline ::google::protobuf::uint32 excavate_start_battle::_use_hire() const {
  return _use_hire_;
}
inline void excavate_start_battle::set__use_hire(::google::protobuf::uint32 value) {
  set_has__use_hire();
  _use_hire_ = value;
}

// -------------------------------------------------------------------

// excavate_end_battle

// required .up.battle_result _result = 1 [default = victory];
inline bool excavate_end_battle::has__result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void excavate_end_battle::set_has__result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void excavate_end_battle::clear_has__result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void excavate_end_battle::clear__result() {
  _result_ = 0;
  clear_has__result();
}
inline ::up::battle_result excavate_end_battle::_result() const {
  return static_cast< ::up::battle_result >(_result_);
}
inline void excavate_end_battle::set__result(::up::battle_result value) {
  assert(::up::battle_result_IsValid(value));
  set_has__result();
  _result_ = value;
}

// repeated .up.excavate_hero _self_heroes = 2;
inline int excavate_end_battle::_self_heroes_size() const {
  return _self_heroes_.size();
}
inline void excavate_end_battle::clear__self_heroes() {
  _self_heroes_.Clear();
}
inline const ::up::excavate_hero& excavate_end_battle::_self_heroes(int index) const {
  return _self_heroes_.Get(index);
}
inline ::up::excavate_hero* excavate_end_battle::mutable__self_heroes(int index) {
  return _self_heroes_.Mutable(index);
}
inline ::up::excavate_hero* excavate_end_battle::add__self_heroes() {
  return _self_heroes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::up::excavate_hero >&
excavate_end_battle::_self_heroes() const {
  return _self_heroes_;
}
inline ::google::protobuf::RepeatedPtrField< ::up::excavate_hero >*
excavate_end_battle::mutable__self_heroes() {
  return &_self_heroes_;
}

// repeated .up.excavate_hero _oppo_heroes = 3;
inline int excavate_end_battle::_oppo_heroes_size() const {
  return _oppo_heroes_.size();
}
inline void excavate_end_battle::clear__oppo_heroes() {
  _oppo_heroes_.Clear();
}
inline const ::up::excavate_hero& excavate_end_battle::_oppo_heroes(int index) const {
  return _oppo_heroes_.Get(index);
}
inline ::up::excavate_hero* excavate_end_battle::mutable__oppo_heroes(int index) {
  return _oppo_heroes_.Mutable(index);
}
inline ::up::excavate_hero* excavate_end_battle::add__oppo_heroes() {
  return _oppo_heroes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::up::excavate_hero >&
excavate_end_battle::_oppo_heroes() const {
  return _oppo_heroes_;
}
inline ::google::protobuf::RepeatedPtrField< ::up::excavate_hero >*
excavate_end_battle::mutable__oppo_heroes() {
  return &_oppo_heroes_;
}

// repeated uint32 _oprations = 4;
inline int excavate_end_battle::_oprations_size() const {
  return _oprations_.size();
}
inline void excavate_end_battle::clear__oprations() {
  _oprations_.Clear();
}
inline ::google::protobuf::uint32 excavate_end_battle::_oprations(int index) const {
  return _oprations_.Get(index);
}
inline void excavate_end_battle::set__oprations(int index, ::google::protobuf::uint32 value) {
  _oprations_.Set(index, value);
}
inline void excavate_end_battle::add__oprations(::google::protobuf::uint32 value) {
  _oprations_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
excavate_end_battle::_oprations() const {
  return _oprations_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
excavate_end_battle::mutable__oprations() {
  return &_oprations_;
}

// required uint32 _type_id = 5;
inline bool excavate_end_battle::has__type_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void excavate_end_battle::set_has__type_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void excavate_end_battle::clear_has__type_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void excavate_end_battle::clear__type_id() {
  _type_id_ = 0u;
  clear_has__type_id();
}
inline ::google::protobuf::uint32 excavate_end_battle::_type_id() const {
  return _type_id_;
}
inline void excavate_end_battle::set__type_id(::google::protobuf::uint32 value) {
  set_has__type_id();
  _type_id_ = value;
}

// -------------------------------------------------------------------

// query_excavate_def

// required uint32 _mine_id = 1;
inline bool query_excavate_def::has__mine_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_excavate_def::set_has__mine_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_excavate_def::clear_has__mine_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_excavate_def::clear__mine_id() {
  _mine_id_ = 0u;
  clear_has__mine_id();
}
inline ::google::protobuf::uint32 query_excavate_def::_mine_id() const {
  return _mine_id_;
}
inline void query_excavate_def::set__mine_id(::google::protobuf::uint32 value) {
  set_has__mine_id();
  _mine_id_ = value;
}

// required uint32 _applier_uid = 2;
inline bool query_excavate_def::has__applier_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_excavate_def::set_has__applier_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_excavate_def::clear_has__applier_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_excavate_def::clear__applier_uid() {
  _applier_uid_ = 0u;
  clear_has__applier_uid();
}
inline ::google::protobuf::uint32 query_excavate_def::_applier_uid() const {
  return _applier_uid_;
}
inline void query_excavate_def::set__applier_uid(::google::protobuf::uint32 value) {
  set_has__applier_uid();
  _applier_uid_ = value;
}

// -------------------------------------------------------------------

// clear_excavate_battle

// -------------------------------------------------------------------

// withdraw_excavate_hero

// required uint32 _hero_id = 1;
inline bool withdraw_excavate_hero::has__hero_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void withdraw_excavate_hero::set_has__hero_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void withdraw_excavate_hero::clear_has__hero_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void withdraw_excavate_hero::clear__hero_id() {
  _hero_id_ = 0u;
  clear_has__hero_id();
}
inline ::google::protobuf::uint32 withdraw_excavate_hero::_hero_id() const {
  return _hero_id_;
}
inline void withdraw_excavate_hero::set__hero_id(::google::protobuf::uint32 value) {
  set_has__hero_id();
  _hero_id_ = value;
}

// -------------------------------------------------------------------

// draw_excavate_def_rwd

// required string _id = 1;
inline bool draw_excavate_def_rwd::has__id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void draw_excavate_def_rwd::set_has__id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void draw_excavate_def_rwd::clear_has__id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void draw_excavate_def_rwd::clear__id() {
  if (_id_ != &::google::protobuf::internal::kEmptyString) {
    _id_->clear();
  }
  clear_has__id();
}
inline const ::std::string& draw_excavate_def_rwd::_id() const {
  return *_id_;
}
inline void draw_excavate_def_rwd::set__id(const ::std::string& value) {
  set_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    _id_ = new ::std::string;
  }
  _id_->assign(value);
}
inline void draw_excavate_def_rwd::set__id(const char* value) {
  set_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    _id_ = new ::std::string;
  }
  _id_->assign(value);
}
inline void draw_excavate_def_rwd::set__id(const char* value, size_t size) {
  set_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    _id_ = new ::std::string;
  }
  _id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* draw_excavate_def_rwd::mutable__id() {
  set_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    _id_ = new ::std::string;
  }
  return _id_;
}
inline ::std::string* draw_excavate_def_rwd::release__id() {
  clear_has__id();
  if (_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _id_;
    _id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void draw_excavate_def_rwd::set_allocated__id(::std::string* _id) {
  if (_id_ != &::google::protobuf::internal::kEmptyString) {
    delete _id_;
  }
  if (_id) {
    set_has__id();
    _id_ = _id;
  } else {
    clear_has__id();
    _id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// drop_excavate

// required uint32 _mine_id = 1;
inline bool drop_excavate::has__mine_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void drop_excavate::set_has__mine_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void drop_excavate::clear_has__mine_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void drop_excavate::clear__mine_id() {
  _mine_id_ = 0u;
  clear_has__mine_id();
}
inline ::google::protobuf::uint32 drop_excavate::_mine_id() const {
  return _mine_id_;
}
inline void drop_excavate::set__mine_id(::google::protobuf::uint32 value) {
  set_has__mine_id();
  _mine_id_ = value;
}

// -------------------------------------------------------------------

// excavate_hero

// required uint32 _heroid = 1;
inline bool excavate_hero::has__heroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void excavate_hero::set_has__heroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void excavate_hero::clear_has__heroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void excavate_hero::clear__heroid() {
  _heroid_ = 0u;
  clear_has__heroid();
}
inline ::google::protobuf::uint32 excavate_hero::_heroid() const {
  return _heroid_;
}
inline void excavate_hero::set__heroid(::google::protobuf::uint32 value) {
  set_has__heroid();
  _heroid_ = value;
}

// required uint32 _hp_perc = 2;
inline bool excavate_hero::has__hp_perc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void excavate_hero::set_has__hp_perc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void excavate_hero::clear_has__hp_perc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void excavate_hero::clear__hp_perc() {
  _hp_perc_ = 0u;
  clear_has__hp_perc();
}
inline ::google::protobuf::uint32 excavate_hero::_hp_perc() const {
  return _hp_perc_;
}
inline void excavate_hero::set__hp_perc(::google::protobuf::uint32 value) {
  set_has__hp_perc();
  _hp_perc_ = value;
}

// required uint32 _mp_perc = 3;
inline bool excavate_hero::has__mp_perc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void excavate_hero::set_has__mp_perc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void excavate_hero::clear_has__mp_perc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void excavate_hero::clear__mp_perc() {
  _mp_perc_ = 0u;
  clear_has__mp_perc();
}
inline ::google::protobuf::uint32 excavate_hero::_mp_perc() const {
  return _mp_perc_;
}
inline void excavate_hero::set__mp_perc(::google::protobuf::uint32 value) {
  set_has__mp_perc();
  _mp_perc_ = value;
}

// optional uint32 _custom_data = 4;
inline bool excavate_hero::has__custom_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void excavate_hero::set_has__custom_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void excavate_hero::clear_has__custom_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void excavate_hero::clear__custom_data() {
  _custom_data_ = 0u;
  clear_has__custom_data();
}
inline ::google::protobuf::uint32 excavate_hero::_custom_data() const {
  return _custom_data_;
}
inline void excavate_hero::set__custom_data(::google::protobuf::uint32 value) {
  set_has__custom_data();
  _custom_data_ = value;
}

// -------------------------------------------------------------------

// query_split_data

// -------------------------------------------------------------------

// query_split_return

// required uint32 _tid = 1;
inline bool query_split_return::has__tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_split_return::set_has__tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_split_return::clear_has__tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_split_return::clear__tid() {
  _tid_ = 0u;
  clear_has__tid();
}
inline ::google::protobuf::uint32 query_split_return::_tid() const {
  return _tid_;
}
inline void query_split_return::set__tid(::google::protobuf::uint32 value) {
  set_has__tid();
  _tid_ = value;
}

// -------------------------------------------------------------------

// split_hero

// required uint32 _tid = 1;
inline bool split_hero::has__tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void split_hero::set_has__tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void split_hero::clear_has__tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void split_hero::clear__tid() {
  _tid_ = 0u;
  clear_has__tid();
}
inline ::google::protobuf::uint32 split_hero::_tid() const {
  return _tid_;
}
inline void split_hero::set__tid(::google::protobuf::uint32 value) {
  set_has__tid();
  _tid_ = value;
}

// optional uint32 _stone_id = 2;
inline bool split_hero::has__stone_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void split_hero::set_has__stone_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void split_hero::clear_has__stone_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void split_hero::clear__stone_id() {
  _stone_id_ = 0u;
  clear_has__stone_id();
}
inline ::google::protobuf::uint32 split_hero::_stone_id() const {
  return _stone_id_;
}
inline void split_hero::set__stone_id(::google::protobuf::uint32 value) {
  set_has__stone_id();
  _stone_id_ = value;
}

// -------------------------------------------------------------------

// worldcup

// optional .up.worldcup_query _worldcup_query = 1;
inline bool worldcup::has__worldcup_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void worldcup::set_has__worldcup_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void worldcup::clear_has__worldcup_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void worldcup::clear__worldcup_query() {
  if (_worldcup_query_ != NULL) _worldcup_query_->::up::worldcup_query::Clear();
  clear_has__worldcup_query();
}
inline const ::up::worldcup_query& worldcup::_worldcup_query() const {
  return _worldcup_query_ != NULL ? *_worldcup_query_ : *default_instance_->_worldcup_query_;
}
inline ::up::worldcup_query* worldcup::mutable__worldcup_query() {
  set_has__worldcup_query();
  if (_worldcup_query_ == NULL) _worldcup_query_ = new ::up::worldcup_query;
  return _worldcup_query_;
}
inline ::up::worldcup_query* worldcup::release__worldcup_query() {
  clear_has__worldcup_query();
  ::up::worldcup_query* temp = _worldcup_query_;
  _worldcup_query_ = NULL;
  return temp;
}
inline void worldcup::set_allocated__worldcup_query(::up::worldcup_query* _worldcup_query) {
  delete _worldcup_query_;
  _worldcup_query_ = _worldcup_query;
  if (_worldcup_query) {
    set_has__worldcup_query();
  } else {
    clear_has__worldcup_query();
  }
}

// optional .up.worldcup_submit _worldcup_submit = 2;
inline bool worldcup::has__worldcup_submit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void worldcup::set_has__worldcup_submit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void worldcup::clear_has__worldcup_submit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void worldcup::clear__worldcup_submit() {
  if (_worldcup_submit_ != NULL) _worldcup_submit_->::up::worldcup_submit::Clear();
  clear_has__worldcup_submit();
}
inline const ::up::worldcup_submit& worldcup::_worldcup_submit() const {
  return _worldcup_submit_ != NULL ? *_worldcup_submit_ : *default_instance_->_worldcup_submit_;
}
inline ::up::worldcup_submit* worldcup::mutable__worldcup_submit() {
  set_has__worldcup_submit();
  if (_worldcup_submit_ == NULL) _worldcup_submit_ = new ::up::worldcup_submit;
  return _worldcup_submit_;
}
inline ::up::worldcup_submit* worldcup::release__worldcup_submit() {
  clear_has__worldcup_submit();
  ::up::worldcup_submit* temp = _worldcup_submit_;
  _worldcup_submit_ = NULL;
  return temp;
}
inline void worldcup::set_allocated__worldcup_submit(::up::worldcup_submit* _worldcup_submit) {
  delete _worldcup_submit_;
  _worldcup_submit_ = _worldcup_submit;
  if (_worldcup_submit) {
    set_has__worldcup_submit();
  } else {
    clear_has__worldcup_submit();
  }
}

// -------------------------------------------------------------------

// worldcup_query

// -------------------------------------------------------------------

// worldcup_submit

// required uint32 _guess1 = 1;
inline bool worldcup_submit::has__guess1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void worldcup_submit::set_has__guess1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void worldcup_submit::clear_has__guess1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void worldcup_submit::clear__guess1() {
  _guess1_ = 0u;
  clear_has__guess1();
}
inline ::google::protobuf::uint32 worldcup_submit::_guess1() const {
  return _guess1_;
}
inline void worldcup_submit::set__guess1(::google::protobuf::uint32 value) {
  set_has__guess1();
  _guess1_ = value;
}

// optional uint32 _guess2 = 2;
inline bool worldcup_submit::has__guess2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void worldcup_submit::set_has__guess2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void worldcup_submit::clear_has__guess2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void worldcup_submit::clear__guess2() {
  _guess2_ = 0u;
  clear_has__guess2();
}
inline ::google::protobuf::uint32 worldcup_submit::_guess2() const {
  return _guess2_;
}
inline void worldcup_submit::set__guess2(::google::protobuf::uint32 value) {
  set_has__guess2();
  _guess2_ = value;
}

// -------------------------------------------------------------------

// report_battle

// required uint32 _id = 1;
inline bool report_battle::has__id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void report_battle::set_has__id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void report_battle::clear_has__id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void report_battle::clear__id() {
  _id_ = 0u;
  clear_has__id();
}
inline ::google::protobuf::uint32 report_battle::_id() const {
  return _id_;
}
inline void report_battle::set__id(::google::protobuf::uint32 value) {
  set_has__id();
  _id_ = value;
}

// required bytes _data = 2;
inline bool report_battle::has__data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void report_battle::set_has__data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void report_battle::clear_has__data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void report_battle::clear__data() {
  if (_data_ != &::google::protobuf::internal::kEmptyString) {
    _data_->clear();
  }
  clear_has__data();
}
inline const ::std::string& report_battle::_data() const {
  return *_data_;
}
inline void report_battle::set__data(const ::std::string& value) {
  set_has__data();
  if (_data_ == &::google::protobuf::internal::kEmptyString) {
    _data_ = new ::std::string;
  }
  _data_->assign(value);
}
inline void report_battle::set__data(const char* value) {
  set_has__data();
  if (_data_ == &::google::protobuf::internal::kEmptyString) {
    _data_ = new ::std::string;
  }
  _data_->assign(value);
}
inline void report_battle::set__data(const void* value, size_t size) {
  set_has__data();
  if (_data_ == &::google::protobuf::internal::kEmptyString) {
    _data_ = new ::std::string;
  }
  _data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* report_battle::mutable__data() {
  set_has__data();
  if (_data_ == &::google::protobuf::internal::kEmptyString) {
    _data_ = new ::std::string;
  }
  return _data_;
}
inline ::std::string* report_battle::release__data() {
  clear_has__data();
  if (_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = _data_;
    _data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void report_battle::set_allocated__data(::std::string* _data) {
  if (_data_ != &::google::protobuf::internal::kEmptyString) {
    delete _data_;
  }
  if (_data) {
    set_has__data();
    _data_ = _data;
  } else {
    clear_has__data();
    _data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// query_ranklist

// required .up.query_ranklist.rank_type _rank_type = 1;
inline bool query_ranklist::has__rank_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_ranklist::set_has__rank_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_ranklist::clear_has__rank_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_ranklist::clear__rank_type() {
  _rank_type_ = 1;
  clear_has__rank_type();
}
inline ::up::query_ranklist_rank_type query_ranklist::_rank_type() const {
  return static_cast< ::up::query_ranklist_rank_type >(_rank_type_);
}
inline void query_ranklist::set__rank_type(::up::query_ranklist_rank_type value) {
  assert(::up::query_ranklist_rank_type_IsValid(value));
  set_has__rank_type();
  _rank_type_ = value;
}

// -------------------------------------------------------------------

// dot_info

// required uint32 _dot_id = 1;
inline bool dot_info::has__dot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dot_info::set_has__dot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dot_info::clear_has__dot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dot_info::clear__dot_id() {
  _dot_id_ = 0u;
  clear_has__dot_id();
}
inline ::google::protobuf::uint32 dot_info::_dot_id() const {
  return _dot_id_;
}
inline void dot_info::set__dot_id(::google::protobuf::uint32 value) {
  set_has__dot_id();
  _dot_id_ = value;
}

// -------------------------------------------------------------------

// require_arousal

// required uint32 _hid = 1;
inline bool require_arousal::has__hid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void require_arousal::set_has__hid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void require_arousal::clear_has__hid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void require_arousal::clear__hid() {
  _hid_ = 0u;
  clear_has__hid();
}
inline ::google::protobuf::uint32 require_arousal::_hid() const {
  return _hid_;
}
inline void require_arousal::set__hid(::google::protobuf::uint32 value) {
  set_has__hid();
  _hid_ = value;
}

// required .up.require_arousal.arousal_type _arousal_type = 2;
inline bool require_arousal::has__arousal_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void require_arousal::set_has__arousal_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void require_arousal::clear_has__arousal_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void require_arousal::clear__arousal_type() {
  _arousal_type_ = 0;
  clear_has__arousal_type();
}
inline ::up::require_arousal_arousal_type require_arousal::_arousal_type() const {
  return static_cast< ::up::require_arousal_arousal_type >(_arousal_type_);
}
inline void require_arousal::set__arousal_type(::up::require_arousal_arousal_type value) {
  assert(::up::require_arousal_arousal_type_IsValid(value));
  set_has__arousal_type();
  _arousal_type_ = value;
}

// optional uint32 _aid = 3;
inline bool require_arousal::has__aid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void require_arousal::set_has__aid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void require_arousal::clear_has__aid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void require_arousal::clear__aid() {
  _aid_ = 0u;
  clear_has__aid();
}
inline ::google::protobuf::uint32 require_arousal::_aid() const {
  return _aid_;
}
inline void require_arousal::set__aid(::google::protobuf::uint32 value) {
  set_has__aid();
  _aid_ = value;
}

// -------------------------------------------------------------------

// change_server

// required .up.server_opt_type _op_type = 1;
inline bool change_server::has__op_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void change_server::set_has__op_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void change_server::clear_has__op_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void change_server::clear__op_type() {
  _op_type_ = 0;
  clear_has__op_type();
}
inline ::up::server_opt_type change_server::_op_type() const {
  return static_cast< ::up::server_opt_type >(_op_type_);
}
inline void change_server::set__op_type(::up::server_opt_type value) {
  assert(::up::server_opt_type_IsValid(value));
  set_has__op_type();
  _op_type_ = value;
}

// optional uint32 _server_id = 2;
inline bool change_server::has__server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void change_server::set_has__server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void change_server::clear_has__server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void change_server::clear__server_id() {
  _server_id_ = 0u;
  clear_has__server_id();
}
inline ::google::protobuf::uint32 change_server::_server_id() const {
  return _server_id_;
}
inline void change_server::set__server_id(::google::protobuf::uint32 value) {
  set_has__server_id();
  _server_id_ = value;
}

// -------------------------------------------------------------------

// request_guild_log

// -------------------------------------------------------------------

// query_act_stage

// repeated uint32 _act_stage_groups = 1;
inline int query_act_stage::_act_stage_groups_size() const {
  return _act_stage_groups_.size();
}
inline void query_act_stage::clear__act_stage_groups() {
  _act_stage_groups_.Clear();
}
inline ::google::protobuf::uint32 query_act_stage::_act_stage_groups(int index) const {
  return _act_stage_groups_.Get(index);
}
inline void query_act_stage::set__act_stage_groups(int index, ::google::protobuf::uint32 value) {
  _act_stage_groups_.Set(index, value);
}
inline void query_act_stage::add__act_stage_groups(::google::protobuf::uint32 value) {
  _act_stage_groups_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
query_act_stage::_act_stage_groups() const {
  return _act_stage_groups_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
query_act_stage::mutable__act_stage_groups() {
  return &_act_stage_groups_;
}

// -------------------------------------------------------------------

// fb_attention

// required uint32 _fb_attention = 1;
inline bool fb_attention::has__fb_attention() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fb_attention::set_has__fb_attention() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fb_attention::clear_has__fb_attention() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fb_attention::clear__fb_attention() {
  _fb_attention_ = 0u;
  clear_has__fb_attention();
}
inline ::google::protobuf::uint32 fb_attention::_fb_attention() const {
  return _fb_attention_;
}
inline void fb_attention::set__fb_attention(::google::protobuf::uint32 value) {
  set_has__fb_attention();
  _fb_attention_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace up

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::system_setting_change_setting_status>() {
  return ::up::system_setting_change_setting_status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::set_money_price_type>() {
  return ::up::set_money_price_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::shop_refresh_rtype>() {
  return ::up::shop_refresh_rtype_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::hero_equip_upgrade_OP_TYPE>() {
  return ::up::hero_equip_upgrade_OP_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::reset_elite_rtype>() {
  return ::up::reset_elite_rtype_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::sweep_stage_rtype>() {
  return ::up::sweep_stage_rtype_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::tavern_draw_draw_type>() {
  return ::up::tavern_draw_draw_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::tavern_draw_box_type>() {
  return ::up::tavern_draw_box_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::query_rankboard_rankboard_type>() {
  return ::up::query_rankboard_rankboard_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::set_name_set_type>() {
  return ::up::set_name_set_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::query_data_query_type>() {
  return ::up::query_data_query_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::ask_daily_login_status>() {
  return ::up::ask_daily_login_status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::chat_acc_chat_acc_t>() {
  return ::up::chat_acc_chat_acc_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::guild_set_jump_is_can_jump>() {
  return ::up::guild_set_jump_is_can_jump_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::guild_join_confirm_confirm_type>() {
  return ::up::guild_join_confirm_confirm_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::guild_set_guild_join_t>() {
  return ::up::guild_set_guild_join_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::query_ranklist_rank_type>() {
  return ::up::query_ranklist_rank_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::require_arousal_arousal_type>() {
  return ::up::require_arousal_arousal_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::hero_status>() {
  return ::up::hero_status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::guild_job_t>() {
  return ::up::guild_job_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::hire_from>() {
  return ::up::hire_from_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::chat_channel>() {
  return ::up::chat_channel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::server_opt_type>() {
  return ::up::server_opt_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::platform_type>() {
  return ::up::platform_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::up::battle_result>() {
  return ::up::battle_result_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_up_2eproto__INCLUDED
